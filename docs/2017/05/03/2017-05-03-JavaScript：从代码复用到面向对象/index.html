<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>JavaScript：从代码复用到面向对象 | Daixinye</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="代码复用的问题12var foo = &amp;#123;color:&amp;apos;red&amp;apos;&amp;#125;;var bar = &amp;#123;color:&amp;apos;green&amp;apos;&amp;#125;; 这段代码中我们生成了两个属性相似的对象，每次生成一个类似的对象都需要重新写一遍代码。 装饰器函数添加属性123456789// lib.jsvar fn = function(obj,color)&amp;#">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript：从代码复用到面向对象">
<meta property="og:url" content="http://daixinye.com/2017/05/03/2017-05-03-JavaScript：从代码复用到面向对象/index.html">
<meta property="og:site_name" content="Daixinye">
<meta property="og:description" content="代码复用的问题12var foo = &amp;#123;color:&amp;apos;red&amp;apos;&amp;#125;;var bar = &amp;#123;color:&amp;apos;green&amp;apos;&amp;#125;; 这段代码中我们生成了两个属性相似的对象，每次生成一个类似的对象都需要重新写一遍代码。 装饰器函数添加属性123456789// lib.jsvar fn = function(obj,color)&amp;#">
<meta property="og:updated_time" content="2017-07-31T16:35:00.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JavaScript：从代码复用到面向对象">
<meta name="twitter:description" content="代码复用的问题12var foo = &amp;#123;color:&amp;apos;red&amp;apos;&amp;#125;;var bar = &amp;#123;color:&amp;apos;green&amp;apos;&amp;#125;; 这段代码中我们生成了两个属性相似的对象，每次生成一个类似的对象都需要重新写一遍代码。 装饰器函数添加属性123456789// lib.jsvar fn = function(obj,color)&amp;#">
  
    <link rel="alternate" href="/atom.xml" title="Daixinye" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Daixinye</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        <a id="nav-github" class="nav-icon" title="github" target="_blank" href="https://github.com/daixinye"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://daixinye.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-2017-05-03-JavaScript：从代码复用到面向对象" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/03/2017-05-03-JavaScript：从代码复用到面向对象/" class="article-date">
  <time datetime="2017-05-03T12:00:00.000Z" itemprop="datePublished">2017-05-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/javascript/">javascript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      JavaScript：从代码复用到面向对象
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="代码复用的问题"><a href="#代码复用的问题" class="headerlink" title="代码复用的问题"></a>代码复用的问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var foo = &#123;color:&apos;red&apos;&#125;;</div><div class="line">var bar = &#123;color:&apos;green&apos;&#125;;</div></pre></td></tr></table></figure>
<p>这段代码中我们生成了两个属性相似的对象，每次生成一个类似的对象都需要重新写一遍代码。</p>
<h2 id="装饰器函数"><a href="#装饰器函数" class="headerlink" title="装饰器函数"></a>装饰器函数</h2><h3 id="添加属性"><a href="#添加属性" class="headerlink" title="添加属性"></a>添加属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// lib.js</div><div class="line">var fn = function(obj,color)&#123;</div><div class="line">    obj.color = color;</div><div class="line">    return obj;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// app.js</div><div class="line">var foo = fn(&#123;&#125;,&apos;red&apos;);</div><div class="line">var bar = fn(&#123;&#125;,&apos;green&apos;);</div></pre></td></tr></table></figure>
<p>我们可以通过一个装饰器函数，来解决生成类似对象的问题。</p>
<p>装饰器函数的作用，就是给某个已拥有某些功能的对象添加属性。这里我们传入了一个空的对象，通过fn函数来对这个空对象进行”装饰“（添加属性）。</p>
<h3 id="添加方法"><a href="#添加方法" class="headerlink" title="添加方法"></a>添加方法</h3><h4 id="浪费内存"><a href="#浪费内存" class="headerlink" title="浪费内存"></a>浪费内存</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// lib.js</div><div class="line">var fn = function(obj,color)&#123;</div><div class="line">    obj.color = color;</div><div class="line">    obj.printColor = function()&#123;</div><div class="line">        console.log(this.color);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return obj;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// app.js</div><div class="line">var foo = fn(&#123;&#125;,&apos;red&apos;);</div><div class="line">foo.printColor(); // red</div><div class="line">var bar = fn(&#123;&#125;,&apos;green&apos;);</div><div class="line">bar.printColor(); // green</div></pre></td></tr></table></figure>
<p>上述添加方法的方式，优点是具有良好的封装性，但是最大的问题是每次调用装饰器函数都会在内存中生成一个新的<code>printColor函数</code>。在对象比较多的情况下，就容易浪费内存。</p>
<h4 id="更多的缺点"><a href="#更多的缺点" class="headerlink" title="更多的缺点"></a>更多的缺点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// lib.js</div><div class="line">var fn = function(obj,color)&#123;</div><div class="line">    obj.color = color;</div><div class="line">    obj.printColor = printColor;</div><div class="line">    return obj;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var printColor = function()&#123;</div><div class="line">    console.log(this.printColor);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// app.js</div><div class="line">var foo = fn(&#123;&#125;,&apos;red&apos;);</div><div class="line">foo.printColor(); // red</div><div class="line">var bar = fn(&#123;&#125;,&apos;green&apos;);</div><div class="line">bar.printColor(); // green</div></pre></td></tr></table></figure>
<p>上述添加方法的方式，尽管解决了内存占用的问题，但是失去了良好的封装性。</p>
<p>除此之外，如果添加的方法比较多，每次都需要在fn中对函数进行绑定，效率很低。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// lib.js</div><div class="line">var fn = function(obj,color)&#123;</div><div class="line">    obj.color = color;</div><div class="line">    obj.method_1 = method_1;</div><div class="line">    obj.method_2 = method_2;</div><div class="line">    // ...</div><div class="line">    obj.method_1000 = method_3;</div><div class="line"></div><div class="line">    return obj;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var method_1 = function()&#123; //... &#125;;</div><div class="line">var method_2 = function()&#123; //... &#125;;</div><div class="line">// ...</div><div class="line">var method_1000 = function()&#123; //... &#125;;</div></pre></td></tr></table></figure>
<h4 id="把方法都装在一起"><a href="#把方法都装在一起" class="headerlink" title="把方法都装在一起"></a>把方法都装在一起</h4><p>在把方法都装进<code>methods</code>中，通过遍历的方式可以把任意数量的方法绑定到<code>obj</code>上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// lib.js</div><div class="line">var fn = function(obj,color)&#123;</div><div class="line">    obj.color = color;</div><div class="line"></div><div class="line">    extend(obj,methods); // extend()代表把methods中的属性复制到obj中，注意它并不是原生的函数</div><div class="line"></div><div class="line">    return obj;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var methods = &#123;</div><div class="line">    method_1:function()&#123; //... &#125;,</div><div class="line">    method_2:function()&#123; //... &#125;,</div><div class="line">    // ...</div><div class="line">    method_1000:function()&#123; //... &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="借助Function对象的属性"><a href="#借助Function对象的属性" class="headerlink" title="借助Function对象的属性"></a>借助Function对象的属性</h4><p><code>methods</code>与<code>fn</code>之间没有一个非常明显的联系，为此我们可以利用<code>Function对象</code>的属性来解决。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// lib.js</div><div class="line">var fn = function(obj,color)&#123;</div><div class="line">    obj.color = color;</div><div class="line"></div><div class="line">    extend(obj, fn.methods);</div><div class="line"></div><div class="line">    return obj;</div><div class="line">&#125;</div><div class="line"></div><div class="line">fn.methods = &#123;</div><div class="line">    method_1:function()&#123; //... &#125;,</div><div class="line">    method_2:function()&#123; //... &#125;,</div><div class="line">    // ...</div><div class="line">    method_1000:function()&#123; //... &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="直接在function内部创建对象"><a href="#直接在function内部创建对象" class="headerlink" title="直接在function内部创建对象"></a>直接在function内部创建对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// lib.js</div><div class="line"></div><div class="line">var fn = function(color)&#123;</div><div class="line">    var obj = &#123;&#125;;</div><div class="line">    obj.color = color;</div><div class="line"></div><div class="line">    extend(obj, fn.methods);</div><div class="line"></div><div class="line">    return obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="原型委托"><a href="#原型委托" class="headerlink" title="原型委托"></a>原型委托</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// lib.js</div><div class="line">var fn = function(color)&#123;</div><div class="line">    var obj = Object.create(fn.methods);</div><div class="line">    obj.color = color;</div><div class="line"></div><div class="line">    return obj;</div><div class="line">&#125;</div><div class="line"></div><div class="line">fn.methods = &#123; //... &#125;;</div></pre></td></tr></table></figure>
<h3 id="使用prototype属性"><a href="#使用prototype属性" class="headerlink" title="使用prototype属性"></a>使用prototype属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// lib.js</div><div class="line">var fn = function(color)&#123;</div><div class="line">    var obj = Object.create(fn.prototype);</div><div class="line">    obj.color = color;</div><div class="line"></div><div class="line">    return obj;</div><div class="line">&#125;</div><div class="line">fn.prototype.printColor = function()&#123;</div><div class="line">    console.log(this.color);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此时<code>fn</code>就是一个“构造函数”，每一个函数对象被创建时都会有一个<code>prototype</code>属性，这个属性跟之前的<code>fn.methods</code>其实并没有太大的区别，唯一的区别在于<code>prototype.constructor</code>指向了函数对象本身。</p>
<p>在我们讨论“实例的原型”和“构造函数的原型”时要注意：“实例的原型”实际上就是<code>instance.prototype</code>，在实例中没有的属性会被委托到原型中进行查找。而“构造函数的原型”，实际上是“创建一个对象，并且把这个对象委托给原型进行函数共享”。</p>
<h3 id="关系验证"><a href="#关系验证" class="headerlink" title="关系验证"></a>关系验证</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// app.js</div><div class="line">var foo = fn(&apos;red&apos;);</div><div class="line">var bar = fn(&apos;green&apos;);</div><div class="line"></div><div class="line">console.log(foo instanceof fn); // true</div><div class="line">// instanceof 操作符 实际上执行的就是下面的操作</div><div class="line">console.log(foo.constructor == fn.prototype.construector); // true</div></pre></td></tr></table></figure>
<h3 id="new-关键字"><a href="#new-关键字" class="headerlink" title="new 关键字"></a>new 关键字</h3><p>在fn中，创建一个对象、原型委托和返回对象是一定会做的一件事情，我们可以通过<code>new关键字</code>来简化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// lib.js</div><div class="line">var fn = function(color)&#123;</div><div class="line">    this.color = color;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在使用<code>new关键字</code>进行调用时（构造模式），解释器会自动插入两行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// lib.js</div><div class="line">var fn = function(color)&#123;</div><div class="line">    this = Object.create(fn.prototype); // 将新对象委托给原型对象</div><div class="line"></div><div class="line">    this.color;</div><div class="line"></div><div class="line">    return this; // 返回这个新对象</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用构造模式即使用<code>new关键字</code>调用fn函数才能被真正称作“构造函数”。</p>
<h3 id="子类继承"><a href="#子类继承" class="headerlink" title="子类继承"></a>子类继承</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">var Human = function(name)&#123;</div><div class="line">    this.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Human.prototype.sayName = function()&#123;</div><div class="line">    console.log(this.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var Man = function(name)&#123;</div><div class="line">    Human.call(this, name);</div><div class="line">    this.sex = &apos;male&apos;;</div><div class="line">&#125;</div><div class="line">Man.prototype = Object.create(Human.prototype);</div><div class="line">Man.prototype.constructor = Man;</div><div class="line"></div><div class="line">var frank = new Man(&apos;frank&apos;);</div><div class="line"></div><div class="line">frank.sayName(); // frank</div><div class="line">console.log(frank instanceof Man); // true</div><div class="line">console.log(frank instanceof Human); // true</div></pre></td></tr></table></figure>
<p>务必注意<code>Man</code>继承<code>Human</code>时调用的<code>Human</code>方法，其使用<code>call</code>方法指定了<code>this</code>绑定的对象。<code>this</code>在JavaScript中可以作为一个传入的参数来看待，在使用<code>obj.method()</code>时，<code>method</code>中的<code>this</code>指向<code>obj</code>，而使用<code>new method()</code>时，<code>this</code>指向新构造的空对象。</p>
<p>此外，<code>Man.prototype</code>对象的原型委托给了<code>Human.prototype</code>形成了原型链<code>。</code>这里还需要注意要重新指定<code>Man.prototype.constructor</code>赋值<code>Man</code>。</p>

      
    </div>
    <footer class="article-footer">
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/05/08/2017-05-08-JavaScript：逻辑与 与 逻辑或/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          JavaScript：逻辑与 与 逻辑或
        
      </div>
    </a>
  
  
    <a href="/2017/04/27/2017-04-27-JavaScript：作用域、闭包 和 this/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">JavaScript：作用域、闭包 和 this</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/css/">css</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/fe/">fe</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/http/">http</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/javascript/">javascript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/jquery/">jquery</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mac/">mac</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/react/">react</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/shell/">shell</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/sublime/">sublime</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/svn/">svn</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/vue/">vue</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/08/04/奇怪的JavaScript（1）/">奇怪的JavaScript（1）：基础类型篇</a>
          </li>
        
          <li>
            <a href="/2017/07/06/2017-07-06-Shell 脚本入门/">Shell 脚本入门</a>
          </li>
        
          <li>
            <a href="/2017/07/05/2017-07-05-CSS：什么是 BFC/">CSS：什么是 BFC</a>
          </li>
        
          <li>
            <a href="/2017/06/21/2017-06-21-Vue：基础用法与指令/">Vue：基础用法与指令</a>
          </li>
        
          <li>
            <a href="/2017/06/21/2017-06-21-CSS：Animation 动画/">CSS：Animation 动画小记</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 Xinye Dai<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>