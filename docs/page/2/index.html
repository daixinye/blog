<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Daixinye</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Daixinye">
<meta property="og:url" content="http://daixinye.com/page/2/index.html">
<meta property="og:site_name" content="Daixinye">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Daixinye">
  
    <link rel="alternate" href="/atom.xml" title="Daixinye" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Daixinye</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        <a id="nav-github" class="nav-icon" title="github" target="_blank" href="https://github.com/daixinye"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://daixinye.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-2017-05-23-什么是Hybrid App" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/23/2017-05-23-什么是Hybrid App/" class="article-date">
  <time datetime="2017-05-23T07:30:00.000Z" itemprop="datePublished">2017-05-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/23/2017-05-23-什么是Hybrid App/">什么是Hybrid App</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="什么是Hybrid"><a href="#什么是Hybrid" class="headerlink" title="什么是Hybrid"></a>什么是Hybrid</h2><h3 id="Hybrid-出现的历史原因"><a href="#Hybrid-出现的历史原因" class="headerlink" title="Hybrid 出现的历史原因"></a>Hybrid 出现的历史原因</h3><ul>
<li>2013年起移动互联网的兴起导致App开发的需求日益高涨。</li>
<li>2014年 H5 的发布，使得 Web 能够实现更多功能。</li>
<li>在产品需要快速迭代、抢占市场的大背景下，开发 iOS 和 Android 原生应用的时间成本和劳动成本都非常高。</li>
<li>随着 iOS 和 Android 两大阵营对 H5 的支持日益完善，H5 足以实现大多数的需求。</li>
<li>为了利用 Web 应用低成本、高效率、跨成本等诸多优点，出现了使用 Web 和 Native 混合进行开发的模式。</li>
</ul>
<h3 id="Hybrid-的分类"><a href="#Hybrid-的分类" class="headerlink" title="Hybrid 的分类"></a>Hybrid 的分类</h3><p>App 应用从实现机制上来区分，主要分为三类：</p>
<ol>
<li>Native 应用：使用原生语言的应用，能够调用所有底层接口，交互体验最好。</li>
<li>Web App 应用：使用纯 Web 开发的应用，通过浏览器访问，交互体验最差。</li>
<li>Hybrid 应用：<ol>
<li>以 WebView 作为用户界面层，以 JavaScript 为基本逻辑通过与中间件通讯、访问底层 API ，进行应用开发。</li>
<li>使用非官方语言的工具，打包成原生应用的方式开发。</li>
<li>基于原生应用的架构，在部分功能中嵌入 WebView 。WebView 负责对界面的渲染，同时也可以访问底层的 API 以实现特定的功能。</li>
<li>通过 JavaScript 引擎管理和渲染 native 视图，将 JavaScript 代码渲染成原生组件，调用原生 API 与用户进行交互。（ReactNative、Weex）</li>
</ol>
</li>
</ol>
<h3 id="Hybrid-的优势"><a href="#Hybrid-的优势" class="headerlink" title="Hybrid 的优势"></a>Hybrid 的优势</h3><ul>
<li>开发效率高</li>
<li>开发成本低</li>
<li>跨平台</li>
<li>快速迭代，无需发布版本即可修复Bug</li>
</ul>
<p>总结来说，Hybrid 是既保持了对原生API的完整掌控，同时可以在特定功能下节省跨平台开发成本、提升效率。</p>
<h3 id="Hybrid-的劣势"><a href="#Hybrid-的劣势" class="headerlink" title="Hybrid 的劣势"></a>Hybrid 的劣势</h3><ul>
<li>容易造成性能问题，不适用于依赖原生 API 、动画较多和游戏开发的需求。</li>
<li>永远保持最新（直接访问线上，而不是使用 App 本地的静态资源）带来的低版本机型的适配问题，包括调用底层 API 和对 H5 的支持方面。（即不太好做版本控制）</li>
<li>需要实现 Native 与 H5 之间的通信机制</li>
<li>交互体验不如原生页面，需要尽可能仿制原生应用的体验</li>
</ul>
<p>总结来说，Web 只能替代、辅助一部分功能，无法取代原生开发的主导地位。</p>
<h2 id="Hybrid-实现"><a href="#Hybrid-实现" class="headerlink" title="Hybrid 实现"></a>Hybrid 实现</h2><h3 id="Native-与前端之间的关系"><a href="#Native-与前端之间的关系" class="headerlink" title="Native 与前端之间的关系"></a>Native 与前端之间的关系</h3><p>Hybrid App 底层依赖于 Native 提供的容器，上层使用 H5 做业务开发，底层透明化、上层多样化，适合前端介入进行快速迭代开发。</p>
<p>Native 提供的实际上是类似于浏览器的宿主环境，H5 页面可以利用宿主环境提供的“能力”来进行开发。正如一般浏览器为 JavaScript 提供了 window 对象以控制浏览器一样，Native 也可以为 H5 页面提供特定的接口以调用底层的 API。</p>
<h3 id="Hybrid-交互设计"><a href="#Hybrid-交互设计" class="headerlink" title="Hybrid 交互设计"></a>Hybrid 交互设计</h3><p>Native 可以调用前端页面的 JavaScript 方法对视图进行操作，前端页面也可以通过 JavaScript 方法调用 Native 提供的接口实现系统层面的功能。两者沟通的桥梁则是 WebView。</p>
<h3 id="Schema"><a href="#Schema" class="headerlink" title="Schema"></a><img src="/images/FE-Hybrid-interaction.png" alt="">Schema</h3><p>App 自身可以自定义 URL Schema，并且把自定义的 URL 注册在调度中心。App 安装后会在手机上注册一个 Schema，例如淘宝是 taobao:// ，Native 会有一个进程监控 WebView 发出的所有 schema:// 请求，从而打开 Native 应用并传入参数执行特定的行为。</p>
<p>通过 Schema ，H5 可以通过发起 schema 请求，来实现 H5 与 Native 页面之间的跳转。</p>
<h3 id="常用交互-API"><a href="#常用交互-API" class="headerlink" title="常用交互 API"></a>常用交互 API</h3><ul>
<li>跳转<ul>
<li>页面内部跳转</li>
<li>H5 跳转 Native 界面，Native 通过截获 URL 参数跳转到响应页面。</li>
<li>H5 新打开一个 WebView。</li>
</ul>
</li>
<li>Header 组件<ul>
<li>避免白屏陷入假死状态</li>
<li>Header 左侧和右侧按钮可配置，中间 title 部分可配置</li>
</ul>
</li>
<li>请求类<ul>
<li>通过 Native 代理发起 AJAX 请求，解决跨域问题</li>
</ul>
</li>
<li>Native UI 组件<ul>
<li>Loading 组件</li>
<li>Toast 组件</li>
</ul>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/yexiaochai/p/4921635.html" target="_blank" rel="external">http://www.cnblogs.com/yexiaochai/p/4921635.html</a></p>
<p><a href="http://ued.ctrip.com/blog/translation-hybrid-mobile-application-provide-native-web-technology-experience.html" target="_blank" rel="external">http://ued.ctrip.com/blog/translation-hybrid-mobile-application-provide-native-web-technology-experience.html</a></p>
<p><a href="https://dailc.github.io/2016/10/04/hybridBase01HybridInfo.html" target="_blank" rel="external">https://dailc.github.io/2016/10/04/hybridBase01HybridInfo.html</a></p>
<p><a href="https://dailc.github.io/2016/10/04/hybridBase02HybridCompareOthers.html" target="_blank" rel="external">https://dailc.github.io/2016/10/04/hybridBase02HybridCompareOthers.html</a></p>
<p><a href="https://weex.apache.org/cn/" target="_blank" rel="external">https://weex.apache.org/cn/</a></p>
<p><a href="http://www.infoq.com/cn/articles/hybrid-app-development-combat#note-bottom-anchor" target="_blank" rel="external">http://www.infoq.com/cn/articles/hybrid-app-development-combat#note-bottom-anchor</a></p>
<p><a href="http://www.jianshu.com/p/e83aa2d1ade3" target="_blank" rel="external">http://www.jianshu.com/p/e83aa2d1ade3</a></p>

      
    </div>
    <footer class="article-footer">
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/fe/">fe</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2017-05-19-JSON：JSON 方法小记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/19/2017-05-19-JSON：JSON 方法小记/" class="article-date">
  <time datetime="2017-05-19T12:00:00.000Z" itemprop="datePublished">2017-05-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/19/2017-05-19-JSON：JSON 方法小记/">JSON：JSON 方法小记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="JSON-parse"><a href="#JSON-parse" class="headerlink" title="JSON.parse()"></a>JSON.parse()</h2><blockquote>
<p>JSON.parse( text[, reviver] )</p>
</blockquote>
<ul>
<li><p>text : 要被解析成 JavaScript 值的字符串</p>
</li>
<li><p>reviver : 规定原始值如何被解析改造的函数</p>
</li>
</ul>
<h3 id="reviver-函数"><a href="#reviver-函数" class="headerlink" title="reviver 函数"></a>reviver 函数</h3><p>解析值本身以及它所包含的值，从里向外调用去调用 <code>reviver</code> 函数。属性名和属性值会作为参数传入 <code>reviver</code> 中，如果 <code>reviver</code> 返回 <code>undefined</code> ，那么当前属性就会从对象中删除；如果返回其他值，返回值就会作为当前属性新的属性值。</p>
<p>注意，遍历到顶层时，传入 <code>reviver</code> 函数的是空字符串和当前对象，即<code>{&quot;&quot; : 修改过的解析值 }</code>。这是个特例，需要特别注意。</p>
<p>所以 <code>reviver</code> 函数有基本两种种用法：</p>
<p>1、删除特定属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var str = &apos;&#123;&quot;a&quot;:1, &quot;b&quot;:2&#125;&apos;;</div><div class="line"></div><div class="line">// 将属性值置为 undefined 删除属性</div><div class="line">var json = JSON.parse(str,function(key, value)&#123;</div><div class="line">    return key == &apos;a&apos; ? undefined : value;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">console.log(json); // &#123;b:2&#125;</div></pre></td></tr></table></figure>
<p>2、修改特定属性的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var str = &apos;&#123;&quot;a&quot;:1, &quot;b&quot;:2&#125;&apos;;</div><div class="line"></div><div class="line">var json = JSON.parse(str, function(key, value)&#123;</div><div class="line">    return key == &apos;a&apos; ? value * 2 : value;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">console.log(json); // &#123;a:2, b:4&#125;</div></pre></td></tr></table></figure>
<h2 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify()"></a>JSON.stringify()</h2><blockquote>
<p>JSON.stringify value[, replacer[, space ]] )</p>
</blockquote>
<ul>
<li>value : 要被转换成 JSON 字符串的值</li>
<li>replacer : 规定如何转换和处理值的属性</li>
<li>space : 指定缩进用的空白字符串</li>
</ul>
<h3 id="replacer-参数"><a href="#replacer-参数" class="headerlink" title="replacer 参数"></a>replacer 参数</h3><h4 id="传入函数"><a href="#传入函数" class="headerlink" title="传入函数"></a>传入函数</h4><p>返回 <code>undefined</code> 代表不输出该属性；输出其他（包括 <code>null</code> ）都会替代原来的属性值输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function replacer(key, value) &#123;</div><div class="line">  if (typeof value === &quot;string&quot;) &#123;</div><div class="line">    return undefined;</div><div class="line">  &#125;</div><div class="line">  return value;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var foo = &#123;foundation: &quot;Mozilla&quot;, model: &quot;box&quot;, week: 45, transport: &quot;car&quot;, month: 7&#125;;</div><div class="line">var jsonString = JSON.stringify(foo, replacer);</div><div class="line"></div><div class="line">console.log(jsonString); // &#123;&quot;week&quot;:45,&quot;month&quot;:7&#125;</div></pre></td></tr></table></figure>
<h4 id="传入数组"><a href="#传入数组" class="headerlink" title="传入数组"></a>传入数组</h4><p>根据属性名指定哪些属性会被输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var foo = &#123;foundation: &quot;Mozilla&quot;, model: &quot;box&quot;, week: 45, transport: &quot;car&quot;, month: 7&#125;;</div><div class="line">var jsonString = JSON.stringify(foo, [&apos;week&apos;,&apos;model&apos;]);</div><div class="line"></div><div class="line">console.log(jsonString); // &#123;&quot;week&quot;:45,&quot;model&quot;:&quot;box&quot;&#125;</div></pre></td></tr></table></figure>
<h4 id="传入-undefined-或-null"><a href="#传入-undefined-或-null" class="headerlink" title="传入 undefined 或 null"></a>传入 <code>undefined</code> 或 <code>null</code></h4><p>输出所有的属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var foo = &#123;foundation: &quot;Mozilla&quot;, model: &quot;box&quot;, week: 45, transport: &quot;car&quot;, month: 7&#125;;</div><div class="line">var jsonString = JSON.stringify(foo, null);</div><div class="line"></div><div class="line">console.log(jsonString); // &#123;&quot;foundation&quot;:&quot;Mozilla&quot;,&quot;model&quot;:&quot;box&quot;,&quot;week&quot;:45,&quot;transport&quot;:&quot;car&quot;,&quot;month&quot;:7&#125;</div></pre></td></tr></table></figure>
<h3 id="space-参数"><a href="#space-参数" class="headerlink" title="space 参数"></a>space 参数</h3><p>指定缩进用的空白字符串，用于美化输出。</p>
<p>如果参数是数字，就代表有多少空格，上限是10；</p>
<p>如果参数是字符串，则为该字符串的前10个字母；</p>
<p>如果参数没有提供，就意味着没有空格。</p>
<p>除此之外，也可以传入转义字符（ <code>\t</code> ）来用 tab 进行缩进。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse" target="_blank" rel="external">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse</a></p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify" target="_blank" rel="external">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify</a></p>

      
    </div>
    <footer class="article-footer">
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2017-05-08-JavaScript：逻辑与 与 逻辑或" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/08/2017-05-08-JavaScript：逻辑与 与 逻辑或/" class="article-date">
  <time datetime="2017-05-08T12:00:00.000Z" itemprop="datePublished">2017-05-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/08/2017-05-08-JavaScript：逻辑与 与 逻辑或/">JavaScript：逻辑与 与 逻辑或</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="逻辑与"><a href="#逻辑与" class="headerlink" title="逻辑与"></a>逻辑与</h2><p>逻辑与是<strong>短路操作</strong>，如果第一个<strong>操作数</strong>能够决定结果，那么将不会对接下来的<strong>操作数</strong>进行<strong>求值</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var a = 0,</div><div class="line">    b = 1;</div><div class="line"></div><div class="line">a &amp;&amp; b++;</div><div class="line"></div><div class="line">console.log(a); // 0</div><div class="line">console.log(b); // 1, b++没有执行</div></pre></td></tr></table></figure>
<h3 id="表达式语句的值"><a href="#表达式语句的值" class="headerlink" title="表达式语句的值"></a>表达式语句的值</h3><p>如果操作数都是<code>True</code>（对象、非空字符串、非<code>0</code>或<code>NaN</code>的数字、布尔值<code>True</code>），则返回最后一个操作数。</p>
<p>如果操作数中有若干个<code>False</code>（<code>Null</code>、<code>Undefined</code>、空字符串、<code>NaN</code>、布尔值<code>False</code>），则返回第一个<code>False</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;&#125; &amp;&amp; false ; // false</div><div class="line">&#123;&#125; &amp;&amp; 0; // 0</div><div class="line">&#123;&#125; &amp;&amp; null; // null</div><div class="line">&#123;&#125; &amp;&amp; undefined; // undefined</div><div class="line"></div><div class="line">null &amp;&amp; 0; // null</div><div class="line"></div><div class="line">&#123;a:1&#125; &amp;&amp; &#123;b:1&#125; &amp;&amp; &#123;c:1&#125;; // &#123;c:1&#125;</div></pre></td></tr></table></figure>
<p>与函数相结合</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">true &amp;&amp; foo(); // 执行foo</div><div class="line">true &amp;&amp; false &amp;&amp; foo(); // 返回false，不执行foo</div></pre></td></tr></table></figure>
<h2 id="逻辑或"><a href="#逻辑或" class="headerlink" title="逻辑或"></a>逻辑或</h2><p>逻辑或与逻辑与一样，也是<strong>短路操作</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var a = 0,</div><div class="line">    b = 1;</div><div class="line"></div><div class="line">b || a++;</div><div class="line"></div><div class="line">console.log(a); // 0</div><div class="line">console.log(b); // 1</div></pre></td></tr></table></figure>
<h3 id="表达式语句的值-1"><a href="#表达式语句的值-1" class="headerlink" title="表达式语句的值"></a>表达式语句的值</h3><p>如果操作数都是False，则返回最后一个操作数。</p>
<p>如果操作数中有若干个True，则返回第一个True。</p>
<p>逻辑或一般用于避免给变量赋null或undefined值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var foo = null;</div><div class="line">    bar = 1;</div><div class="line"></div><div class="line">var value = foo || bar;</div></pre></td></tr></table></figure>
<p>也可以用来在函数中对参数进行校验，下面三个函数等价，但是显然第一个是最优雅的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function(v)&#123;</div><div class="line">    var value = v || defaultValue;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function(v)&#123;</div><div class="line">    var value = !!v ? v : defaultValue;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function(v)&#123;</div><div class="line">    if(v)&#123;</div><div class="line">        var value = v;</div><div class="line">    &#125;else&#123;</div><div class="line">        var value = defaultValue;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2017-05-03-JavaScript：从代码复用到面向对象" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/03/2017-05-03-JavaScript：从代码复用到面向对象/" class="article-date">
  <time datetime="2017-05-03T12:00:00.000Z" itemprop="datePublished">2017-05-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/03/2017-05-03-JavaScript：从代码复用到面向对象/">JavaScript：从代码复用到面向对象</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="代码复用的问题"><a href="#代码复用的问题" class="headerlink" title="代码复用的问题"></a>代码复用的问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var foo = &#123;color:&apos;red&apos;&#125;;</div><div class="line">var bar = &#123;color:&apos;green&apos;&#125;;</div></pre></td></tr></table></figure>
<p>这段代码中我们生成了两个属性相似的对象，每次生成一个类似的对象都需要重新写一遍代码。</p>
<h2 id="装饰器函数"><a href="#装饰器函数" class="headerlink" title="装饰器函数"></a>装饰器函数</h2><h3 id="添加属性"><a href="#添加属性" class="headerlink" title="添加属性"></a>添加属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// lib.js</div><div class="line">var fn = function(obj,color)&#123;</div><div class="line">    obj.color = color;</div><div class="line">    return obj;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// app.js</div><div class="line">var foo = fn(&#123;&#125;,&apos;red&apos;);</div><div class="line">var bar = fn(&#123;&#125;,&apos;green&apos;);</div></pre></td></tr></table></figure>
<p>我们可以通过一个装饰器函数，来解决生成类似对象的问题。</p>
<p>装饰器函数的作用，就是给某个已拥有某些功能的对象添加属性。这里我们传入了一个空的对象，通过fn函数来对这个空对象进行”装饰“（添加属性）。</p>
<h3 id="添加方法"><a href="#添加方法" class="headerlink" title="添加方法"></a>添加方法</h3><h4 id="浪费内存"><a href="#浪费内存" class="headerlink" title="浪费内存"></a>浪费内存</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// lib.js</div><div class="line">var fn = function(obj,color)&#123;</div><div class="line">    obj.color = color;</div><div class="line">    obj.printColor = function()&#123;</div><div class="line">        console.log(this.color);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return obj;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// app.js</div><div class="line">var foo = fn(&#123;&#125;,&apos;red&apos;);</div><div class="line">foo.printColor(); // red</div><div class="line">var bar = fn(&#123;&#125;,&apos;green&apos;);</div><div class="line">bar.printColor(); // green</div></pre></td></tr></table></figure>
<p>上述添加方法的方式，优点是具有良好的封装性，但是最大的问题是每次调用装饰器函数都会在内存中生成一个新的<code>printColor函数</code>。在对象比较多的情况下，就容易浪费内存。</p>
<h4 id="更多的缺点"><a href="#更多的缺点" class="headerlink" title="更多的缺点"></a>更多的缺点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// lib.js</div><div class="line">var fn = function(obj,color)&#123;</div><div class="line">    obj.color = color;</div><div class="line">    obj.printColor = printColor;</div><div class="line">    return obj;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var printColor = function()&#123;</div><div class="line">    console.log(this.printColor);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// app.js</div><div class="line">var foo = fn(&#123;&#125;,&apos;red&apos;);</div><div class="line">foo.printColor(); // red</div><div class="line">var bar = fn(&#123;&#125;,&apos;green&apos;);</div><div class="line">bar.printColor(); // green</div></pre></td></tr></table></figure>
<p>上述添加方法的方式，尽管解决了内存占用的问题，但是失去了良好的封装性。</p>
<p>除此之外，如果添加的方法比较多，每次都需要在fn中对函数进行绑定，效率很低。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// lib.js</div><div class="line">var fn = function(obj,color)&#123;</div><div class="line">    obj.color = color;</div><div class="line">    obj.method_1 = method_1;</div><div class="line">    obj.method_2 = method_2;</div><div class="line">    // ...</div><div class="line">    obj.method_1000 = method_3;</div><div class="line"></div><div class="line">    return obj;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var method_1 = function()&#123; //... &#125;;</div><div class="line">var method_2 = function()&#123; //... &#125;;</div><div class="line">// ...</div><div class="line">var method_1000 = function()&#123; //... &#125;;</div></pre></td></tr></table></figure>
<h4 id="把方法都装在一起"><a href="#把方法都装在一起" class="headerlink" title="把方法都装在一起"></a>把方法都装在一起</h4><p>在把方法都装进<code>methods</code>中，通过遍历的方式可以把任意数量的方法绑定到<code>obj</code>上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// lib.js</div><div class="line">var fn = function(obj,color)&#123;</div><div class="line">    obj.color = color;</div><div class="line"></div><div class="line">    extend(obj,methods); // extend()代表把methods中的属性复制到obj中，注意它并不是原生的函数</div><div class="line"></div><div class="line">    return obj;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var methods = &#123;</div><div class="line">    method_1:function()&#123; //... &#125;,</div><div class="line">    method_2:function()&#123; //... &#125;,</div><div class="line">    // ...</div><div class="line">    method_1000:function()&#123; //... &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="借助Function对象的属性"><a href="#借助Function对象的属性" class="headerlink" title="借助Function对象的属性"></a>借助Function对象的属性</h4><p><code>methods</code>与<code>fn</code>之间没有一个非常明显的联系，为此我们可以利用<code>Function对象</code>的属性来解决。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// lib.js</div><div class="line">var fn = function(obj,color)&#123;</div><div class="line">    obj.color = color;</div><div class="line"></div><div class="line">    extend(obj, fn.methods);</div><div class="line"></div><div class="line">    return obj;</div><div class="line">&#125;</div><div class="line"></div><div class="line">fn.methods = &#123;</div><div class="line">    method_1:function()&#123; //... &#125;,</div><div class="line">    method_2:function()&#123; //... &#125;,</div><div class="line">    // ...</div><div class="line">    method_1000:function()&#123; //... &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="直接在function内部创建对象"><a href="#直接在function内部创建对象" class="headerlink" title="直接在function内部创建对象"></a>直接在function内部创建对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// lib.js</div><div class="line"></div><div class="line">var fn = function(color)&#123;</div><div class="line">    var obj = &#123;&#125;;</div><div class="line">    obj.color = color;</div><div class="line"></div><div class="line">    extend(obj, fn.methods);</div><div class="line"></div><div class="line">    return obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="原型委托"><a href="#原型委托" class="headerlink" title="原型委托"></a>原型委托</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// lib.js</div><div class="line">var fn = function(color)&#123;</div><div class="line">    var obj = Object.create(fn.methods);</div><div class="line">    obj.color = color;</div><div class="line"></div><div class="line">    return obj;</div><div class="line">&#125;</div><div class="line"></div><div class="line">fn.methods = &#123; //... &#125;;</div></pre></td></tr></table></figure>
<h3 id="使用prototype属性"><a href="#使用prototype属性" class="headerlink" title="使用prototype属性"></a>使用prototype属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// lib.js</div><div class="line">var fn = function(color)&#123;</div><div class="line">    var obj = Object.create(fn.prototype);</div><div class="line">    obj.color = color;</div><div class="line"></div><div class="line">    return obj;</div><div class="line">&#125;</div><div class="line">fn.prototype.printColor = function()&#123;</div><div class="line">    console.log(this.color);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此时<code>fn</code>就是一个“构造函数”，每一个函数对象被创建时都会有一个<code>prototype</code>属性，这个属性跟之前的<code>fn.methods</code>其实并没有太大的区别，唯一的区别在于<code>prototype.constructor</code>指向了函数对象本身。</p>
<p>在我们讨论“实例的原型”和“构造函数的原型”时要注意：“实例的原型”实际上就是<code>instance.prototype</code>，在实例中没有的属性会被委托到原型中进行查找。而“构造函数的原型”，实际上是“创建一个对象，并且把这个对象委托给原型进行函数共享”。</p>
<h3 id="关系验证"><a href="#关系验证" class="headerlink" title="关系验证"></a>关系验证</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// app.js</div><div class="line">var foo = fn(&apos;red&apos;);</div><div class="line">var bar = fn(&apos;green&apos;);</div><div class="line"></div><div class="line">console.log(foo instanceof fn); // true</div><div class="line">// instanceof 操作符 实际上执行的就是下面的操作</div><div class="line">console.log(foo.constructor == fn.prototype.construector); // true</div></pre></td></tr></table></figure>
<h3 id="new-关键字"><a href="#new-关键字" class="headerlink" title="new 关键字"></a>new 关键字</h3><p>在fn中，创建一个对象、原型委托和返回对象是一定会做的一件事情，我们可以通过<code>new关键字</code>来简化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// lib.js</div><div class="line">var fn = function(color)&#123;</div><div class="line">    this.color = color;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在使用<code>new关键字</code>进行调用时（构造模式），解释器会自动插入两行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// lib.js</div><div class="line">var fn = function(color)&#123;</div><div class="line">    this = Object.create(fn.prototype); // 将新对象委托给原型对象</div><div class="line"></div><div class="line">    this.color;</div><div class="line"></div><div class="line">    return this; // 返回这个新对象</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用构造模式即使用<code>new关键字</code>调用fn函数才能被真正称作“构造函数”。</p>
<h3 id="子类继承"><a href="#子类继承" class="headerlink" title="子类继承"></a>子类继承</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">var Human = function(name)&#123;</div><div class="line">    this.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Human.prototype.sayName = function()&#123;</div><div class="line">    console.log(this.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var Man = function(name)&#123;</div><div class="line">    Human.call(this, name);</div><div class="line">    this.sex = &apos;male&apos;;</div><div class="line">&#125;</div><div class="line">Man.prototype = Object.create(Human.prototype);</div><div class="line">Man.prototype.constructor = Man;</div><div class="line"></div><div class="line">var frank = new Man(&apos;frank&apos;);</div><div class="line"></div><div class="line">frank.sayName(); // frank</div><div class="line">console.log(frank instanceof Man); // true</div><div class="line">console.log(frank instanceof Human); // true</div></pre></td></tr></table></figure>
<p>务必注意<code>Man</code>继承<code>Human</code>时调用的<code>Human</code>方法，其使用<code>call</code>方法指定了<code>this</code>绑定的对象。<code>this</code>在JavaScript中可以作为一个传入的参数来看待，在使用<code>obj.method()</code>时，<code>method</code>中的<code>this</code>指向<code>obj</code>，而使用<code>new method()</code>时，<code>this</code>指向新构造的空对象。</p>
<p>此外，<code>Man.prototype</code>对象的原型委托给了<code>Human.prototype</code>形成了原型链<code>。</code>这里还需要注意要重新指定<code>Man.prototype.constructor</code>赋值<code>Man</code>。</p>

      
    </div>
    <footer class="article-footer">
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2017-04-27-JavaScript：作用域、闭包 和 this" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/27/2017-04-27-JavaScript：作用域、闭包 和 this/" class="article-date">
  <time datetime="2017-04-27T12:00:00.000Z" itemprop="datePublished">2017-04-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/27/2017-04-27-JavaScript：作用域、闭包 和 this/">JavaScript：作用域、闭包 和 this</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="作用域（Scope）"><a href="#作用域（Scope）" class="headerlink" title="作用域（Scope）"></a>作用域（Scope）</h2><p>在JavaScript中，函数的一对花括号中会产生一个新的作用域。这个作用域只有函数内部能够访问。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var a = 1;</div><div class="line">var fn = function()&#123;</div><div class="line">    var b = 2;</div><div class="line">    console.log(b);</div><div class="line">&#125;</div><div class="line"></div><div class="line">console.log(a); // 1</div><div class="line">fn(); // 2</div><div class="line">console.log(b); // Error</div></pre></td></tr></table></figure>
<p>需要注意的是，if、while、for语句的语句块也是一对花括号构成，但是这对花括号并没有形成新的作用域。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var a = 1;</div><div class="line"></div><div class="line">if(a)&#123;</div><div class="line">    var b = 2;</div><div class="line">    console.log(b); // 2</div><div class="line">&#125;</div><div class="line"></div><div class="line">console.log(a); // 1</div><div class="line">console.log(b); // 2，可以获取if()&#123;&#125;中的变量b</div></pre></td></tr></table></figure>
<p>while、for语句同理。</p>
<h3 id="执行上下文（Excution-context）"><a href="#执行上下文（Excution-context）" class="headerlink" title="执行上下文（Excution context）"></a>执行上下文（Excution context）</h3><p>执行上下文是内存中存储的作用域结构，也叫内存作用域。根据执行上下文，我们可以知道哪些变量是可以被访问的，而哪些变量是在作用域之外的。<img src="/assets/javascript-excution-context.png" alt="">需要注意的是，函数在没有被执行之前，我们只需要记下”函数的位置“即可，到真正被调用的时候，再去计算里面的值，此时就需要注意作用域的问题了。</p>
<h2 id="闭包（Closure）"><a href="#闭包（Closure）" class="headerlink" title="闭包（Closure）"></a>闭包（Closure）</h2><p>由于每个函数可以访问包围它的作用域中的变量，所以闭包指的就是，在外部作用域已经返回之后还能访问该作用域的任意函数。</p>
<p>简单来说，就是能访问函数内部作用域的函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function closure()&#123;</div><div class="line">    var a = 1;</div><div class="line">    </div><div class="line">    return function()&#123;</div><div class="line">        console.log(a);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">closure()(); // 1</div></pre></td></tr></table></figure>
<p>返回的匿名函数可以访问closure的作用域，故能够获取变量a的值。此时，这个返回的匿名函数就是一个闭包。</p>
<p>闭包能够访问一个函数内部的私有变量，这个私有变量是外部作用域永远无法访问的。</p>
<p>透彻理解解释器执行代码时的工作方式，以及变量作用域和闭包，对JS面向对象编程是至关重要的。</p>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><blockquote>
<p>对this最好的理解，是把它看做函数被调用时传入的参数。</p>
</blockquote>
<p>在函数没有被调用前，我们永远无法得知this指向哪一个对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">var fn = function(one, two)&#123;</div><div class="line">    console.log(one, two);</div><div class="line">&#125;</div><div class="line">var r=&#123;&#125;, g=&#123;&#125;, b=&#123;&#125;, y=&#123;&#125;;</div><div class="line"></div><div class="line">r.method = fn;</div><div class="line"></div><div class="line">r.method(); // this=r, one=undefined, two=undefined</div><div class="line">fn(g,b);  // Global, g, b</div><div class="line">fn.call(r, g, b); // r, g, b</div><div class="line">r.method.call(y, g, b); // y, g, b</div><div class="line"></div><div class="line">setTimeout(fn, 1000); // this的值不确定，undefined, undefined</div><div class="line">setTimeout(r.method, 1000); // this的值不确定（跟r无关），undefined,undefined</div><div class="line">setTimeout(function()&#123;</div><div class="line">    r.method(); // r, undefined, undefined </div><div class="line">    &#125;,1000); </div><div class="line"></div><div class="line">console.log(one); // Referrence Error</div><div class="line">console.log(this); // Global</div><div class="line">new r.method(g, b); // &#123;&#125;, g, b</div></pre></td></tr></table></figure>
<p>上面的代码例子中注意<code>setTimeout(r.method, 1000)</code>和<code>new r.method(g ,b)</code>。</p>
<h3 id="注意点1：其实是同一个function对象"><a href="#注意点1：其实是同一个function对象" class="headerlink" title="注意点1：其实是同一个function对象"></a>注意点1：其实是同一个function对象</h3><p>实际上<code>r.method</code>和<code>fn</code>指向的是同一个function对象，只是两者在执行时，传入的是不同的<code>this</code>参数。</p>
<p>所以以下两个语句是相等的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">setTimeout(r.method, 1000);</div><div class="line"></div><div class="line">setTimeout(fn, 1000);</div></pre></td></tr></table></figure>
<h3 id="注意点2：new关键字的作用"><a href="#注意点2：new关键字的作用" class="headerlink" title="注意点2：new关键字的作用"></a>注意点2：new关键字的作用</h3><p><code>new</code>关键字执行了以下几步：</p>
<ul>
<li>创建一个空对象</li>
<li>把函数的this指向这个空对象</li>
<li>执行这个函数</li>
<li>返回创建的对象</li>
</ul>
<p>所以下面三条语句实际上是相等的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">new r.method(g, b);</div><div class="line"></div><div class="line">r.method.call(&#123;&#125;,g,b);</div><div class="line"></div><div class="line">fn.call(&#123;&#125;,g,b);</div></pre></td></tr></table></figure>
<p>全程，其实跟<code>r</code>一点关系都没有。</p>

      
    </div>
    <footer class="article-footer">
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2017-04-26-jQuery：事件监听用法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/26/2017-04-26-jQuery：事件监听用法/" class="article-date">
  <time datetime="2017-04-26T12:00:00.000Z" itemprop="datePublished">2017-04-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/26/2017-04-26-jQuery：事件监听用法/">jQuery：事件监听用法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="常见事件类型"><a href="#常见事件类型" class="headerlink" title="常见事件类型"></a>常见事件类型</h2><ul>
<li>Form events: 如 submit</li>
<li>Focus events: 如 blur, focus, change</li>
<li>Input devices events: 如 keyup, keypress, mouseover, mousemove, mouseleave</li>
<li>View events: 如 scroll, resize</li>
</ul>
<h2 id="事件监听三要素"><a href="#事件监听三要素" class="headerlink" title="事件监听三要素"></a>事件监听三要素</h2><ul>
<li>the target element to listen to，监听对象</li>
<li>the event we want to react to，监听事件</li>
<li>the actions to take in response，回调函数</li>
</ul>
<h2 id="基础示例"><a href="#基础示例" class="headerlink" title="基础示例"></a>基础示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$(&apos;div.foo button&apos;).on(&apos;click&apos;,function()&#123;</div><div class="line">    $(this).remove();</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h2 id="更多用法"><a href="#更多用法" class="headerlink" title="更多用法"></a>更多用法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 传递事件对象</div><div class="line">$(&apos;div.foo button).on(&apos;click&apos;,function(event)&#123;</div><div class="line">    $(event.target).remove(); // event.target 事件目标的页面元素</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 阻止默认行为</div><div class="line">$(&apos;div.foo a).on(&apos;click&apos;,function(event)&#123;</div><div class="line">    event.preventDefault();</div><div class="line">    console.log(&apos;the link you clicked will not work&apos;);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="event"><a href="#event" class="headerlink" title="event"></a>event</h3><ul>
<li>event.keyCode，用来了解按下的是哪个键</li>
<li>event.pageX, event.pageY，用来了解点击发生的坐标位置</li>
<li>event.type，用来了解发生的事件</li>
</ul>
<h2 id="简易写法"><a href="#简易写法" class="headerlink" title="简易写法"></a>简易写法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$(&apos;div.foo&apos;).click(function()&#123;...&#125;);</div><div class="line">$(&apos;div.foo&apos;).hover(function()&#123;...&#125;);</div><div class="line"></div><div class="line">//等等</div></pre></td></tr></table></figure>
<p>需要注意的是，<code>.hover()</code>监听了两个事件<code>mouseenter</code>和<code>mouseleave</code>，并且并不是所有事件都有简易的写法。</p>
<p>更多简易写法参考：<a href="http://api.jquery.com/category/events/" target="_blank" rel="external">jQuery: Events</a></p>
<h2 id="事件代理"><a href="#事件代理" class="headerlink" title="事件代理"></a>事件代理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;foo&quot;&gt;</div><div class="line">    &lt;ul&gt;</div><div class="line">        &lt;li&gt; 1 &lt;/li&gt;</div><div class="line">        &lt;li&gt; 2 &lt;/li&gt;</div><div class="line">        ...</div><div class="line">        &lt;li&gt; 1000 &lt;/li&gt;</div><div class="line">    &lt;/ul&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<p>假设有如上这样一个DOM片段，如果用以下方式进行事件监听，则会产生过多的监听器，导致性能问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$(&apos;div.foo li&apos;).on(&apos;click&apos;,function(event)&#123;</div><div class="line">    console.log(event.target);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>此时可以使用父元素事件代理（event delegation）的方式来处理，只用了一个监听器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$(&apos;div.foo&apos;).on(&apos;click&apos;,&apos;li&apos;,function(event)&#123;</div><div class="line">    console.log(event.target);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/Events#Categories" target="_blank" rel="external">MDN: Events Catagory</a></p>
<p><a href="https://api.jquery.com/category/events/event-object/" target="_blank" rel="external">jQuery: Event Object</a></p>
<p><a href="https://api.jquery.com/event.target/" target="_blank" rel="external">jQuery: event.targer</a></p>
<p><a href="https://www.w3.org/TR/DOM-Level-3-Events/" target="_blank" rel="external">W3C: Dom Level-3 Event</a></p>
<p><a href="https://learn.jquery.com/events/event-delegation/" target="_blank" rel="external">jQuery: Event Delegation</a></p>

      
    </div>
    <footer class="article-footer">
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jquery/">jquery</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2017-04-26-jQuery：基础 DOM 操作方法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/26/2017-04-26-jQuery：基础 DOM 操作方法/" class="article-date">
  <time datetime="2017-04-26T12:00:00.000Z" itemprop="datePublished">2017-04-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/26/2017-04-26-jQuery：基础 DOM 操作方法/">jQuery：基础 DOM 操作方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="元素选择"><a href="#元素选择" class="headerlink" title="元素选择"></a>元素选择</h2><h3 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// $(selector)</div><div class="line">$(&apos;div.foo&apos;);</div><div class="line"></div><div class="line">// $(element)</div><div class="line">$(&apos;div.foo&apos;).on(&apos;click&apos;,function()&#123;</div><div class="line">    $(this).slideUp();</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="遍历元素"><a href="#遍历元素" class="headerlink" title="遍历元素"></a>遍历元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// 父元素</div><div class="line">$(&apos;div.foo&apos;).parent();</div><div class="line"></div><div class="line">// 祖先元素</div><div class="line">$(&apos;div.foo&apos;).parents();</div><div class="line"></div><div class="line">// 子元素</div><div class="line">$(&apos;div.foo&apos;).children();</div><div class="line"></div><div class="line">// 后代元素</div><div class="line">$(&apos;div.foo&apos;).find();</div><div class="line"></div><div class="line">// 兄弟元素</div><div class="line">$(&apos;div.foo&apos;).sibling();</div></pre></td></tr></table></figure>
<h2 id="DOM操作"><a href="#DOM操作" class="headerlink" title="DOM操作"></a>DOM操作</h2><h3 id="添加or删除class"><a href="#添加or删除class" class="headerlink" title="添加or删除class"></a>添加or删除class</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(&apos;div.foo&apos;).toggleClass(&apos;bar&apos;);</div></pre></td></tr></table></figure>
<h3 id="修改or获取属性"><a href="#修改or获取属性" class="headerlink" title="修改or获取属性"></a>修改or获取属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$(&apos;div.foo a&apos;).attr(&apos;href&apos;,&apos;#1&apos;);</div><div class="line">$(&apos;div.foo a&apos;).attr(&apos;href&apos;); // #1</div></pre></td></tr></table></figure>
<h3 id="修改or获取CSS"><a href="#修改or获取CSS" class="headerlink" title="修改or获取CSS"></a>修改or获取CSS</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$(&apos;div.foo&apos;).css(&apos;font-size&apos;,&apos;20px&apos;);</div><div class="line">$(&apos;div.foo&apos;).css(&apos;font-size&apos;); // 20px</div></pre></td></tr></table></figure>
<h3 id="获取内容"><a href="#获取内容" class="headerlink" title="获取内容"></a>获取内容</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$(&apos;div.foo&apos;).html(); // 完整的HTML代码</div><div class="line">$(&apos;div.foo&apos;).text(); // 去掉HTML标签后的文本</div><div class="line">$(&apos;div.foo input&apos;).val(); // 获取输入的值</div></pre></td></tr></table></figure>
<h3 id="移除"><a href="#移除" class="headerlink" title="移除"></a>移除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(&apos;div.foo&apos;).remove();</div></pre></td></tr></table></figure>
<h3 id="添加child元素"><a href="#添加child元素" class="headerlink" title="添加child元素"></a>添加child元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$(&apos;div.foo&apos;).append(&apos;&lt;p&gt;last child&lt;/p&gt;&apos;&gt;</div><div class="line">$(&apos;div.foo&apos;).prepend(&apos;&lt;p&gt;first child&lt;/p&gt;&apos;&gt;</div></pre></td></tr></table></figure>
<h3 id="添加sibling元素"><a href="#添加sibling元素" class="headerlink" title="添加sibling元素"></a>添加sibling元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$(&apos;div.foo&apos;).after(&apos;&lt;div&gt;sibling after div.foo&lt;/div&gt;&apos;);</div><div class="line">$(&apos;div.foo&apos;).before(&apos;&lt;div&gt;sibling before div.foo&lt;/div&gt;&apos;);</div><div class="line"></div><div class="line">$(&apos;&lt;div&gt;sibling after div.foo&lt;/div&gt;&apos;).insertAfter($(&apos;div.foo&apos;));</div><div class="line">$(&apos;&lt;div&gt;sibling before div.foo&lt;/div&gt;&apos;).insertBefore($(&apos;div.foo&apos;));</div></pre></td></tr></table></figure>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$(&apos;p&apos;).each(function()&#123;</div><div class="line">   var len = $(this).text().length;</div><div class="line">   alert(len); // 输出每个p标签的文字长度</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h2 id="DOM加载完成后执行"><a href="#DOM加载完成后执行" class="headerlink" title="DOM加载完成后执行"></a>DOM加载完成后执行</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$(function()&#123;</div><div class="line">    alert(&apos;the document is ready&apos;);</div><div class="line"></div><div class="line">    //do something</div><div class="line">&#125;)</div><div class="line"></div><div class="line">$(document).ready(function()&#123;</div><div class="line">    alert(&apos;the document is ready&apos;);</div><div class="line"></div><div class="line">    //do something</div><div class="line">&#125;)</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jquery/">jquery</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2017-04-24-前端：跨域方法小记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/24/2017-04-24-前端：跨域方法小记/" class="article-date">
  <time datetime="2017-04-24T12:00:00.000Z" itemprop="datePublished">2017-04-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/24/2017-04-24-前端：跨域方法小记/">前端：跨域方法小记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="产生背景"><a href="#产生背景" class="headerlink" title="产生背景"></a>产生背景</h2><p>为了防止跨站请求伪造（CSRF，Cross-site request forgery）攻击，浏览器引入了同源策略（SOP，Same-Origin Policy）来提高安全性。</p>
<p>同源策略指的是，只要在同一域名（domain或ip）、同一端口、同一协议下才能互相获取资源。</p>
<p>一个域名A的网页可以获取域名B的静态资源（如CSS文件、图片等），但是不能直接发起AJAX（Asynchronous JavaScript and XML）请求。</p>
<h2 id="JS跨域"><a href="#JS跨域" class="headerlink" title="JS跨域"></a>JS跨域</h2><h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>原理：通过动态插入JS脚本的方式来实现跨域。</p>
<p>该方法适合跨域获取JSON类型的数据。缺点是只支持GET方式。</p>
<h3 id="document-domain"><a href="#document-domain" class="headerlink" title="document.domain"></a>document.domain</h3><p>原理：通过修改两个同一一级域名不同二级域名页面（如example.com与a.example）的<code>document.domain</code>来实现跨域。<code>document.domain</code>只能修改为自身或者高一级的父域名。</p>
<p>该方法适用于同父域名下的跨域问题。</p>
<h3 id="window-name"><a href="#window-name" class="headerlink" title="window.name"></a>window.name</h3><p>原理：window对象的name属性有一个特征，即在一个窗口（window）的生命周期下，窗口载入的所有页面都共享一个<code>window.name</code>，故我们可以通过插入一个外部页面的iframe，通过JS修改<code>window.name</code>，再将<code>window.location</code>改为同源的页面，来访问<code>window.name</code>的值进行跨域。</p>
<p>该方法的缺点是需要额外的同源页面，同时不同浏览器对window.name的大小也有一定的限制。</p>
<h3 id="window-postMessage"><a href="#window-postMessage" class="headerlink" title="window.postMessage"></a>window.postMessage</h3><p>原理：<code>window.postMessage(message, targetOrigin)</code>，是HTML5新引进的特性，可以用来向同源或者不同源的window对象发送消息。插入一个iframe，获取<code>iframe.contentWindow</code>，然后使用<code>postMessage</code>发送消息，在iframe预先设置<code>onmessage</code>的处理函数，即可获取跨域的数据。</p>
<p>该方法适用于处理多页面通信以及与iframe之间的消息传递。</p>
<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>原理：通过将外部资源映射成内部的地址，再通过代理服务器去获取真实的资源，然后返回给浏览器，避免在浏览器端进行跨域操作。</p>
<blockquote>
<p>反向代理，代理的是服务器，客户端只需要知道代理服务器上的资源URL地址即可，而不关心资源的真正URL。例如负载均衡就会用到反向代理。</p>
<p>正向代理，则是代理客户端，客户端需要知道资源的实际URL，通过告诉代理服务器真正的资源URL所在的位置，让代理服务器去获取后返还给客户端。例如翻墙工具就是正向代理。</p>
</blockquote>
<h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>浏览器发送一个带有<code>Origin</code>首部字段的HTTP请求，表明请求的来源。服务器的响应头中包含<code>Access-Control-Allow-Origin</code>表明允许哪些域名的请求。一旦不匹配则拒绝访问。通常设置为<code>Access-Control-Allow-Origin: *</code>可以允许任意域名跨域请求该服务器上的资源。</p>

      
    </div>
    <footer class="article-footer">
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/fe/">fe</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2017-04-14-React：基本环境搭建简明步骤" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/14/2017-04-14-React：基本环境搭建简明步骤/" class="article-date">
  <time datetime="2017-04-14T14:34:00.000Z" itemprop="datePublished">2017-04-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/14/2017-04-14-React：基本环境搭建简明步骤/">React：基本环境搭建简明步骤</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>超简的步骤整理。待完善。</p>
<ul>
<li>Babel</li>
<li>ESLint</li>
<li>webpack</li>
</ul>
<h2 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h2><p><code>babel</code>是一个多用途的JavaScript编译器，用它的目的有二：一是支持ES6语法，二是支持<code>React</code>的一些特性（JSX）语法等。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>在这里我们是跟<code>webpack</code>一起用的，所以需要的是<code>babel-core</code>核心模块和<code>babel-lodaer</code>，如果需要单独使用<code>babel</code>则安装<code>babel-cli</code>。</p>
<pre><code>$ npm i babel-core babel-loader --save-dev
</code></pre><p>接下来安装babel presets</p>
<pre><code>$ npm i babel-preset-es2015 babel-preset-react --save-dev
</code></pre><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>在根目录下新建一个<code>.babelrc</code>文件，并加入以下配置</p>
<pre><code>{
    &quot;presets&quot;: [&quot;es2015&quot;, &quot;react&quot;]
}
</code></pre><h2 id="ESLint"><a href="#ESLint" class="headerlink" title="ESLint"></a>ESLint</h2><p>ESLint是一个代码检查工具，用于检查和统一代码规范。</p>
<h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><pre><code>$ npm i eslint eslint-loader --save-dev
</code></pre><h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><pre><code>$ eslint --init
</code></pre><p>接下来根据你的需求进行选择即可，非常方便。最终可选择生成一个<code>.eslint.json</code>文件。我的配置如下：</p>
<pre><code>{
    &quot;env&quot;: {
        &quot;browser&quot;: true,
        &quot;commonjs&quot;: true,
        &quot;es6&quot;: true,
        &quot;node&quot;: true
    },
    &quot;extends&quot;: &quot;eslint:recommended&quot;,
    &quot;parserOptions&quot;: {
        &quot;ecmaFeatures&quot;: {
            &quot;experimentalObjectRestSpread&quot;: true,
            &quot;jsx&quot;: true
        },
        &quot;sourceType&quot;: &quot;module&quot;
    },
    &quot;plugins&quot;: [
        &quot;react&quot;
    ],
    &quot;rules&quot;: {
        &quot;linebreak-style&quot;: [
            &quot;error&quot;,
            &quot;unix&quot;
        ],
        &quot;quotes&quot;: [
            &quot;error&quot;,
            &quot;single&quot;
        ],
        &quot;semi&quot;: [
            &quot;error&quot;,
            &quot;always&quot;
        ]
    }
}
</code></pre><p>更多的配置可参照<a href="http://eslint.org" target="_blank" rel="external">ESLint</a></p>
<h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><p><code>webpack</code>是当前非常流行的模块打包工具，上述的<code>Babel</code>和<code>ESLint</code>都可以作为<code>loader</code>在<code>webpack</code>中被使用。</p>
<p>注意：本文使用的是<code>webpack 2</code>，<code>webpack 1</code>和<code>webpack 2</code>在配置上有诸多不同之处，请务必留心。</p>
<p><a href="https://webpack.js.org/guides/migrating/" target="_blank" rel="external">链接：webpack 1和2的区别</a></p>
<h3 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h3><pre><code>$ npm i webpack webpack-dev-server --save-dev
</code></pre><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>用于自动生成HTML页面，并引入正确的JavaScript文件依赖。</p>
<pre><code>$ npm i html-webpack-plugin --save-dev
</code></pre><h3 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h3><p>处理CSS文件需要用到的两个loader。</p>
<pre><code>$ npm i css-loader style-loader
</code></pre><h3 id="配置-2"><a href="#配置-2" class="headerlink" title="配置"></a>配置</h3><p>在根目录下新建一个<code>app</code>目录，同时再创建一个<code>webpack.config.js</code>文件。</p>
<pre><code>var path = require(&apos;path&apos;);
var HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);

var ROOT_PATH = path.resolve(__dirname);
var APP_PATH = path.resolve(ROOT_PATH, &apos;app&apos;);
var BUILD_PATH = path.resolve(ROOT_PATH, &apos;build&apos;);

module.exports = {
    entry: {
        app: path.resolve(APP_PATH, &apos;app.jsx&apos;)
    },
    output: {
        path: BUILD_PATH,
        filename: &apos;bundle.js&apos;
    },
    devtool: &apos;eval-source-map&apos;,
    devServer: {
        historyApiFallback: true,
        hot: true,
        inline: true,
    },
    module: {
        rules: [{
            test: /\.jsx?$/,
            enforce: &apos;pre&apos;,
            loaders: [&apos;eslint-loader&apos;],
            include: APP_PATH
        }, {
            test: /\.css$/,
            loaders: [&apos;style-loader&apos;, &apos;css-loader&apos;]
        }, {
            test: /\.jsx?$/,
            loader: [&apos;babel-loader&apos;],
            include: APP_PATH
        }],
    },
    plugins: [
        new HtmlWebpackPlugin({
            title: &apos;react-dev&apos;
        })
    ],
    resolve: {
        extensions: [&apos;.js&apos;, &apos;.jsx&apos;]
    }
};
</code></pre><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>添加两条命令到<code>package.json</code>里。</p>
<pre><code>&quot;scripts&quot;: {
    &quot;build&quot;:&quot;webpack&quot;,
    &quot;dev&quot;:&quot;webpack-dev-server --hot&quot;
}
</code></pre><p>通过在Terminal中输入 <code>npm run build</code> 或 <code>npm run dev</code> 执行。</p>

      
    </div>
    <footer class="article-footer">
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/react/">react</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2017-04-12-HTTP：常见的状态码" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/12/2017-04-12-HTTP：常见的状态码/" class="article-date">
  <time datetime="2017-04-12T05:00:00.000Z" itemprop="datePublished">2017-04-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/12/2017-04-12-HTTP：常见的状态码/">HTTP基础（2）：常见的状态码</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>HTTP状态码用于描述客户端向服务器端发送请求后的请求结果。通过状态码，客户端可以知道发出的HTTP是是否被正确处理。</p>
<p>状态码由<strong>三位数字</strong>和<strong>原因短语</strong>组成，第一位指定了<strong>响应类别</strong>。</p>
<p>状态码的类别：</p>
<ul>
<li>1XX：Informational 信息性状态码，表示服务器接收的请求正在被处理</li>
<li>2XX：Success 成功状态码，表示请求被正常处理完毕</li>
<li>3XX：Redirection 重定向状态码，表示客户端需要进行附加操作以完成请求</li>
<li>4XX：Client Error 客户端错误状态码，表示因某种原因服务器无法处理请求</li>
<li>5XX：Server Error 服务器错误状态码，表示服务器处理请求时出错</li>
</ul>
<h2 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a>2XX 成功</h2><h3 id="200-OK"><a href="#200-OK" class="headerlink" title="200 OK"></a>200 OK</h3><p>表示客户端的请求被服务器端正常处理了。</p>
<p>在这个状态码下，服务器的响应内容则依据请求方法决定。如果请求方法为GET，那么，对应请求资源的实体会一并返回；如果请求方法是HEAD，那么仅返回首部，而对应资源的实体不会被返回。</p>
<h3 id="204-No-Content"><a href="#204-No-Content" class="headerlink" title="204 No Content"></a>204 No Content</h3><p>表示客户端的请求被服务器端正常处理，但是响应报文中不含有实体的主体部分。实际上204状态码下也不允许响应报文中有实体的主体部分。</p>
<p>该响应码一般用于客户端向服务器端发送信息，而服务器端不必返回新信息的情况下使用。</p>
<h3 id="206-Parical-Content"><a href="#206-Parical-Content" class="headerlink" title="206 Parical Content"></a>206 Parical Content</h3><p>该状态码表示客户端进行了范围请求（请求资源的一部分内容），而服务器成功执行了这部分的GET请求。响应报文中包含由Content-Range指定的实体内容。</p>
<h2 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX 重定向"></a>3XX 重定向</h2><h3 id="301-Moved-Permanently"><a href="#301-Moved-Permanently" class="headerlink" title="301 Moved Permanently"></a>301 Moved Permanently</h3><p>永久性重定向。该状态码表示请求的资源已经分配了新的URI，新的URI在Location首部字段中。</p>
<h3 id="302-Found"><a href="#302-Found" class="headerlink" title="302 Found"></a>302 Found</h3><p>临时性重定向。该状态码表示请求的资源已经分配了新的URI，希望客户端此次能以新的URI进行访问。</p>
<p>注意302是临时性的重定向，请求的资源在将来还有可能换成别的URI。所以与永久性重定向的区别是，301是让客户端之后都用新的URI访问（相当于搬家，其住址URI不会轻易变更），而302时客户端之后仍然应该访问返回302的页面，以获得请求的资源最新的URI（相当于租房，其住址URI随时会变）。</p>
<h3 id="303-See-Other"><a href="#303-See-Other" class="headerlink" title="303 See Other"></a>303 See Other</h3><p>该状态码表示由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源。</p>
<p>303与302基本相似，唯一不同处是明确规定需要用GET方法去访问新的URI。例如当使用POST方法访问CGI（公共网关接口，Common Gateway Interface）程序，随后服务器端希望客户端以GET方法重定向到另一个URI上去时，返回303状态码。</p>
<h3 id="304-Not-Modified"><a href="#304-Not-Modified" class="headerlink" title="304 Not Modified"></a>304 Not Modified</h3><p>该状态表示客户端发送附带条件的请求时（在请求头部中包含If-Match、If-Modified-Since、If-None-Match、If-Range、If-Unmodified-Since），服务器端允许请求访问资源，但因发生请求未满足条件，直接返回304。</p>
<p>即表示服务器端的资源没有发生改变，客户端可以继续使用未过期的缓存资源。</p>
<p>注意：304虽然在3XX 重定向类别中，但跟重定向实际上没有太大的关系。</p>
<h3 id="307-Temporary-Redirect"><a href="#307-Temporary-Redirect" class="headerlink" title="307 Temporary Redirect"></a>307 Temporary Redirect</h3><p>临时重定向。该状态码与302基本相同，不同的是307会遵照浏览器标准，不会从POST变成GET。</p>
<p>而301、302响应状态码返回时，浏览器一般都会把POST改成GET（尽管301和302标准是禁止这样做的）并删除请求报文的主体，再发起请求。</p>
<h2 id="4XX-客户端错误"><a href="#4XX-客户端错误" class="headerlink" title="4XX 客户端错误"></a>4XX 客户端错误</h2><h3 id="400-Bad-Request"><a href="#400-Bad-Request" class="headerlink" title="400 Bad Request"></a>400 Bad Request</h3><p>该状态码表示请求报文中存在语法错误，需要客户端修改请求内容后再次发送请求。</p>
<p>注意：浏览器会像对待200 OK 一样对待该状态码（即不会像3XX那样子有别的行为）</p>
<h3 id="401-Unauthorized"><a href="#401-Unauthorized" class="headerlink" title="401 Unauthorized"></a>401 Unauthorized</h3><p>该状态码表示发送的请求需要有通过HTTP认证的认证信息。</p>
<p>第一次返回401时，浏览器会弹出认证用的对话框。</p>
<p>第二次返回401时，即表示用户认证失败。</p>
<h3 id="403-Forbidden"><a href="#403-Forbidden" class="headerlink" title="403 Forbidden"></a>403 Forbidden</h3><p>该状态码表示对该资源的请求被服务器拒绝了。服务器没有义务给出拒绝的详细理由，但如果想作说明的话可以在实体的主体部分对原因进行描述。</p>
<h3 id="404-Not-Found"><a href="#404-Not-Found" class="headerlink" title="404 Not Found"></a>404 Not Found</h3><p>该状态码表示服务器无法找到请求的资源，是最常见的状态码。</p>
<h2 id="5XX-服务器端错误"><a href="#5XX-服务器端错误" class="headerlink" title="5XX 服务器端错误"></a>5XX 服务器端错误</h2><h3 id="500-Internal-Server-Error"><a href="#500-Internal-Server-Error" class="headerlink" title="500 Internal Server Error"></a>500 Internal Server Error</h3><p>该状态码表示服务器端在处理请求时发生了错误，例如无法连接数据库，或者服务端语言中有语法错误等等。</p>
<h3 id="503-Service-Unavailable"><a href="#503-Service-Unavailable" class="headerlink" title="503 Service Unavailable"></a>503 Service Unavailable</h3><p>该状态码表示服务器端暂时处理超负载或正在进行停机维护，现在无法处理请求。</p>
<p>如果事先知道服务器将在何时恢复，则最好写入Retry-After首部字段再返回给客户端。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>状态码只在服务器端正确按照规范处理请求的前提下才有意义，不少服务器端会出现状态码与状态不一致的问题，需要在实际开发中注意。</p>
<h3 id="本文提及的常见的状态码"><a href="#本文提及的常见的状态码" class="headerlink" title="本文提及的常见的状态码"></a>本文提及的常见的状态码</h3><ul>
<li>200 OK</li>
<li>202 No Content</li>
<li>204 Partical Content</li>
<li>301 Permanently Redirect</li>
<li>302 Found</li>
<li>303 See Other</li>
<li>304 Not Modified</li>
<li>307 Temporary Redirect</li>
<li>400 Bad Request</li>
<li>401 Unauthorized</li>
<li>403 Forbbiden</li>
<li>404 Not Found</li>
<li>500 Interval Server Error</li>
<li>503 Service Unavailable</li>
</ul>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>本文整理了14种常见的状态码，其中包含4个状态类别，2XX，3XX，4XX，5XX，分别代表了成功，重定向，客户端错误和服务器端错误。</p>
<p>2XX中，要注意202与200的区别，前者不含资源实体的主体。</p>
<p>3XX中，要注意304与重定向无关，301和302一个是永久重定向，一个是临时重定向，且在标准中是不能把POST请求改成GET请求的（但是实际浏览器都会这么做）。303是302的相反版本，303要求POST改成GET请求。307是302的严格版，不允许把POST改成GET请求。</p>
<p>4XX中，400和401都是与浏览器有关的，前者是请求有错误后者是没有HTTP认证信息；403和404与服务器端有关，403禁止浏览器访问特定资源，404则是服务器上没有特定的资源。</p>
<p>5XX中，500是服务器端处理请求时出错，一般是数据库连接、代码有语法问题等等。503则是服务器负载过大或在维护，暂时无法提供服务。</p>

      
    </div>
    <footer class="article-footer">
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/http/">http</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/">&laquo;prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">next&raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/fe/">fe</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jquery/">jquery</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mac/">mac</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/react/">react</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shell/">shell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sublime/">sublime</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/svn/">svn</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/">vue</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/css/" style="font-size: 17.5px;">css</a> <a href="/tags/fe/" style="font-size: 12.5px;">fe</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/javascript/" style="font-size: 20px;">javascript</a> <a href="/tags/jquery/" style="font-size: 12.5px;">jquery</a> <a href="/tags/mac/" style="font-size: 10px;">mac</a> <a href="/tags/react/" style="font-size: 12.5px;">react</a> <a href="/tags/shell/" style="font-size: 10px;">shell</a> <a href="/tags/sublime/" style="font-size: 10px;">sublime</a> <a href="/tags/svn/" style="font-size: 12.5px;">svn</a> <a href="/tags/vue/" style="font-size: 10px;">vue</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/10/09/HTTP缓存机制/">HTTP：缓存机制</a>
          </li>
        
          <li>
            <a href="/2017/08/06/JavaScript：Array类型小结（2）/">JavaScript：Array类型小结（2）</a>
          </li>
        
          <li>
            <a href="/2017/08/06/JavaScript：Array类型小结（1）/">JavaScript：Array 类型小结（1）</a>
          </li>
        
          <li>
            <a href="/2017/08/04/奇怪的JavaScript（1）/">奇怪的JavaScript（1）：基础类型篇</a>
          </li>
        
          <li>
            <a href="/2017/07/06/2017-07-06-Shell 脚本入门/">Shell 脚本入门</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 Xinye Dai<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>