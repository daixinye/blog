<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[腾讯2020届前端实习生面试小记]]></title>
    <url>%2F2019%2F03%2F11%2F%E8%85%BE%E8%AE%AF2020%E5%B1%8A%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0%E7%94%9F%E9%9D%A2%E8%AF%95%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[大周末的本来下午好好看着书，结果突然来了一个深圳的电话，想了想好想像两天（3月8日）刚投了腾讯，猜测大概是先打过来了解一下情况，结果没想到直接就开面了，从4点不到一直面到5点半左右，总共1个小时40分钟。 面试过程刚开始问了一下在学校的情况，然后从学校和项目经历开始，问我如何学习前端，对前端的知识体系的看法，聊了还蛮久的，我中间还以为就是个 HR 小哥哥了解一下情况，结果突然就说他是个前端工程师然后就开始面试了。 面试基本是由浅入深，从基本的 JS 语法开始，基本类型、闭包、作用域、数组；然后是跨域、AJAX；再然后是框架、后端知识、Node、数据库、正则表达式…不管答的好不好，都会问到不会为止。面试的过程中能一直听到面试官在敲键盘的声音，后面问了一下别人说是可能在打分之类的吧。 面试问题整理回去趁着记忆还热乎把基本问到的问题做了个梳理，整理如下： 你是如何学习前端的？你为什么要学习前端？你参加过哪些前端会议？ 你觉得学习前端的技术路线是怎么样的？需要了解哪些东西？ 基本类型和引用类型？ 复制一个数组有哪些方法？哪个方法最好？ 如何判断一个类型是数组？instanceOf 的实现？ CSS 选择器有哪些？如何选择一个 form 表单里的单选框？ 如果要重构一个页面，从CSS的角度来讲如何进行性能优化？ 跨域方法有哪些？ JSONP 的缺点？如何进行安全防范？ CORS 的缺点？简单请求和复杂请求有什么区别？不想发预检请求怎么办？ AJAX 的完整过程？状态=4的时候需要做哪些判断？如何获取返回值，如何进行转换？JSON不能用的时候如何进行兼容？ HTTP 状态码？202？304？ 讲一下 HTTP 的报文？ 从输入 URL 开始到浏览器显示页面的整个过程？ 对框架原理的理解？ Node 内存管理 Node 事件循环机制 Node 如何进行缓存 Node 守护进程原理 Node 单线程的优劣势 Node 单线程的情况下如何使用多核心的CPU？ http.createServer 基本代码？ SQL 的基本语句？左连接右连接？索引？ 从前端提交图片开始到后端存储图片的整个流程？前端怎么提交？图片怎么传输？后端如何存储？ 如何给单词去重？不用数组直接在字符串上进行操作？使用正则表达式怎么解决？子表达式和分组？ -10 ~ 10 求出三个数相加等于10的所有可能性？ 是否有自己建站的经验？喜欢写博客吗？ 你觉得遇到过最难的项目是什么？难点是什么？ 你的优势跟劣势？ 小结前面面的感觉都答的还行，后面涉及到后端、Node、框架、算法的时候基本都没怎么答上来，结束之前问了下面试官觉得我不足的地方有哪些，也说是后端、算法、Node 和 前端框架这些理解不够深。 另外是面试官专业水平还是蛮强的，但是英语的口语还是让人有点想吐槽…面试过程中间面试官说的英语我基本没有听懂，要不停的说“不好意思没听懂”也是蛮尴尬的… 虽然说自己也没想着去深圳投腾讯也是陪女朋友投的，但是被这样面了之后也深深感觉到自己水平上的不足，一方面有些失落，另一方面其实也比较庆幸，想着多受点打击也许才能更沉下心去准备面试吧。 值得一提的是面的过程当中其实还有个拼多多的在线笔试，面完回去只剩半个小时答题了，还好只是一些基础的题目，花了20分钟左右就答完了，也不知道做的怎么样…]]></content>
  </entry>
  <entry>
    <title><![CDATA[写一个Shell脚本来练英语听力]]></title>
    <url>%2F2018%2F04%2F04%2F%E5%86%99%E4%B8%80%E4%B8%AAShell%E8%84%9A%E6%9C%AC%E6%9D%A5%E7%BB%83%E8%8B%B1%E8%AF%AD%E5%90%AC%E5%8A%9B%2F</url>
    <content type="text"><![CDATA[前言博客好久没更新啦，今天就趁着刚换了新的主题（Next），加了评论系统（Gitment，需要用 GitHub 账号授权），来更新一下吧。 最近听听力的时候发现，自己一到有数字的部分就会惊慌地不知所措。个位数的倒还好一些，但是来一个 two months ago 是 one hundred fifty two pounds 然后现在是 one hundred thirty seven pounds 最后问我现在跟俩月前相比瘦了多少磅，那我就得反应个半天了… 为了让自己对数字更加敏感一些，我打算借助 Shell 脚本来对数字听力做一个专项练习。 思路基于《刻意练习》中的 3F 原则（Focus，Feedback &amp; Fix），练习得有直接正面的反馈和以及能够立即纠正的机制。对此，比较好的一个方式就是由他人随机念出一个数字，我们立即给出数字，接着与正确答案进行比较。如果正确，则继续；如果不正确，则重复一次数字再进行辨认，直到得到正确答案为止。 表现为一个程序大概就以下几个步骤： 用户输入一个范围（例如 1~100） 程序随机选择给定范围中的一个数字 程序念出选中的数字 用户输入答案 程序比对答案，若正确则念下一个数字，否则重复当前数字直到给出正确答案 实现输入输出和对比都不难，关键在于如何让系统“念”数字。 博主用的是 Mac，在类 Unix 系统中应该都有一个 say 命令，用于把文本转换成语音（Convert text to audible speech）。say 的更多用法和介绍可以在终端中输入以下命令来查看： 1$ man say 通过这个命令，我们就能够实现“念数字”的功能了。万事俱备，只欠代码。简单实现的 Shell 脚本代码如下所示： 12345678910111213141516171819202122#! /bin/bashecho -n "Please input the range of numbers: "# 输入我们想要练习的数值范围，注意这个范围是左闭右开的，即[min,max)read min maxdiff=$(($max-$min))while [ true ]; do que=$(($RANDOM%$diff+$min)) # 随机选择给定范围中的一个数字 say $que # 念出这个数字 echo -n 'Input the number you just heard: ' read ans # 输入答案 until [[ $que = $ans ]]; do # 直到答案是正确的之前，都重复念同一个数字 echo "❌" echo -n "Try again: " say $que read ans # 再次输入答案 done echo "✅" # 答案正确，进入下一个循环done 运行接下来假设你使用的是 Mac… 如果你有终端的使用经验的话，只需要把打开一个文本编辑器，复制上述代码并保存为以.sh（如 practice.sh）结尾的文件，然后切换到相应的目录，在终端里运行就好了，你可以用以下两种方式来执行一个脚本： 12$ chmod +x ./practice.sh$ ./practice.sh 或者是 1$ /bin/bash ./practice.sh 如果你没有终端的使用经验的话，那就下载这个文件(practice.sh)，然后在 Docker 里点一下访达（Finder），把这个文件放到打开的个人目录中。再在启动台中找到并打开终端，输入： 1$ /bin/bash ./practice.sh 应该就可以了。 退出你可以用 Ctrl + C 随时退出。 开始练习使用的效果，大概就是像这样子（gif 可能有点慢…），请自行脑补声音 🙃： Tips：say命令的语音设置，可以在 系统偏好设置-&gt;辅助功能-&gt;语音 中找到，你可以设置使用不同的系统声音，也可以调整它的速率哦。 好了，这篇文章就到此结束了，希望能对大家有所帮助~]]></content>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP：缓存机制]]></title>
    <url>%2F2017%2F10%2F09%2FHTTP%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Foreword浏览器缓存可以让用户在访问我们的站点时，通过直接使用保存在浏览器上的缓存，从而避免发起不必要的 HTTP 请求，提升页面渲染的速度。那么，对于不了解这个缓存机制的人来说，就有以下几个问题需要求解： 1、浏览器什么时候应该缓存资源？2、浏览器什么时候会使用缓存资源？3、浏览器的缓存资源过期了怎么办？ 本文默认读者对于 HTTP 协议有一定的了解（对于 HTTP 协议请求头、响应头有基础的认识，以及对前后端交互有基本的了解） 第一问：浏览器什么时候会缓存资源？第一种：当 HTTP Response 中带有 Expires Header 时，浏览器会缓存该资源。Expires 会告诉浏览器该资源在什么时候过期，并且在这个过期日期之前，浏览器应当一直使用存在浏览器本地的资源副本而不发起 HTTP 请求。下面这个 HTTP Response 说明这个资源在10年后的今天过期。 1234HTTP/1.1 200 OKHost: daixinye.comExpires: Mon, 9 Oct 2027 22:00:00 GMT... 第二种：当 HTTP Response 中带有 Cache-Control 及 max-age 指令时。HTTP 1.1 引入了 Cache-Control Header，通过 Cache-Control 指定 max-age 指令可以指定该资源被缓存多久。与 Expires 有两大不同点需要注意： 当 Response 中两者同时存在时，Cache-Control 的优先级高于 Expires Expires 指定了过期时间，而 Cache-Control 的 max-age 则以秒为单位，指定了从该 HTTP Request 起经过多少秒后该资源将会过期。 1234HTTP/1.1 200 OKHost: daixinye.comCache-Control: max-age=31536000... 第二问：浏览器什么时候会使用缓存资源？从第一问可以看到，当 HTTP Response 中包含了 Expires 或 Cache-Control 时，服务器会告诉浏览器该资源何时会过期。在过期时间之前，浏览器应当一直使用本地缓存下来的资源副本，且不发起获取该资源的 HTTP Request。 第三问：浏览器的缓存资源过期了怎么办？当浏览器缓存下来的资源副本过期时，浏览器会发起一个条件 Get 请求（Conditional Get Request）。浏览器这个请求会询问服务器，“我现在存下来的资源能不能继续用啊”。如果服务器告诉浏览器，“你这个资源我已经修改过啦，你得重新获取啦”，那么 Response 就会返回 200，同时浏览器会重新下载这个资源以替代之前存在本地的资源。如果服务器告诉浏览器说，“你这个资源我没修改过啦，你接着用吧”，那么就会返回 304 Not Modified。这个时候浏览器只付出了一个 HTTP Response Header 的流量就可以避免一次下载存在服务器的资源带来的额外开销。那么浏览器和服务器是如何判断浏览器的缓存是否有效的呢？这就需要引入 Last-Modified 和 Etags 两个 Response Header 了。 Last-Modified Header实际上在一个正常的 HTTP Response 中，服务器会告诉浏览器，这个资源最后被修改的时间，通过这个最后被修改的时间，我们就可以判别这个资源是否需要更新： 1234567HTTP/1.1 200 OKHost: daixinye.comCache-Control: max-age=60Last-Modified: Mon, 8 Oct 2017 20:00:00 GMTvar iamdxy = true... 接下来当资源过期，也就是一分钟后，当浏览器再次打算使用这个本地缓存的资源时发现，“诶这个资源过期了，我得问一下服务器这个缓存还能不能接着用”，于是浏览器根据能省则省的原则发起了一个条件 Get 请求： 1234GET /index.js HTTP/1.1Host: daixinye.comIf-Modified-Since: Mon, 8 Oct 2017 20:00:00 GMT... 这个 Request 中的 If-Modified-Since Header，就是之前服务器 Response 中的 Last-Modified，这里浏览器用来询问服务器，“老哥这个资源你昨天8点以后修改过了吗？”。服务器老哥想回答说：”没修改！你接着用你缓存！“，于是返回一个 Response ： 1HTTP/1.1 304 Not Modified 由此，浏览器收到以后继续使用本地缓存。那如果服务器老哥说：”改过啦，你用这个新的，这个是我今天晚上10点刚刚改过的！“呢，那么就会正常的返回一个 200 的 Response： 1234567HTTP/1.1 200 OKHost: daixinye.comCache-Control: max-age=60Last-Modified: Mon, 9 Oct 2017 22:00:00 GMTvar iamdxy = true... 由此，浏览器更新本地缓存，同时也付出了一个下载 HTTP Entity 流量的惨痛代价。 Etags HeaderEtags，Entity Tags，实体标签。这个 Header 跟 Last-Modified 的用处一样，只是一个是用时间一个则是用标识了一个资源特定版本的字符串来辨别资源是否被过期。Etags 的值根据浏览器的具体 Etags 生成策略的不同而不同，这里我们只要知道，当浏览器发起条件 Get 请求时，如果本地资源的 Etags 跟服务器上的不匹配，那么此时就需要重新下载资源；若匹配，则又是一个美好的 304 了。服务器 Response： 1234567HTTP/1.1 200 OKHost: daixinye.comCache-Control: max-age=60Etags: "1a2b3c4d5f"var iamdxy = true... 浏览器在缓存资源过期时的条件 Get 请求： 1234GET /index.js HTTP/1.1Host: daixinye.comIf-None-Match: "1a2b3c4d5f"... 这里Conditional Get Request 的 If-None-Match Header 与 Response 里的 Etags 是一致的。接下来服务器会对比 Etags ，若匹配则 304，若不匹配则 200。 Etags 与 Last-Modified 同时存在时怎么办？当 Etags 与 Last-Modified 同时存在时，仅当两者同时与服务器上的资源匹配时，才会返回 304，否则只要其中一个不匹配，服务器就会返回 200 要求浏览器重新下载资源。 小结本文阐述了关于 HTTP 缓存的基本机制，其大致的行为可以描述为：浏览器向服务器请求资源，服务器在返回资源的时候也告诉浏览器，你应该缓存这个资源，并且在何时之前你都可以一直使用这个资源。如果资源过期，那么你就发一个条件 Get 请求，如果资源没修改你还可以接着使用本地资源。本文有以下几个核心的概念： Expires Cache-Control，max-age Last-Modified/If-Modified-Since Etags/If-None-Match Conditional Get Request 相信理解了这几个概念之后，对 HTTP 的缓存机制也就有了一个初步的认识。 最后谢谢你读到最后，如果你有发现本文中的任何错误，请不吝指出。]]></content>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript：Array类型小结（2）]]></title>
    <url>%2F2017%2F08%2F06%2FJavaScript%EF%BC%9AArray%E7%B1%BB%E5%9E%8B%E5%B0%8F%E7%BB%93%EF%BC%882%EF%BC%89%2F</url>
    <content type="text"><![CDATA[承接 JavaScript：Array类型小结（1） 位置方法indexOf()indexOf() 方法用于从前往后查找元素，当没有查找到该元素时，会返回 -1。此外，indexOf() 不会对传入的查找元素进行类型转换，在进行对比时会使用全等（===）的方式进行比较：1234let value = [1,2,3,4,5] console.log(value.indexOf(3)) // 2console.log(value.indexOf(4)) // -1console.log(value.indexOf('3')) // -1 我们可以再传入一个参数来指定从第几项（从0开始）开始进行查找（查找包含起始的元素）：123let value = [1,2,3,4,5]console.log(value.indexOf(3,2)) // 3console.log(value.indexOf(2,2)) // -1 lastIndexOf()lastIndexOf() 方法用于从后往前查找元素，用法与 indexOf() 基本一致：1234let value = [1,1,2,2,3,3]console.log(value.lastIndexOf(1)) // 1console.log(value.lastIndexOf(3)) // 5console.log(value.lastIndexOf(2,1)) // -1，代表从第1项开始往前查找 迭代方法forEachforEach() 对数组中每一项运行指定函数，没有返回值。等同于 for 语句：12345678910let value = [1,2,3,4,5]value.forEach( (item, index) =&gt; &#123; console.log(item, index)&#125;)// 输出// 1 0// 2 1// 3 2// 4 3// 5 4 everyevery() 对数组每一项运行指定函数，若对任意所有函数都返回 true， 则返回 true。与逻辑与操作符很相似：1234let value = [1,2,3,4,5]value.every( item =&gt; &#123; return item &gt; 0&#125;) // true somesome() 对数组每一项运行指定函数，若存在函数返回 true，则返回 true。与逻辑或操作符很相似：1234let value = [1,2,3,4,5]value.some( item =&gt; &#123; return item &gt; 4&#125;) // true mapmap() 对数组每一项运行指定函数，返回由每一项函数的返回值组成的新数组：1234let value = [1,2,3,4,5]value.map( item =&gt; &#123; return item + 1&#125;) // [2,3,4,5,6] filterfilter() 对数组每一项运行指定函数，返回每一项函数返回值为 true 的项组成的新数组：1234let value = [1,2,3,4,5]value.map( item =&gt; &#123; return item &lt; 3&#125;) // [1,2] 归并方法reduce()reduce() 接受一个函数，函数接受4个参数，分别是 前一个值，当前值，项的索引和数组对象。reduce() 方法能够遍历整个数组，并将上一个函数的返回值作为第一个参数传给下一个函数：12345let value = [1,2,3,4,5]let sum = value.reduce((prev, cur, index, array)&#123; return prev + cur&#125;)console.log(sum ) // 15 reduceRight()reduceRight() 与 reduce() 基本一致，只是前者从后向前归并。 ES6 新方法（部分）Array.of()Array.of() 方法用于创建一个数组。之前我们提到，创建数组的方式由两种，一是通过构造函数，二是通过字面量的形式。然而通过构造函数的方式有一个令人迷惑的地方：123let array = new Array(2)console.log(array.length) // 2console.log(array) // [undefined, undefined] 当给构造函数传入一个数字时，构造函数会返回一个长度为该数字的数组，并用 undefined 填充。而当给构造函数传入一个字符串时，则会创建一个长度为1，元素为该字符串的数组：123let array = new Array('2')console.log(array.length) // 1console.log(array) // ['2'] 这样就让我们很难用构造函数来创建只有一个数字的数组了。 为了让创建数组的行为更加一致， Array.of() 去除了数组构造函数当传入一个数字时的情况：123let array = Array.of(2)console.log(array.length) // 1console.log(array.) // [2] 这样子，构造数组的方式就更加统一，无需我们去判断只传入一个参数时，参数的类型了。 Array.from()Array.form() 方法可以接受可迭代对象或类数组对象作为第一个参数，第二个参数接受一个映射函数，来对第一个参数中的每一个值进行映射转换：123456789void function f_1()&#123; let array = Array.from(arguments) console.log(array)&#125;(1,2,3,4) // [1,2,3,4]void function f_2()&#123; let array = Array.from(arguments, value =&gt; value + 1) console.log(array)&#125;(1,2,3,4) // [2,3,4,5] Array.find()Array.find() 方法接受一个函数作为参数，用于获取满足某一条件的数组元素：12let value = [1,2,3,4,5]value.find(item =&gt; item &gt; 3) // 4 Array.findIndex()Array.findIndex() 与 Array.find() 的用法一致，只是前者返回的是查找到的元素下标：12let value = [1,2,3,4,5]value.find(item =&gt; item &gt; 3) // 3 Array.fill()Array.fill() 可以用指定的值填充若干个数组元素。其接受三个参数，第一个参数是需要替换的值，第二个和第三个是起始下标和结束下标（不包含结束下标对应的值）12345let value = [1,2,3,4]value.fill(0) // [0,0,0,0]value.fill(-1, 1) // [0, -1, -1, -1]value.fill(-2, 1, 3) // [0, -2, -2, -1]]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript：Array 类型小结（1）]]></title>
    <url>%2F2017%2F08%2F06%2FJavaScript%EF%BC%9AArray%E7%B1%BB%E5%9E%8B%E5%B0%8F%E7%BB%93%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[创建构造函数123new Array(5) // 创建一个长度为 5 ，元素值均为 undefined 的数组new Array(1, 2, 3) // 创建一个长度为 3 ，元素为 1、2、3 的数组new Array('a', 'b', 'c') // 创建一个长度为 3 ，元素为 a、b、c 的数组 注意： new 关键字是不必要的。 字面量字面量由若干个元素，以逗号分隔的形式包裹在一对方括号中：123[,,,,] // 相当于 new Array(5)[1, 2, 3] // 相当于 Array(1, 2, 3)['a', 'b', 'c'] // 相当于 Array('a', 'b', 'c') length 属性获取数组长度我们可以通过 length 属性来获取当前数组的长度：12let list = [1, 2, 3]console.log(list.length) // 3 新增元素或删除元素都会动态的改变 length 的值。 不仅仅是可读的length 除了可以获取当前数组的长度之外，其也可以用于增加或删除数组元素：1234567891011let list = [1, 2, 3]console.log(list.length) // 3list.length = 2;console.log(list) // 输出 1,2， 第3个元素被删除了list.length = 4console.log(list) // 输出 1,2,undefined,undefined，新增了两个值为 undefined 的元素list[list.length] = 5console.log(list) // 输出 1,2,undefined,undefined,5，通过length下标新增一个值为 5 的元素，与 list.push(5) 行为是一致的 不使用循环来创建值为 1,2,…n 的数组使用递归：1234function producer(n,list =[])&#123; return list.length === n ? list : (list[list.length] = list.length + 1) &amp;&amp; producer(n, list)&#125;console.log(producer(5)); // 1,2,3,4,5 检测数组instanceOf1new Array() instanceOf Array // true 操作数1 instanceof 操作数2 操作符实际上做的行为是判断第一个操作数的的构造函数是否等于第二个。因此如果是在有多个全局环境的情况下（网页中有多个iframe），那么一个 iframe 的数组实例的构造函数不一定等于另一个 iframe 的 Array。所以这个方法存在一定的局限性。 Array.isArray()12let value = new Array()Array.isArray(value) // true 不同于 instanceof 可能会受不同全局环境的影响， isArray() 方法在各种环境下都是可靠的，推荐使用 isArray() 来判断一个变量是否是数组的实例。 转换方法toString()在需要字符串的操作场合，都会调用数组的 toString() 方法，返回一个以逗号分隔的字符串：12let value = new Array(1,2,3)console.log(value) // 打印的过程中调用了 value 的 toString 方法，输出 [1,2,3] join()我们可以通过 join() 方法来拼接数组元素，使其成为一个字符串：12let value = new Array(1,2,3)console.log(value.join('&amp;')) // 1&amp;2&amp;3 栈方法（LIFO）push()push() 用于向数组的末尾添加一个元素：123let value = new Array(1,2,3)value.push(4)console.log(value) // [1,2,3,4] 我们可以借助 length 属性来模拟这个行为：123let value = new Array(1,2,3)value[value.length] = 4console.log(value) // [1,2,3,4] pop()pop() 方法用于移除数组末尾的元素：123let value = new Array(1,2,3,4)value.pop()console.log(value) // [1,2,3] 队列方法（FIFO）shift()shift() 能够移除并返回数组的第一项1234let value = new Array(1,2,3)let shiftedNode = value.shift()console.log(value) // [2,3]console.log(shiftedNode) // 1 unshift()unshift() 与 shift() 正好相反，后者用于移除，而前者用于添加若干个新元素到数组的前端，并返回新数组的长度：123let value = new Array(1,2,3)value.unshift(-2,-1,0)console.log(value) // [-2,-1,0,1,2,3] 需要注意的是，unshift() 里的参数是从最右边开始逐个加到数组前端的。 排序方法reverse()reverse() 用于反转数组的顺序：123let value = new Array(1,2,3)value.reverse()console.log(value) // [3,2,1] sort()sort() 方法用于排序，其默认排序为升序。需要注意的是，sort() 排序时会把所有的元素都转换成字符串进行比较，所以有个比较奇怪的现象如下：123let value = new Array(1,2,3,11,22,33)value.sort()console.log(value) // 1,11,2,22,33 这时我们需要借助一个比较函数来对这个数组进行排序12345678function compare(before, after)&#123; // 当返回负数时， before 会排在 after 前；返回正数时，before 会被放到 after 后面。 return before - after&#125;let value = new Array(1,2,3,11,22,33)value.sort(compare)console.log(value) // 1,2,3,11,22,33 操作方法concat()concat() 用于连接两个数组：12345678let value_1 = new Array(1,2,3)let value_2 = new Array(4,5,6)let result = value_1.concat(value_2)console.log(result) // [1,2,3,4,5,6]// 当 concat 没有被传入参数时， 返回的是原数组的一个副本，即 concat 可以用来浅拷贝一个数组let value_copy = value_1.concat()console.log(value_copy) // [1,2,3,4,5,6] 需要注意的是，concat() 是不会影响原数组的。 slice()slice() 用来创建一个子数组，其接受两个参数，分别为起始下标和结束下标，当只传了起始下标时，会返回从这个起始下标开始的所有数组元素。需要注意的是，结束下标所在的元素并不会被包含到新的子数组中去：1234let value = new Array(1,2,3,4,5)console.log(value.slice(2)) // [3,4,5]console.log(value.slice(2, value.length)) // [3,4,5]console.log(value.slice(2,3)) // [3] slice() 也不会影响原数组，也可以用于浅拷贝一个数组。 splice()splice() 可用于删除、插入和替换元素，其接受三个参数，分别为需要删除或插入的元素下标，需要删除的个数，以及需要插入的元素：1234567891011let value = new Array(1,2,3)// 删除一个元素value.splice(0,1)console.log(value) // [2,3]// 插入一个元素value.splice(0,0,1.5)console.log(value) // [1.5,2,3]// 删除多个元素和插入多个元素value.splice(1,2, 2.5, 3.5)console.log(value) // [1.5, 2.5, 3.5] splice() 会返回被删除的元素，与 concat()和 slice() 不同的是，splice() 是会直接影响原数组的。]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[奇怪的JavaScript（1）：基础类型篇]]></title>
    <url>%2F2017%2F08%2F04%2F%E5%A5%87%E6%80%AA%E7%9A%84JavaScript%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言JavaScript 是一门很奇怪的语言，它看起来很“随便”，一个变量可以赋值数字也可以赋值字符串，一个对象竟然用一对花括号就可以创建出来。然而正是在这种“随便”的特点之下，造就了 JavaScript 无比灵活的姿态。它有着性感的体态，却也有着诡异的性格，让人琢磨不透。那么就让我们来盘点一下，JavaScript 那些奇怪的地方吧。 1、tpyeof null; // objecttypeof 是一个用于类型判断的操作符，而 null 则是五大基本数据类型之一，然而 typeof null 却出乎了很多初学者的预料。没错，这个表达式返回居然是 &#39;object&#39;！这个表达式在《JS高程》中也有特意提到，尽管 null 被视作对象的占位符，因此返回的是对象在技术角度上来讲是合理的，但是不得不说这个“特例”会让人觉得相当迷惑。 2、null == undefined; // true返回的是 true，其原因是 undefined 派生自 null，在不严格的比较下两者是相等的。反正我是没在别的语言见过这种操作啦。 3、Boolean(false) == true; // trueBoolean(false) 是一个包装对象，既然是对象那么它在不严格相等的情况都会转换成 true。你可以用 Boolean(false).valueOf() 来获取真正的 false 值。 4、0.1 + 0.2 == 0.3; // false“浮点数值的最高精度是17位小数，但在进行算术计算时其精确度远远不如整数”因此，0.1 + 0.2 等于 0.30000000000000004，而不等于 0.3 。这个其实在所有语言的浮点数运算中都会有类似的问题。 5、NaN == NaN; // falseNaN（Not a Number），有两个特点：一是与其任何的操作都返回 NaN；二是 NaN 与任何值都不相等。所以 NaN != NaN 是成立的。还有就是当 0 / 0 时也会返回 NaN。 6、”23” &lt; “3”; // true尽管 JS 在进行比较的时候会进行类型转换，但是在直接比较字符串的时候，它可能并不想我们预想中的那样子会直接比较“数值”（因为并没有被转换成数值）。两个字符串进行大小比较时，比较的是字符编码。&#39;3&#39;的字符编码在&#39;2&#39;的后面，所以 &quot;23&quot; &lt; &quot;3&quot; 返回的是 true。需要注意的是，当比较的两个操作数，有一个是数字时，另一个字符串会被转换成数值。如：1&quot;23&quot; &lt; 3 // false 与123 &lt; 3 // false 是等价的。]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell 脚本入门]]></title>
    <url>%2F2017%2F07%2F06%2FShell%20%E8%84%9A%E6%9C%AC%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[在本文开始之前，我想先阐述一下本文的基本内容。 本文的标题是《Shell 脚本入门》，内容将涵盖 如何写一个基本的 Shell 脚本、如何运行它、一些基本的流程控制和判断，以及更多可供参考学习的站点。 那话不多说，让我们从一个最简单的 Shell 脚本开始吧~ 一、Hello World打开一个文本编辑器，输入以下脚本代码，保存为 helloworld.sh： 12345#!/bin/sh# it&apos;s just a demoecho &quot;Hello World&quot; 接着，打开 命令行 ，切换至 helloworld.sh 所在目录，并输入以下命令： 1$ /bin/sh helloworld.sh 可以看到，命令行中输出了 “哈喽沃德”： 1Hello World 好了，这就是我们使用一个 Shell 脚本的基本流程：编写脚本 =&gt; 运行脚本 =&gt; 运行结果。 二、编写的三个要素观察一下我们的 helloworld.sh，我们可以把它分为三部分：指定程序、注释说明 以及 脚本命令。 1、指定程序：#!/bin/sh符号 #! 用于指定运行该脚本使用的程序。 在 helloworld.sh 中，我们用 /bin/sh来执行这个脚本。 2、注释说明：# it&#39;s just a demo注释，以 # 开头的一行表示注释。 12345678910#!/bin/sh# 这里是注释 # 可以用来解释这个脚本是用来做什么的 ######### 分割线 ############## 你也可以用多个#来做注释之间的分割#############################echo &quot;Hello World&quot; 3、脚本命令： echo &quot;Hello World&quot;echo用于在命令行中打印指定的字符串。 你可以用单引号、双引号将要打印的字符串包裹起来，也可以选择不用引号。 三、运行的两个方式运行一个脚本，有两种方法：作为参数 或者是 作为可执行文件。 1、作为参数1$ /bin/bash ./helloworld.sh 可以看到，我们通过给 /bin/bash 这个程序指定要运行的脚本，来运行 helloworld.sh 的。 2、作为可执行文件首先，我们让这个脚本变成可执行的程序： 1$ chmod +x helloworld.sh 接下来，就可以直接运行这个脚本： 1$ ./helloworld.sh 四、小进阶在了解了基本的 Shell 编程之后，我们来让 Shell 脚本做更多的事情。 1、读取输入12345678#!/bin/sh# read.shecho &quot;你的名字？&quot;read nameecho &quot;你好 $name，很高兴认识你。&quot; 运行一下： 12$ /bin/sh read.sh 你的名字？ 输入 daixinye，回车： 1你好daixinye，很高兴认识你。 2、条件判断1234567891011121314151617#!/bin/sh# if.shecho &quot;你的年龄？&quot;read age# 注意 等号左右两边 不能有空格myAge=18# 注意 方括号内部前后 需要有空格if [ $age == $myAge ] then echo &quot;我们岁数一样哦&quot; else echo &quot;我们岁数不一样哦&quot; fi 运行一下： 12$ /bin/sh if.sh 你的年龄？ 输入 18，回车： 1我们岁数一样哦 3、条件循环12345678910111213141516171819#!/bin/sh# while.shecho &quot;我有一个数字，你要来猜一下吗？1~1000哦&quot;answer=666bingo=0while [ $bingo == 0 ]; do read guess if [ $guess == $answer ] then echo &quot;猜对啦&quot; bingo=1 else echo &quot;猜错啦，再猜一次吧？&quot; fidone 运行一下： 12$ /bin/sh while.sh 我有一个数字，你要来猜一下吗？1~1000哦 依次输入1、5、10、100、600、666 ： 1234567891011121猜错啦，再猜一次吧？5猜错啦，再猜一次吧？10猜错啦，再猜一次吧？100猜错啦，再猜一次吧？600猜错啦，再猜一次吧？666猜对啦 五、小结好啦，通过本文你应该已经了解了以下几个知识点： 如何写一个基本 Shell脚本 如何打印内容（echo） 如何运行脚本（作为参数和作为可执行程序） 如何读取输入（read） 如何进行条件判断（if…else 语句） 如何进行条件循环（while… do 语句） 本文参考https://my.oschina.net/maczhao/blog/349452 测试代码https://github.com/daixinye/practice/tree/master/shell]]></content>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS：什么是 BFC]]></title>
    <url>%2F2017%2F07%2F05%2FCSS%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%20BFC%2F</url>
    <content type="text"><![CDATA[什么是 BFCBFC，Block Formatting Context，直译为块级格式化上下文。 在 BFC 中，HTML 元素按照一定的规则进行布局，并且不管其中的元素如何变换样式，均不会影响 BFC 外部的任何元素同样也不受外部任何元素的影响。 触发 BFC 的方法0、the root element一个 HTML 文档本身就是一个 BFC 。 1、floatfloat 属性不为 none 时，即如果一个元素是浮动元素，那么它就是一个 BFC 。 float: left; float: right; 2、overflowoverflow 属性不为 visible 时，即 overflow 为auto、scroll、hidden 时会形成一个 BFC 。 overflow: hidden; overflow: scroll; overflow: auto; 3、displaydisplay 属性为 table-cell、table-caption 或 inline-block 时也会触发 BFC。 display: table-cell; display: table-caption; display: inline-block; 4、positionposition 属性不为 relative 或 static 时，即 postion 为 absolute、fixed 时也会触发 BFC 。 position: absolute; position: fixed; BFC 的作用 不让文字环绕浮动的兄弟元素（自适应布局） 在有浮动子元素的情况下，不让父元素高度坍缩（包含浮动） 让兄弟元素之间的外边距不重合（边距折叠） 测试代码：https://github.com/daixinye/practice/blob/master/HTML/BFC.html 参考： https://www.w3cplus.com/css/understanding-bfc-and-margin-collapse.html http://www.zhangxinxu.com/wordpress/2015/02/css-deep-understand-flow-bfc-column-two-auto-layout/ http://www.cnblogs.com/MockingBirdHome/p/3365346.html]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS：Animation 动画小记]]></title>
    <url>%2F2017%2F06%2F21%2FCSS%EF%BC%9AAnimation%20%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[属性 animation-delay 延时 animation-direction 动画重复播放时是反向运行还是回到开始位置 animation-duration 动画持续时间 animation-iteration-count 动画重复次数 animation-name 关键帧名称 animation-play-state 允许暂停和回复动画 animation-timing-function 动画速度函数 animation-fill-mode 动画执行前后目标元素如何应用样式 关键帧 keyframes123456789101112131415p &#123; animation-name: slidein;&#125;@keyframes slidein &#123; from &#123; margin-left: 100%; width: 300%; &#125; to &#123; margin-left: 0%; width: 100%; &#125;&#125; 除了 from 和 to ，也可以用百分比来定义关键帧。 12345678910111213141516@keyframes slidein &#123; 0% &#123; margin-left: 100%; width: 300%; &#125; 50% &#123; margin-left: 70%; witdh: 250%; &#125; 100% &#123; margin-left: 0; width: 100%; &#125;&#125; 重复播放动画设置 animation-iteration-coutn 为 infinite 即可。 1234p &#123; animation-name: slidein; animation-iteration-count: infinite;&#125; 来回播放动画设置 animation-direction 为 alternate 12345p &#123; animation-name: slidein; animation-iteration-count: infinite; animation-direction: alternate;&#125; 动画事件 Animation Event animationstart 动画开始时 animationend 动画结束时 animationiteration 开始重复动画时 123$(&apos;p&apos;).on(&apos;animationiteration webkitAnimationIteration&apos;, (e) =&gt; &#123; // do something&#125;) 注意添加 webkit 前缀，以兼容低版本浏览器。 移动设备兼容性 iOS 9.2 起、安卓 4.2~4.3 起（需添加 webkit 前缀） 参考http://www.runoob.com/jsref/event-animationiteration.html https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent https://caniuse.com/#search=animation]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue：基础用法与指令]]></title>
    <url>%2F2017%2F06%2F21%2FVue%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95%E4%B8%8E%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Vue 是什么？Vue 是一套构建用户界面的渐进式框架，采用自底向上增量开发的设计。Vue 的核心库值关注视图层（View）。 声明式渲染文本插值123&lt;div id=&quot;app&quot;&gt; &#123;&#123; message &#125;&#125;&lt;/div&gt; 123456var app = new Vue(&#123; el:&apos;#app&apos;, data: &#123; message: &apos;hello&apos; &#125;&#125;) 渲染 DOM 属性（ v-bind:name 指令）12345&lt;div id=&quot;app&quot;&gt; &lt;span v-bind:title=&quot;message&quot;&gt; 鼠标悬停此处查看动态提示信息 &lt;/span&gt;&lt;/div&gt; 123456var app = new Vue(&#123; el: &apos;#app&apos;, data: &#123; message: &apos;提示信息&apos; &#125;&#125;) v-bind 属性被称为指令（指令带有前缀 v-，以表示他们是 Vue 提供的特殊属性）。这里该指令的作用是“将这个元素的 title 属性和 Vue 实例的 message 属性保持一致”。 条件与循环（ v-if 指令和 v-for 指令）条件123&lt;div id=&quot;app&quot;&gt; &lt;p v-if=&quot;seen&quot;&gt;看到了没？&lt;/p&gt;&lt;/div&gt; 123456var app = new Vue(&#123; el: &apos;#app&apos;, data: &#123; seen: true &#125;&#125;) 循环1234567&lt;div id=&quot;app&quot;&gt; &lt;ol&gt; &lt;li v-for=&quot;todo in todos&quot;&gt; &#123;&#123; todo.text &#125;&#125; &lt;/li&gt; &lt;/ol&gt;&lt;/div&gt; 12345678910var app = new Vue(&#123; el: &apos;#app&apos;, data: &#123; todos:［ &#123; text : &apos;吃饭&apos; &#125;, &#123; text : &apos;睡觉&apos; &#125;, &#123; text : &apos;打游戏&apos; &#125; ］ &#125;&#125;) 处理用户输入（ v-on 指令和 v-model 指令）事件监听器1234&lt;div id=&quot;app&quot;&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;button v-on:click=&quot;reverseMessage&quot;&gt;逆转消息&lt;/&lt;/div&gt; 1234567891011var app = new Vue(&#123; el:&apos;#app&apos;, data: &#123; message: &apos;hello&apos; &#125;, methods: &#123; reverseMessage: function()&#123; this.message = this.message.split(&apos;&apos;).reverse().join() &#125; &#125;&#125;) 双向绑定1234&lt;div id=&quot;app&quot;&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;input v-model=&quot;message&quot; &gt;&lt;/div&gt; 123456var app = new Vue(&#123; el: &apos;#app&apos;, data:&#123; message: &apos;hello&apos; &#125;&#125;) 组件化12345&lt;div id=&quot;app&quot;&gt; &lt;ol&gt; &lt;todo-item v-for=&quot;item in list&quot; v-bind:todo=&quot;item&quot;&gt;&lt;/todo-item&gt; &lt;/ol&gt;&lt;/div&gt; 123456789101112131415Vue.component(&apos;todo-item&apos;, &#123; props: [&apos;todo&apos;], //接受一个自定义属性todo template: &apos;&lt;li&gt;&#123;&#123; todo.text &#125;&#125;&lt;/li&gt;&apos;&#125;)var app = new Vue(&#123; el:&apos;#app&apos;, data: &#123; list : [ &#123; text: &apos;apple&apos; &#125;, &#123; text: &apos;banana&apos; &#125;, &#123; text: &apos;orange&apos; &#125; ] &#125;&#125;) 注意，在这个例子中 v-for 循环渲染子组件 todo-item ，并传递了 item 变量。接着 v-bind 指令将 item 与子组件的 todo 属性绑定起来，接受到 todo 属性的子组件读取 todo.text 插入到 &lt;li&gt; 中。整个过程，父组件向子组件单向传递数据并渲染出来。 小结指令 v-bind:name v-if v-for v-on v-model 参考https://cn.vuejs.org/v2/guide/]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS：table-cell 用法小记]]></title>
    <url>%2F2017%2F06%2F01%2FCSS%EF%BC%9Atable-cell%20%E7%94%A8%E6%B3%95%E5%B0%8F%2F</url>
    <content type="text"><![CDATA[1、垂直居中123&lt;div class=&quot;table-cell&quot;&gt; &lt;div&gt;需要垂直居中的元素&lt;/div&gt;&lt;/div&gt; 12345.table-cell &#123; display: table-cell; verticall-align: middle; height: 200px;&#125; 2、等高布局12345678&lt;div class=&quot;table&quot;&gt; &lt;div class=&quot;table-cell&quot;&gt; &lt;div&gt;等高布局&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;table-cell width-100&quot;&gt; &lt;div&gt;table-cell的高度取决于所有table-cell中最大的高度&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 123456789.table &#123; display: table;&#125;.table-cell &#123; display: table-cell;&#125;.width-100 &#123; width: 100px;&#125; 3、平均划分子元素1234567891011&lt;div class=&quot;table&quot;&gt; &lt;div class=&quot;table-cell&quot;&gt; 子元素 &lt;/div&gt; &lt;div class=&quot;table-cell&quot;&gt; 子元素 &lt;/div&gt; &lt;div class=&quot;table-cell&quot;&gt; 子元素 &lt;/div&gt;&lt;/div&gt; 1234567.table &#123; display: table; width: 100%;&#125;.table-cell &#123; display: table-cell;&#125; 参考https://my.oschina.net/CharmyZ/blog/714983]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript：Promise 小记]]></title>
    <url>%2F2017%2F05%2F28%2FJavaScript%EF%BC%9APromise%20%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Promise 对象是一个代理对象（代理一个值），被代理的值在 Promise 对象创建时可能是未知的。它最主要的特点，是可以让异步代码像同步方法那样返回值，并为结果的成功（onFulfilled）和失败（onRejected）绑定相应的处理方法（Handlers）。需要注意的是，尽管看起来像同步方法那样返回了值但是并不是立即返回执行的。 1234567891011new Promise(function(resolve, reject)&#123; resolve(1);&#125;).then(function(msg)&#123; console.log(msg);&#125;)console.log(2);// 输出顺序为// 2// 1 一个 Promise 有以下几种状态： pendding 初始状态 fulfilled 意味着操作成功 rejected 意味着操作失败 语法12345678910111213141516171819202122var promise = new Promise( /* executor */ function(resolve, reject) &#123;...&#125;);// 第一种处理方式promise.then( /* onFulfilled */ function()&#123;...&#125;, /* onRejected */ function()&#123;...&#125;)// 第二种处理方式promise.then( /* onFulfilled */ function()&#123;...&#125;).catch( /* onRejected */ function()&#123;...&#125;) 与回调函数的区别先来看一下一个普通的异步处理，使用回调函数来处理回调的结果： 123456789getAsycn(&quot;file.txt&quot;, function(error, result)&#123; if(error)&#123; // 取得失败时的处理 throw error; &#125; // 取得成功时的处理 &#125;) 接下来是使用Promise的处理方式： 123456789var promise = getAsyncPromise(&quot;file.txt&quot;); // 返回一个Promise对象promise.then(function(result)&#123; // 取得成功时的处理 &#125;.catch(function(error)&#123; // 取得失败时的处理 &#125;) 参考https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是Hybrid App]]></title>
    <url>%2F2017%2F05%2F23%2F%E4%BB%80%E4%B9%88%E6%98%AFHybrid%20App%2F</url>
    <content type="text"><![CDATA[什么是HybridHybrid 出现的历史原因 2013年起移动互联网的兴起导致App开发的需求日益高涨。 2014年 H5 的发布，使得 Web 能够实现更多功能。 在产品需要快速迭代、抢占市场的大背景下，开发 iOS 和 Android 原生应用的时间成本和劳动成本都非常高。 随着 iOS 和 Android 两大阵营对 H5 的支持日益完善，H5 足以实现大多数的需求。 为了利用 Web 应用低成本、高效率、跨成本等诸多优点，出现了使用 Web 和 Native 混合进行开发的模式。 Hybrid 的分类App 应用从实现机制上来区分，主要分为三类： Native 应用：使用原生语言的应用，能够调用所有底层接口，交互体验最好。 Web App 应用：使用纯 Web 开发的应用，通过浏览器访问，交互体验最差。 Hybrid 应用： 以 WebView 作为用户界面层，以 JavaScript 为基本逻辑通过与中间件通讯、访问底层 API ，进行应用开发。 使用非官方语言的工具，打包成原生应用的方式开发。 基于原生应用的架构，在部分功能中嵌入 WebView 。WebView 负责对界面的渲染，同时也可以访问底层的 API 以实现特定的功能。 通过 JavaScript 引擎管理和渲染 native 视图，将 JavaScript 代码渲染成原生组件，调用原生 API 与用户进行交互。（ReactNative、Weex） Hybrid 的优势 开发效率高 开发成本低 跨平台 快速迭代，无需发布版本即可修复Bug 总结来说，Hybrid 是既保持了对原生API的完整掌控，同时可以在特定功能下节省跨平台开发成本、提升效率。 Hybrid 的劣势 容易造成性能问题，不适用于依赖原生 API 、动画较多和游戏开发的需求。 永远保持最新（直接访问线上，而不是使用 App 本地的静态资源）带来的低版本机型的适配问题，包括调用底层 API 和对 H5 的支持方面。（即不太好做版本控制） 需要实现 Native 与 H5 之间的通信机制 交互体验不如原生页面，需要尽可能仿制原生应用的体验 总结来说，Web 只能替代、辅助一部分功能，无法取代原生开发的主导地位。 Hybrid 实现Native 与前端之间的关系Hybrid App 底层依赖于 Native 提供的容器，上层使用 H5 做业务开发，底层透明化、上层多样化，适合前端介入进行快速迭代开发。 Native 提供的实际上是类似于浏览器的宿主环境，H5 页面可以利用宿主环境提供的“能力”来进行开发。正如一般浏览器为 JavaScript 提供了 window 对象以控制浏览器一样，Native 也可以为 H5 页面提供特定的接口以调用底层的 API。 Hybrid 交互设计Native 可以调用前端页面的 JavaScript 方法对视图进行操作，前端页面也可以通过 JavaScript 方法调用 Native 提供的接口实现系统层面的功能。两者沟通的桥梁则是 WebView。 SchemaApp 自身可以自定义 URL Schema，并且把自定义的 URL 注册在调度中心。App 安装后会在手机上注册一个 Schema，例如淘宝是 taobao:// ，Native 会有一个进程监控 WebView 发出的所有 schema:// 请求，从而打开 Native 应用并传入参数执行特定的行为。 通过 Schema ，H5 可以通过发起 schema 请求，来实现 H5 与 Native 页面之间的跳转。 常用交互 API 跳转 页面内部跳转 H5 跳转 Native 界面，Native 通过截获 URL 参数跳转到响应页面。 H5 新打开一个 WebView。 Header 组件 避免白屏陷入假死状态 Header 左侧和右侧按钮可配置，中间 title 部分可配置 请求类 通过 Native 代理发起 AJAX 请求，解决跨域问题 Native UI 组件 Loading 组件 Toast 组件 参考http://www.cnblogs.com/yexiaochai/p/4921635.html http://ued.ctrip.com/blog/translation-hybrid-mobile-application-provide-native-web-technology-experience.html https://dailc.github.io/2016/10/04/hybridBase01HybridInfo.html https://dailc.github.io/2016/10/04/hybridBase02HybridCompareOthers.html https://weex.apache.org/cn/ http://www.infoq.com/cn/articles/hybrid-app-development-combat#note-bottom-anchor http://www.jianshu.com/p/e83aa2d1ade3]]></content>
      <tags>
        <tag>fe</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSON：JSON 方法小记]]></title>
    <url>%2F2017%2F05%2F19%2FJSON%EF%BC%9AJSON%20%E6%96%B9%E6%B3%95%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[JSON.parse() JSON.parse( text[, reviver] ) text : 要被解析成 JavaScript 值的字符串 reviver : 规定原始值如何被解析改造的函数 reviver 函数解析值本身以及它所包含的值，从里向外调用去调用 reviver 函数。属性名和属性值会作为参数传入 reviver 中，如果 reviver 返回 undefined ，那么当前属性就会从对象中删除；如果返回其他值，返回值就会作为当前属性新的属性值。 注意，遍历到顶层时，传入 reviver 函数的是空字符串和当前对象，即{&quot;&quot; : 修改过的解析值 }。这是个特例，需要特别注意。 所以 reviver 函数有基本两种种用法： 1、删除特定属性 12345678var str = &apos;&#123;&quot;a&quot;:1, &quot;b&quot;:2&#125;&apos;;// 将属性值置为 undefined 删除属性var json = JSON.parse(str,function(key, value)&#123; return key == &apos;a&apos; ? undefined : value;&#125;)console.log(json); // &#123;b:2&#125; 2、修改特定属性的值 1234567var str = &apos;&#123;&quot;a&quot;:1, &quot;b&quot;:2&#125;&apos;;var json = JSON.parse(str, function(key, value)&#123; return key == &apos;a&apos; ? value * 2 : value;&#125;)console.log(json); // &#123;a:2, b:4&#125; JSON.stringify() JSON.stringify value[, replacer[, space ]] ) value : 要被转换成 JSON 字符串的值 replacer : 规定如何转换和处理值的属性 space : 指定缩进用的空白字符串 replacer 参数传入函数返回 undefined 代表不输出该属性；输出其他（包括 null ）都会替代原来的属性值输出。 1234567891011function replacer(key, value) &#123; if (typeof value === &quot;string&quot;) &#123; return undefined; &#125; return value;&#125;var foo = &#123;foundation: &quot;Mozilla&quot;, model: &quot;box&quot;, week: 45, transport: &quot;car&quot;, month: 7&#125;;var jsonString = JSON.stringify(foo, replacer);console.log(jsonString); // &#123;&quot;week&quot;:45,&quot;month&quot;:7&#125; 传入数组根据属性名指定哪些属性会被输出。 1234var foo = &#123;foundation: &quot;Mozilla&quot;, model: &quot;box&quot;, week: 45, transport: &quot;car&quot;, month: 7&#125;;var jsonString = JSON.stringify(foo, [&apos;week&apos;,&apos;model&apos;]);console.log(jsonString); // &#123;&quot;week&quot;:45,&quot;model&quot;:&quot;box&quot;&#125; 传入 undefined 或 null输出所有的属性。 1234var foo = &#123;foundation: &quot;Mozilla&quot;, model: &quot;box&quot;, week: 45, transport: &quot;car&quot;, month: 7&#125;;var jsonString = JSON.stringify(foo, null);console.log(jsonString); // &#123;&quot;foundation&quot;:&quot;Mozilla&quot;,&quot;model&quot;:&quot;box&quot;,&quot;week&quot;:45,&quot;transport&quot;:&quot;car&quot;,&quot;month&quot;:7&#125; space 参数指定缩进用的空白字符串，用于美化输出。 如果参数是数字，就代表有多少空格，上限是10； 如果参数是字符串，则为该字符串的前10个字母； 如果参数没有提供，就意味着没有空格。 除此之外，也可以传入转义字符（ \t ）来用 tab 进行缩进。 参考https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript：逻辑与 与 逻辑或]]></title>
    <url>%2F2017%2F05%2F08%2FJavaScript%EF%BC%9A%E9%80%BB%E8%BE%91%E4%B8%8E%20%E4%B8%8E%20%E9%80%BB%E8%BE%91%E6%88%96%2F</url>
    <content type="text"><![CDATA[逻辑与逻辑与是短路操作，如果第一个操作数能够决定结果，那么将不会对接下来的操作数进行求值。 1234567var a = 0, b = 1;a &amp;&amp; b++;console.log(a); // 0console.log(b); // 1, b++没有执行 表达式语句的值如果操作数都是True（对象、非空字符串、非0或NaN的数字、布尔值True），则返回最后一个操作数。 如果操作数中有若干个False（Null、Undefined、空字符串、NaN、布尔值False），则返回第一个False。 12345678&#123;&#125; &amp;&amp; false ; // false&#123;&#125; &amp;&amp; 0; // 0&#123;&#125; &amp;&amp; null; // null&#123;&#125; &amp;&amp; undefined; // undefinednull &amp;&amp; 0; // null&#123;a:1&#125; &amp;&amp; &#123;b:1&#125; &amp;&amp; &#123;c:1&#125;; // &#123;c:1&#125; 与函数相结合 12true &amp;&amp; foo(); // 执行footrue &amp;&amp; false &amp;&amp; foo(); // 返回false，不执行foo 逻辑或逻辑或与逻辑与一样，也是短路操作。 1234567var a = 0, b = 1;b || a++;console.log(a); // 0console.log(b); // 1 表达式语句的值如果操作数都是False，则返回最后一个操作数。 如果操作数中有若干个True，则返回第一个True。 逻辑或一般用于避免给变量赋null或undefined值。 1234var foo = null; bar = 1;var value = foo || bar; 也可以用来在函数中对参数进行校验，下面三个函数等价，但是显然第一个是最优雅的。 123456789101112131415function(v)&#123; var value = v || defaultValue;&#125;function(v)&#123; var value = !!v ? v : defaultValue;&#125;function(v)&#123; if(v)&#123; var value = v; &#125;else&#123; var value = defaultValue; &#125;&#125;]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript：从代码复用到面向对象]]></title>
    <url>%2F2017%2F05%2F03%2FJavaScript%EF%BC%9A%E4%BB%8E%E4%BB%A3%E7%A0%81%E5%A4%8D%E7%94%A8%E5%88%B0%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[代码复用的问题12var foo = &#123;color:&apos;red&apos;&#125;;var bar = &#123;color:&apos;green&apos;&#125;; 这段代码中我们生成了两个属性相似的对象，每次生成一个类似的对象都需要重新写一遍代码。 装饰器函数添加属性123456789// lib.jsvar fn = function(obj,color)&#123; obj.color = color; return obj;&#125;// app.jsvar foo = fn(&#123;&#125;,&apos;red&apos;);var bar = fn(&#123;&#125;,&apos;green&apos;); 我们可以通过一个装饰器函数，来解决生成类似对象的问题。 装饰器函数的作用，就是给某个已拥有某些功能的对象添加属性。这里我们传入了一个空的对象，通过fn函数来对这个空对象进行”装饰“（添加属性）。 添加方法浪费内存123456789101112131415// lib.jsvar fn = function(obj,color)&#123; obj.color = color; obj.printColor = function()&#123; console.log(this.color); &#125; return obj;&#125;// app.jsvar foo = fn(&#123;&#125;,&apos;red&apos;);foo.printColor(); // redvar bar = fn(&#123;&#125;,&apos;green&apos;);bar.printColor(); // green 上述添加方法的方式，优点是具有良好的封装性，但是最大的问题是每次调用装饰器函数都会在内存中生成一个新的printColor函数。在对象比较多的情况下，就容易浪费内存。 更多的缺点12345678910111213141516// lib.jsvar fn = function(obj,color)&#123; obj.color = color; obj.printColor = printColor; return obj;&#125;var printColor = function()&#123; console.log(this.printColor);&#125;// app.jsvar foo = fn(&#123;&#125;,&apos;red&apos;);foo.printColor(); // redvar bar = fn(&#123;&#125;,&apos;green&apos;);bar.printColor(); // green 上述添加方法的方式，尽管解决了内存占用的问题，但是失去了良好的封装性。 除此之外，如果添加的方法比较多，每次都需要在fn中对函数进行绑定，效率很低。 123456789101112131415// lib.jsvar fn = function(obj,color)&#123; obj.color = color; obj.method_1 = method_1; obj.method_2 = method_2; // ... obj.method_1000 = method_3; return obj;&#125;var method_1 = function()&#123; //... &#125;;var method_2 = function()&#123; //... &#125;;// ...var method_1000 = function()&#123; //... &#125;; 把方法都装在一起在把方法都装进methods中，通过遍历的方式可以把任意数量的方法绑定到obj上。 123456789101112131415// lib.jsvar fn = function(obj,color)&#123; obj.color = color; extend(obj,methods); // extend()代表把methods中的属性复制到obj中，注意它并不是原生的函数 return obj;&#125;var methods = &#123; method_1:function()&#123; //... &#125;, method_2:function()&#123; //... &#125;, // ... method_1000:function()&#123; //... &#125;&#125;; 借助Function对象的属性methods与fn之间没有一个非常明显的联系，为此我们可以利用Function对象的属性来解决。 123456789101112131415// lib.jsvar fn = function(obj,color)&#123; obj.color = color; extend(obj, fn.methods); return obj;&#125;fn.methods = &#123; method_1:function()&#123; //... &#125;, method_2:function()&#123; //... &#125;, // ... method_1000:function()&#123; //... &#125;&#125; 直接在function内部创建对象12345678910// lib.jsvar fn = function(color)&#123; var obj = &#123;&#125;; obj.color = color; extend(obj, fn.methods); return obj;&#125; 原型委托123456789// lib.jsvar fn = function(color)&#123; var obj = Object.create(fn.methods); obj.color = color; return obj;&#125;fn.methods = &#123; //... &#125;; 使用prototype属性12345678910// lib.jsvar fn = function(color)&#123; var obj = Object.create(fn.prototype); obj.color = color; return obj;&#125;fn.prototype.printColor = function()&#123; console.log(this.color);&#125; 此时fn就是一个“构造函数”，每一个函数对象被创建时都会有一个prototype属性，这个属性跟之前的fn.methods其实并没有太大的区别，唯一的区别在于prototype.constructor指向了函数对象本身。 在我们讨论“实例的原型”和“构造函数的原型”时要注意：“实例的原型”实际上就是instance.prototype，在实例中没有的属性会被委托到原型中进行查找。而“构造函数的原型”，实际上是“创建一个对象，并且把这个对象委托给原型进行函数共享”。 关系验证1234567// app.jsvar foo = fn(&apos;red&apos;);var bar = fn(&apos;green&apos;);console.log(foo instanceof fn); // true// instanceof 操作符 实际上执行的就是下面的操作console.log(foo.constructor == fn.prototype.construector); // true new 关键字在fn中，创建一个对象、原型委托和返回对象是一定会做的一件事情，我们可以通过new关键字来简化。 1234// lib.jsvar fn = function(color)&#123; this.color = color;&#125; 在使用new关键字进行调用时（构造模式），解释器会自动插入两行代码： 12345678// lib.jsvar fn = function(color)&#123; this = Object.create(fn.prototype); // 将新对象委托给原型对象 this.color; return this; // 返回这个新对象&#125; 使用构造模式即使用new关键字调用fn函数才能被真正称作“构造函数”。 子类继承1234567891011121314151617181920var Human = function(name)&#123; this.name = name;&#125;Human.prototype.sayName = function()&#123; console.log(this.name);&#125;var Man = function(name)&#123; Human.call(this, name); this.sex = &apos;male&apos;;&#125;Man.prototype = Object.create(Human.prototype);Man.prototype.constructor = Man;var frank = new Man(&apos;frank&apos;);frank.sayName(); // frankconsole.log(frank instanceof Man); // trueconsole.log(frank instanceof Human); // true 务必注意Man继承Human时调用的Human方法，其使用call方法指定了this绑定的对象。this在JavaScript中可以作为一个传入的参数来看待，在使用obj.method()时，method中的this指向obj，而使用new method()时，this指向新构造的空对象。 此外，Man.prototype对象的原型委托给了Human.prototype形成了原型链。这里还需要注意要重新指定Man.prototype.constructor赋值Man。]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript：作用域、闭包 和 this]]></title>
    <url>%2F2017%2F04%2F27%2FJavaScript%EF%BC%9A%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E9%97%AD%E5%8C%85%20%E5%92%8C%20this%2F</url>
    <content type="text"><![CDATA[作用域（Scope）在JavaScript中，函数的一对花括号中会产生一个新的作用域。这个作用域只有函数内部能够访问。 123456789var a = 1;var fn = function()&#123; var b = 2; console.log(b);&#125;console.log(a); // 1fn(); // 2console.log(b); // Error 需要注意的是，if、while、for语句的语句块也是一对花括号构成，但是这对花括号并没有形成新的作用域。 123456789var a = 1;if(a)&#123; var b = 2; console.log(b); // 2&#125;console.log(a); // 1console.log(b); // 2，可以获取if()&#123;&#125;中的变量b while、for语句同理。 执行上下文（Excution context）执行上下文是内存中存储的作用域结构，也叫内存作用域。根据执行上下文，我们可以知道哪些变量是可以被访问的，而哪些变量是在作用域之外的。需要注意的是，函数在没有被执行之前，我们只需要记下”函数的位置“即可，到真正被调用的时候，再去计算里面的值，此时就需要注意作用域的问题了。 闭包（Closure）由于每个函数可以访问包围它的作用域中的变量，所以闭包指的就是，在外部作用域已经返回之后还能访问该作用域的任意函数。 简单来说，就是能访问函数内部作用域的函数。 123456789function closure()&#123; var a = 1; return function()&#123; console.log(a); &#125;&#125;closure()(); // 1 返回的匿名函数可以访问closure的作用域，故能够获取变量a的值。此时，这个返回的匿名函数就是一个闭包。 闭包能够访问一个函数内部的私有变量，这个私有变量是外部作用域永远无法访问的。 透彻理解解释器执行代码时的工作方式，以及变量作用域和闭包，对JS面向对象编程是至关重要的。 this 对this最好的理解，是把它看做函数被调用时传入的参数。 在函数没有被调用前，我们永远无法得知this指向哪一个对象。 123456789101112131415161718192021var fn = function(one, two)&#123; console.log(one, two);&#125;var r=&#123;&#125;, g=&#123;&#125;, b=&#123;&#125;, y=&#123;&#125;;r.method = fn;r.method(); // this=r, one=undefined, two=undefinedfn(g,b); // Global, g, bfn.call(r, g, b); // r, g, br.method.call(y, g, b); // y, g, bsetTimeout(fn, 1000); // this的值不确定，undefined, undefinedsetTimeout(r.method, 1000); // this的值不确定（跟r无关），undefined,undefinedsetTimeout(function()&#123; r.method(); // r, undefined, undefined &#125;,1000); console.log(one); // Referrence Errorconsole.log(this); // Globalnew r.method(g, b); // &#123;&#125;, g, b 上面的代码例子中注意setTimeout(r.method, 1000)和new r.method(g ,b)。 注意点1：其实是同一个function对象实际上r.method和fn指向的是同一个function对象，只是两者在执行时，传入的是不同的this参数。 所以以下两个语句是相等的 123setTimeout(r.method, 1000);setTimeout(fn, 1000); 注意点2：new关键字的作用new关键字执行了以下几步： 创建一个空对象 把函数的this指向这个空对象 执行这个函数 返回创建的对象 所以下面三条语句实际上是相等的。 12345new r.method(g, b);r.method.call(&#123;&#125;,g,b);fn.call(&#123;&#125;,g,b); 全程，其实跟r一点关系都没有。]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery：基础 DOM 操作方法]]></title>
    <url>%2F2017%2F04%2F26%2FjQuery%EF%BC%9A%E5%9F%BA%E7%A1%80%20DOM%20%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[元素选择获取元素1234567// $(selector)$(&apos;div.foo&apos;);// $(element)$(&apos;div.foo&apos;).on(&apos;click&apos;,function()&#123; $(this).slideUp();&#125;) 遍历元素1234567891011121314// 父元素$(&apos;div.foo&apos;).parent();// 祖先元素$(&apos;div.foo&apos;).parents();// 子元素$(&apos;div.foo&apos;).children();// 后代元素$(&apos;div.foo&apos;).find();// 兄弟元素$(&apos;div.foo&apos;).sibling(); DOM操作添加or删除class1$(&apos;div.foo&apos;).toggleClass(&apos;bar&apos;); 修改or获取属性12$(&apos;div.foo a&apos;).attr(&apos;href&apos;,&apos;#1&apos;);$(&apos;div.foo a&apos;).attr(&apos;href&apos;); // #1 修改or获取CSS12$(&apos;div.foo&apos;).css(&apos;font-size&apos;,&apos;20px&apos;);$(&apos;div.foo&apos;).css(&apos;font-size&apos;); // 20px 获取内容123$(&apos;div.foo&apos;).html(); // 完整的HTML代码$(&apos;div.foo&apos;).text(); // 去掉HTML标签后的文本$(&apos;div.foo input&apos;).val(); // 获取输入的值 移除1$(&apos;div.foo&apos;).remove(); 添加child元素12$(&apos;div.foo&apos;).append(&apos;&lt;p&gt;last child&lt;/p&gt;&apos;&gt;$(&apos;div.foo&apos;).prepend(&apos;&lt;p&gt;first child&lt;/p&gt;&apos;&gt; 添加sibling元素12345$(&apos;div.foo&apos;).after(&apos;&lt;div&gt;sibling after div.foo&lt;/div&gt;&apos;);$(&apos;div.foo&apos;).before(&apos;&lt;div&gt;sibling before div.foo&lt;/div&gt;&apos;);$(&apos;&lt;div&gt;sibling after div.foo&lt;/div&gt;&apos;).insertAfter($(&apos;div.foo&apos;));$(&apos;&lt;div&gt;sibling before div.foo&lt;/div&gt;&apos;).insertBefore($(&apos;div.foo&apos;)); 遍历1234$(&apos;p&apos;).each(function()&#123; var len = $(this).text().length; alert(len); // 输出每个p标签的文字长度&#125;) DOM加载完成后执行1234567891011$(function()&#123; alert(&apos;the document is ready&apos;); //do something&#125;)$(document).ready(function()&#123; alert(&apos;the document is ready&apos;); //do something&#125;)]]></content>
      <tags>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery：事件监听用法]]></title>
    <url>%2F2017%2F04%2F26%2FjQuery%EF%BC%9A%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[常见事件类型 Form events: 如 submit Focus events: 如 blur, focus, change Input devices events: 如 keyup, keypress, mouseover, mousemove, mouseleave View events: 如 scroll, resize 事件监听三要素 the target element to listen to，监听对象 the event we want to react to，监听事件 the actions to take in response，回调函数 基础示例123$(&apos;div.foo button&apos;).on(&apos;click&apos;,function()&#123; $(this).remove();&#125;) 更多用法1234// 传递事件对象$(&apos;div.foo button).on(&apos;click&apos;,function(event)&#123; $(event.target).remove(); // event.target 事件目标的页面元素&#125;) 12345// 阻止默认行为$(&apos;div.foo a).on(&apos;click&apos;,function(event)&#123; event.preventDefault(); console.log(&apos;the link you clicked will not work&apos;);&#125;) event event.keyCode，用来了解按下的是哪个键 event.pageX, event.pageY，用来了解点击发生的坐标位置 event.type，用来了解发生的事件 简易写法1234$(&apos;div.foo&apos;).click(function()&#123;...&#125;);$(&apos;div.foo&apos;).hover(function()&#123;...&#125;);//等等 需要注意的是，.hover()监听了两个事件mouseenter和mouseleave，并且并不是所有事件都有简易的写法。 更多简易写法参考：jQuery: Events 事件代理12345678&lt;div class=&quot;foo&quot;&gt; &lt;ul&gt; &lt;li&gt; 1 &lt;/li&gt; &lt;li&gt; 2 &lt;/li&gt; ... &lt;li&gt; 1000 &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 假设有如上这样一个DOM片段，如果用以下方式进行事件监听，则会产生过多的监听器，导致性能问题。 123$(&apos;div.foo li&apos;).on(&apos;click&apos;,function(event)&#123; console.log(event.target);&#125;) 此时可以使用父元素事件代理（event delegation）的方式来处理，只用了一个监听器。 123$(&apos;div.foo&apos;).on(&apos;click&apos;,&apos;li&apos;,function(event)&#123; console.log(event.target);&#125;) 参考MDN: Events Catagory jQuery: Event Object jQuery: event.targer W3C: Dom Level-3 Event jQuery: Event Delegation]]></content>
      <tags>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端：跨域方法小记]]></title>
    <url>%2F2017%2F04%2F24%2F%E5%89%8D%E7%AB%AF%EF%BC%9A%E8%B7%A8%E5%9F%9F%E6%96%B9%E6%B3%95%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[产生背景为了防止跨站请求伪造（CSRF，Cross-site request forgery）攻击，浏览器引入了同源策略（SOP，Same-Origin Policy）来提高安全性。 同源策略指的是，只要在同一域名（domain或ip）、同一端口、同一协议下才能互相获取资源。 一个域名A的网页可以获取域名B的静态资源（如CSS文件、图片等），但是不能直接发起AJAX（Asynchronous JavaScript and XML）请求。 JS跨域JSONP原理：通过动态插入JS脚本的方式来实现跨域。 该方法适合跨域获取JSON类型的数据。缺点是只支持GET方式。 document.domain原理：通过修改两个同一一级域名不同二级域名页面（如example.com与a.example）的document.domain来实现跨域。document.domain只能修改为自身或者高一级的父域名。 该方法适用于同父域名下的跨域问题。 window.name原理：window对象的name属性有一个特征，即在一个窗口（window）的生命周期下，窗口载入的所有页面都共享一个window.name，故我们可以通过插入一个外部页面的iframe，通过JS修改window.name，再将window.location改为同源的页面，来访问window.name的值进行跨域。 该方法的缺点是需要额外的同源页面，同时不同浏览器对window.name的大小也有一定的限制。 window.postMessage原理：window.postMessage(message, targetOrigin)，是HTML5新引进的特性，可以用来向同源或者不同源的window对象发送消息。插入一个iframe，获取iframe.contentWindow，然后使用postMessage发送消息，在iframe预先设置onmessage的处理函数，即可获取跨域的数据。 该方法适用于处理多页面通信以及与iframe之间的消息传递。 服务端反向代理原理：通过将外部资源映射成内部的地址，再通过代理服务器去获取真实的资源，然后返回给浏览器，避免在浏览器端进行跨域操作。 反向代理，代理的是服务器，客户端只需要知道代理服务器上的资源URL地址即可，而不关心资源的真正URL。例如负载均衡就会用到反向代理。 正向代理，则是代理客户端，客户端需要知道资源的实际URL，通过告诉代理服务器真正的资源URL所在的位置，让代理服务器去获取后返还给客户端。例如翻墙工具就是正向代理。 CORS浏览器发送一个带有Origin首部字段的HTTP请求，表明请求的来源。服务器的响应头中包含Access-Control-Allow-Origin表明允许哪些域名的请求。一旦不匹配则拒绝访问。通常设置为Access-Control-Allow-Origin: *可以允许任意域名跨域请求该服务器上的资源。]]></content>
      <tags>
        <tag>fe</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React：基本环境搭建简明步骤]]></title>
    <url>%2F2017%2F04%2F14%2FReact%EF%BC%9A%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%AE%80%E6%98%8E%E6%AD%A5%E9%AA%A4%2F</url>
    <content type="text"><![CDATA[超简的步骤整理。待完善。 Babel ESLint webpack Babelbabel是一个多用途的JavaScript编译器，用它的目的有二：一是支持ES6语法，二是支持React的一些特性（JSX）语法等。 安装在这里我们是跟webpack一起用的，所以需要的是babel-core核心模块和babel-lodaer，如果需要单独使用babel则安装babel-cli。 $ npm i babel-core babel-loader --save-dev 接下来安装babel presets $ npm i babel-preset-es2015 babel-preset-react --save-dev 配置在根目录下新建一个.babelrc文件，并加入以下配置 { &quot;presets&quot;: [&quot;es2015&quot;, &quot;react&quot;] } ESLintESLint是一个代码检查工具，用于检查和统一代码规范。 安装$ npm i eslint eslint-loader --save-dev 配置$ eslint --init 接下来根据你的需求进行选择即可，非常方便。最终可选择生成一个.eslint.json文件。我的配置如下： { &quot;env&quot;: { &quot;browser&quot;: true, &quot;commonjs&quot;: true, &quot;es6&quot;: true, &quot;node&quot;: true }, &quot;extends&quot;: &quot;eslint:recommended&quot;, &quot;parserOptions&quot;: { &quot;ecmaFeatures&quot;: { &quot;experimentalObjectRestSpread&quot;: true, &quot;jsx&quot;: true }, &quot;sourceType&quot;: &quot;module&quot; }, &quot;plugins&quot;: [ &quot;react&quot; ], &quot;rules&quot;: { &quot;linebreak-style&quot;: [ &quot;error&quot;, &quot;unix&quot; ], &quot;quotes&quot;: [ &quot;error&quot;, &quot;single&quot; ], &quot;semi&quot;: [ &quot;error&quot;, &quot;always&quot; ] } } 更多的配置可参照ESLint webpackwebpack是当前非常流行的模块打包工具，上述的Babel和ESLint都可以作为loader在webpack中被使用。 注意：本文使用的是webpack 2，webpack 1和webpack 2在配置上有诸多不同之处，请务必留心。 链接：webpack 1和2的区别 安装$ npm i webpack webpack-dev-server --save-dev 插件用于自动生成HTML页面，并引入正确的JavaScript文件依赖。 $ npm i html-webpack-plugin --save-dev loader处理CSS文件需要用到的两个loader。 $ npm i css-loader style-loader 配置在根目录下新建一个app目录，同时再创建一个webpack.config.js文件。 var path = require(&apos;path&apos;); var HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;); var ROOT_PATH = path.resolve(__dirname); var APP_PATH = path.resolve(ROOT_PATH, &apos;app&apos;); var BUILD_PATH = path.resolve(ROOT_PATH, &apos;build&apos;); module.exports = { entry: { app: path.resolve(APP_PATH, &apos;app.jsx&apos;) }, output: { path: BUILD_PATH, filename: &apos;bundle.js&apos; }, devtool: &apos;eval-source-map&apos;, devServer: { historyApiFallback: true, hot: true, inline: true, }, module: { rules: [{ test: /\.jsx?$/, enforce: &apos;pre&apos;, loaders: [&apos;eslint-loader&apos;], include: APP_PATH }, { test: /\.css$/, loaders: [&apos;style-loader&apos;, &apos;css-loader&apos;] }, { test: /\.jsx?$/, loader: [&apos;babel-loader&apos;], include: APP_PATH }], }, plugins: [ new HtmlWebpackPlugin({ title: &apos;react-dev&apos; }) ], resolve: { extensions: [&apos;.js&apos;, &apos;.jsx&apos;] } }; 最后添加两条命令到package.json里。 &quot;scripts&quot;: { &quot;build&quot;:&quot;webpack&quot;, &quot;dev&quot;:&quot;webpack-dev-server --hot&quot; } 通过在Terminal中输入 npm run build 或 npm run dev 执行。]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP基础（2）：常见的状态码]]></title>
    <url>%2F2017%2F04%2F12%2FHTTP%EF%BC%9A%E5%B8%B8%E8%A7%81%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81%2F</url>
    <content type="text"><![CDATA[HTTP状态码用于描述客户端向服务器端发送请求后的请求结果。通过状态码，客户端可以知道发出的HTTP是是否被正确处理。 状态码由三位数字和原因短语组成，第一位指定了响应类别。 状态码的类别： 1XX：Informational 信息性状态码，表示服务器接收的请求正在被处理 2XX：Success 成功状态码，表示请求被正常处理完毕 3XX：Redirection 重定向状态码，表示客户端需要进行附加操作以完成请求 4XX：Client Error 客户端错误状态码，表示因某种原因服务器无法处理请求 5XX：Server Error 服务器错误状态码，表示服务器处理请求时出错 2XX 成功200 OK表示客户端的请求被服务器端正常处理了。 在这个状态码下，服务器的响应内容则依据请求方法决定。如果请求方法为GET，那么，对应请求资源的实体会一并返回；如果请求方法是HEAD，那么仅返回首部，而对应资源的实体不会被返回。 204 No Content表示客户端的请求被服务器端正常处理，但是响应报文中不含有实体的主体部分。实际上204状态码下也不允许响应报文中有实体的主体部分。 该响应码一般用于客户端向服务器端发送信息，而服务器端不必返回新信息的情况下使用。 206 Partial Content该状态码表示客户端进行了范围请求（请求资源的一部分内容），而服务器成功执行了这部分的GET请求。响应报文中包含由Content-Range指定的实体内容。 3XX 重定向301 Moved Permanently永久性重定向。该状态码表示请求的资源已经分配了新的URI，新的URI在Location首部字段中。 302 Found临时性重定向。该状态码表示请求的资源已经分配了新的URI，希望客户端此次能以新的URI进行访问。 注意302是临时性的重定向，请求的资源在将来还有可能换成别的URI。所以与永久性重定向的区别是，301是让客户端之后都用新的URI访问（相当于搬家，其住址URI不会轻易变更），而302时客户端之后仍然应该访问返回302的页面，以获得请求的资源最新的URI（相当于租房，其住址URI随时会变）。 303 See Other该状态码表示由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源。 303与302基本相似，唯一不同处是明确规定需要用GET方法去访问新的URI。例如当使用POST方法访问CGI（公共网关接口，Common Gateway Interface）程序，随后服务器端希望客户端以GET方法重定向到另一个URI上去时，返回303状态码。 304 Not Modified该状态表示客户端发送附带条件的请求时（在请求头部中包含If-Match、If-Modified-Since、If-None-Match、If-Range、If-Unmodified-Since），服务器端允许请求访问资源，但因发生请求未满足条件，直接返回304。 即表示服务器端的资源没有发生改变，客户端可以继续使用未过期的缓存资源。 注意：304虽然在3XX 重定向类别中，但跟重定向实际上没有太大的关系。 307 Temporary Redirect临时重定向。该状态码与302基本相同，不同的是307会遵照浏览器标准，不会从POST变成GET。 而301、302响应状态码返回时，浏览器一般都会把POST改成GET（尽管301和302标准是禁止这样做的）并删除请求报文的主体，再发起请求。 4XX 客户端错误400 Bad Request该状态码表示请求报文中存在语法错误，需要客户端修改请求内容后再次发送请求。 注意：浏览器会像对待200 OK 一样对待该状态码（即不会像3XX那样子有别的行为） 401 Unauthorized该状态码表示发送的请求需要有通过HTTP认证的认证信息。 第一次返回401时，浏览器会弹出认证用的对话框。 第二次返回401时，即表示用户认证失败。 403 Forbidden该状态码表示对该资源的请求被服务器拒绝了。服务器没有义务给出拒绝的详细理由，但如果想作说明的话可以在实体的主体部分对原因进行描述。 404 Not Found该状态码表示服务器无法找到请求的资源，是最常见的状态码。 5XX 服务器端错误500 Internal Server Error该状态码表示服务器端在处理请求时发生了错误，例如无法连接数据库，或者服务端语言中有语法错误等等。 503 Service Unavailable该状态码表示服务器端暂时处理超负载或正在进行停机维护，现在无法处理请求。 如果事先知道服务器将在何时恢复，则最好写入Retry-After首部字段再返回给客户端。 小结注意：状态码只在服务器端正确按照规范处理请求的前提下才有意义，不少服务器端会出现状态码与状态不一致的问题，需要在实际开发中注意。 本文提及的常见的状态码 200 OK 202 No Content 204 Partical Content 301 Permanently Redirect 302 Found 303 See Other 304 Not Modified 307 Temporary Redirect 400 Bad Request 401 Unauthorized 403 Forbbiden 404 Not Found 500 Interval Server Error 503 Service Unavailable 总结：本文整理了14种常见的状态码，其中包含4个状态类别，2XX，3XX，4XX，5XX，分别代表了成功，重定向，客户端错误和服务器端错误。 2XX中，要注意202与200的区别，前者不含资源实体的主体。 3XX中，要注意304与重定向无关304实际上是把资源重定向了本地的缓存，301和302一个是永久重定向，一个是临时重定向，且在标准中是不能把POST请求改成GET请求的（但是实际浏览器都会这么做）。303是302的相反版本，303要求POST改成GET请求。307是302的严格版，不允许把POST改成GET请求。 4XX中，400和401都是与浏览器有关的，前者是请求有错误后者是没有HTTP认证信息；403和404与服务器端有关，403禁止浏览器访问特定资源，404则是服务器上没有特定的资源。 5XX中，500是服务器端处理请求时出错，一般是数据库连接、代码有语法问题等等。503则是服务器负载过大或在维护，暂时无法提供服务。]]></content>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP基础（1）：概述]]></title>
    <url>%2F2017%2F04%2F11%2FHTTP%EF%BC%9A%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[HTTP协议HTTP，HyperText Transfer Protocol，超文本传输协议（超文本转移协议）。 HTTP协议用于客户端和服务器端之间的通信。访问文本或图像等资源的一端称为服务端（即浏览器），提供资源相应的一端称为服务端（即Web服务器）。 客户端向服务器端发起一个HTTP请求，服务器端在收到HTTP请求后根据请求报文中的内容进行响应，随后返回一个HTTP响应报文。客户端得到响应后便获取到了想要获取的资源或者相关错误信息（如资源不存在）。 HTTP通过请求和响应的交换达成通信HTTP协议规定，请求从客户端发出，最后服务器端响应该请求并返回。 HTTP请求客户端发送请求： GET /index.html HTTP/1.1 Host: www.example.com GET表示访问服务器的类型，称为方法（method）。随后的字符串/index.html指明了请求访问的资源对象，叫做请求URI（request-URI）。然后是HTTP/1.1，即HTTP的版本号。 综上，这段请求的意思：通过GET方法，访问www.example.com这台主机上的/index.html页面资源。 请求报文由以下几部分组成： 请求方法 请求URI HTTP版本协议 可选的请求首部字段 可选的内容实体 以下是一个用POST方法发起的HTTP请求： POST /user/login HTTP/1.1 Host: www.example.com Connect: keep-alive Content-Type: application/x-www-form-urlencode Content-Length: 16 user=dxy&amp;pwd=123 第一部分分别是请求方法（POST)，请求URI（/user/login），版本协议（HTTP/1.1）。接下来是请求首部字段（Host：…）。最后是内容实体（user=dxy&amp;pwd=123）。 这段请求的意思是：用POST方法，向www.example.com/user/login提交一个表单数据，表单数据为user=dxy&amp;pwd=123。 HTTP响应服务器端发送响应： HTTP/1.1 200 OK Date: Mon, 10 Apr 2017 14:17:00 GMT Content-Length: 3987 Content-Type: text/html &lt;html&gt; ... 第一部分分别是版本协议（HTTP/1.1），响应状态码（200，status code）和原因短语（reason-phrase）。接下来是创建响应的日期时间，和其他首部字段的内容。最后是一行隔开，为资源实体的主体（entity body）。 响应报文由以下几部分组成： HTTP版本协议 状态码和原因短语 创建响应的日期和可选的首部字段 资源实体的主体 HTTP是不保存状态的协议HTTP是一种无状态的协议（stateless）,这意味着HTTP协议不会保存请求和响应时的通信状态，即对请求和响应都不会做持久化处理。 这就会导致用户在访问一个网站时，其访问的状态无法得到保存，因为每次发起的HTTP请求都是“新”的请求，与之前是否发送过无关。 为了解决这个问题，可以通过Cookie技术来实现用户状态的保存。 请求URI定位资源HTTP协议使用URI（统一资源标识符）来定位互联网上的资源。当客户端请求访问某个资源时，需要指定该资源的URI作为HTTP请求中的请求URI。指定的方式由以下两种：第一种是在Host首部字段中写明访问的主机地址（域名或IP） GET /index.html HTTP/1.1 Host: www.example.com 第二种是完整的URI地址： GET http://www.example.com/index.html HTTP/1.1 如果不是访问特定资源而是对服务器发起请求，可以用*来代替URI。下面这个例子是查询HTTP服务器端支持的HTTP方法种类。 OPTIONS * HTTP/1.1 基本的HTTP请求方法GET：获取资源GET方法用来请求访问已被URI识别的资源。指定的资源经过服务器端解析后返回响应的内容。请求： GET /index.html HTTP/1.1 Host: www.example.com If-Modified-Since: Mon, 10 Apr 2017 14:17:00 GMT 响应：返回2017年4月10日14点17分00秒后更新过的index.html内容，若没有更新过，则返回304 Not Modified。 POST：传输实体主体尽管GET也可以传输实体主体，但是一般来说GET用于获取资源，而POST则专门用于传输资源或更新数据。 请求： POST /submit HTTP/1.1 Host: www.example.com ConTent-Length: 16 user=dxy&amp;pwd=123 响应：返回submit响应后的处理结果 PUT：传输文件PUT方法用来传输文件，要求请求报文的主体中包含文件内容，然后保存到URI指定的位置。 但是由于HTTP/1.1的PUT方法没有验证机制，任何人都可以上传文件，所以存在安全性问题。现在一般只用来配合RESTFul API。 DELETE：删除文件DELETE方法与PUT方法正好相反，用于删除指定URI上的文件。现在一般也只用在RESTFul API上。 HEAD：获取报文首部HEAD方法用来获取报文的首部，确认URI的有效性和资源的更新日期。HEAD方法基本和GET方法一样，只是GET方法获取资源内容，而HEAD方法不获取资源内容，仅获取响应报文的首部。 OPTIONS：询问支持的方法OPTIONS方法用来查询针对请求URI指定的资源支持的方法。 请求： OPTIONS * HTTP/1.1 Host: www.example.com 响应： HTTP/1.1 200 OK Allow：Get,Post,Head,Options TRACE：追踪路径TRACE方法是让Web服务器端将之前的请求通信环回给客户端的方法。客户端通过TRACE方法可以查询发送出去的请求是怎样被加工修改的。 由于TRACE方法容易引发XST（Cross-Site Tracing 跨站追踪）攻击，且本身就不常用，这里不作展开。 CONNECT：要求用隧道协议连接代理CONNECT方法要求在与代理服务器通信时建立隧道，实现使用隧道协议进行TCP通信。主要使用SSL（Secure Sockets Layer，安全套接字）和TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。 建立持久连接以节省通信量在HTTP协议的初始版本中，每次发送HTTP协议都会经历一次TCP连接和关闭。随着Web的发展，一个网页会包含多个HTTP请求去加载JS文件、CSS文件、图片文件等等。如果每次HTTP请求都要断开TCP连接的话，就会带来额外的通信量。为此，HTTP/1.1新增了持久化连接（HTTP keep-alive）的方案。 持久连接的特点是：只要任意一方没有明确需要断开TCP连接，那么客户端和服务器端将一直保持TCP连接，旨在一次TCP连接中进行多次HTTP请求和响应。 HTTP/1.1中，所有的连接默认都是持久连接。当然这需要客户端和服务器端同时支持。 持久连接使得多数请求能够以管线化的方式发送，可以让客户端并行发送多个HTTP请求，大大降低Web页面的显示速度。如果没有持久化连接，那么每次发起HTTP请求，下一个HTTP请求都得等待上一个HTTP请求得到响应后才能发送。 使用Cookie进行状态管理一方面，无状态协议能够节省服务器计算资源的开销，另一方面由于无状态的存在使得状态管理成为一个难题。 为了保留无状态协议同时实现状态管理，引入了Cookie技术，通过在请求和响应的报文中写入Cookie信息来控制客户端的状态。 第一次请求（没有Cookie信息）： GET /reader HTTP/1.1 Host: www.example.com 响应（服务器生成Cookie信息）： HTTP/1.1 200 OK Date: Mon, 10 Apr 2017 14:17:00 GMT Server: Apache Set-Cookie: sid=1342077140226724; path=/; expires=Wed, 10-OCT-12 07:12:20 GMT Content-Type: text/plain; charset=UTF-8 之后再发起请求时，会自带Cookie信息： GET /other HTTP/1.1 Host: www.example.com Cookie: sid=1342077140226724 可见服务器通过Set-Cookie来通知客户端保存Cookie信息，客户端随后针对这个站点的HTTP请求都会在请求头部中加入Cookie字段。如此一来，服务器端在接收到请求时就能根据客户端传来的Cookie中的sid信息，来辨别客户端了，客户端的状态就能够得到保持。 小结HTTP协议是通过请求和响应来进行通信的无状态协议。 其中要注意HTTP请求的基本格式，其组成（请求方法，请求URI，版本协议，可选的首部字段，可选的传输实体）。HTTP响应的基本格式，以及其组成（版本协议，状态码，原因短语，可选的首部字段，资源实体的主体）。 要熟悉常见的请求方法（GET、POST、PUT、DELETE、OPTIONS、TRACE、CONNECT）。能写出基本的请求报文。 能说出持久化连接的实现方法及其优点，以及如何通过Cookie解决客户端状态保持的问题。]]></content>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript：基本数据类型整理]]></title>
    <url>%2F2017%2F04%2F11%2FJavaScript%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[Undefined Null Boolean String Number UndefinedUndefined类型只有一个undefined值。 用var声明但未赋值的变量，其值为undefined。 var a; alert(a); //undefined 使用一个未经声明的变量，typeof检测为undefined，但使用时会报错。 alert(a); //Error 访问一个对象中不存在的属性时，其值为undefined，不会报错。 var o = {a:1}; alert(o.b); //undefined 故undefined不能与typeof结合使用来判断一个变量是否被声明。 var a; alert(typeof a); //undefined alert(typeof b); //undefined ，变量b并没有被声明 NullNull表示一个空对象指针，typeof null会返回object。 var o = null; alert(typeof o); //object null可以作为空对象的占位符，故如果定义的变量将来用于存放对象，那么最好将该变量初始化为null，这样通过typeof可以判断相应的变量是否保存了一个对象的引用。 var o = null; //... if(o == null){ //do something } undefined是派生自null的，故下面相等性测试返回的是true alert(undefined == null); //true 注意：undefined与null很大的一个区别在于，无论什么情况下，undefined一般都不会被用作显式地初始化变量，而null则推荐用来作为空对象指针。 BooleanECMAScript中，所有类型的值都有与Boolean类型对应的值，我们可以通过转型函数Boolean()来进行转换。 String类型，非空字符串均返回true，空字符串返回false Number类型，非零数字值均返回true，0和NaN返回false Object类型，任何非空对象均返回true，null返回false Undefined类型，恒为false 这个转换在流控制语句中如if语句中，会将if()中的变量自动转换成对应的Boolean值，以下代码是相等的： var foo = &quot;bar&quot;; if(foo){ //do something } //上下两段代码是相同的 if(Boolean(foo)){ //do something } NumberNumber类型使用IEEE754格式来表示整数和浮点数，浮点数值的最高精度是17位小数，故在计算时会产生舍入误差的问题。所以永远不要测试某个特定的浮点数值。 var a = 0.1; var b = 0.2; alert(a+b == 0.3) //false，0.1+0.2会变成0.30000000000000004 数值范围 正无穷：+Infinity 能够表示的最大正数：Number.MAX_VALUE 能够表示的最小正数：Number.MIN_VALUE 0 能够表示的最大负数：-Number.MIN_VALUE 能够表示的最小负数：-Number.MAX_VALUE 负无穷：-Infinity NaNNaN，Not a Number，用于表示一个本来要返回数值的操作数未返回数值的情况，此时不抛出错误，也不会影响其他代码的执行。 除了类型转换时会出现NaN之外，0/0也会返回NaN。 特点： NaN与任何数值操作均为NaN NaN与任何值都不相等，包括NaN自身 可以用isNaN()函数来判断一个值是否“不是数值”，isNaN()在接收到一个参数后，会尝试将这个值转换为数值。 isNaN(NaN); //true isNaN(10); //false isNaN(&quot;10&quot;); //false，字符串&quot;10&quot;可以转换成数字10 isNaN(&quot;blue&quot;); //true，字符串&quot;blue&quot;不能被转换成数字 isNaN(true); //false，布尔值true可以被转换成数字1 isNaN(false); //false，布尔值false可以被转换成数字0 数值转换 Number()，转型函数 parseInt()，全局函数 parseFloat()，全局函数 Number() Boolean，true 1，false 0 Null，null 0 Undefined，undefined NaN String，字符串只包含数字时（包括+/-，整数/浮点数） 对应数字，空字符串”” 0 Object，先valueOf()若NaN则toString()，转换规则跟上述一致 parseInt()parseInt接收两个参数，第一个是待转换的值，第二个是基数（二进制、八进制、十进制、十六进制），其他进制不常用，以下仅讨论十进制。 与Number()的几个区别是， Number()接收任意类型的参数，而parseInt()只接收String，非String一律为NaN。 parseInt()会对传入的字符串从左到右进行遍历，从第一个数字或正负号开始，到第一个非数字结束，字符串中不存在数字就一定会是NaN，忽略其他非数字的字符；Number()中如果字符串存在非数字字符就会是NaN。 空字符串Number()转换成0，parseInt()转换成NaN。 parseInt()只会转换成整数 示例： var n0 = true; alert(Number(n0)); //1 alert(parseInt(n0,10)); //NaN var n1 = &quot;1234blue&quot;; alert(Number(n1)); //NaN alert(parseInt(n1,10)); //1234 var n2 = &quot;&quot;; alert(Number(n2)); //0 alert(parseInt(n2,10)); //NaN var n3 = &quot;22.5&quot;; alert(Number(n3)); //22.5 alert(parseInt(n3,10)); //22 parseFloat()parseFloat()与parseInt()的解析机制基本相同，以下为两个比较主要的区别： parseFloat()没有第二个参数，只解析十进制 parseFloat()识别小数点，遇到第二个小数点停止解析 StringString类型用于表示由零或多个16位Unicode字符组成的字符序列，即字符串。 用双引号表示的字符串与用单引号表示的字符串完全相同。 字符字面量即转义序列，用于表示非打印字符或其他用途的字符。常见的有： \n 换行 \t 制表 \r 回车 \b 退格 \xnn 以十六进制代码nn表示一个字符（n为0~F） \unnnn 以十六进制代码nnnn表示的一个Unicode字符（其中n为0~f) 注意：\unnnn类型的字符虽然在代码中占6个字符，但是在length属性中只占1个字符。 但是如果字符串中包含双字节字符，那么length属性可能不会精确地返回字符串中的字符数目。 字符串的特点字符串是不可变的，一旦创建，它们的值就不能改变。要改变的话，则会先销毁原来的字符串，再用一个包含新值的字符串填充该变量。 var lang = &quot;Java&quot;; lang = lang + &quot;Script&quot;; 首先创建一个10字符的新字符串 接着填充”Java”和”Script” 将新字符串赋值给lang 删除”Java”和”Script” 转换为字符串转换为字符串有两种方法，分别是toString()和String()。 还有一种是用加号操作符，这里先不作讨论。 toString()几乎每个值都有toString()方法，返回响应值的字符串表现。 Number，即数字本身，还可以传递一个参数以指定基数 Boolean，即”true”或”false” String，即字符串本身 示例： var num = 10; alert(num.toString()); //10，默认十进制 alert(num.toString(2)); //1010，二进制 alert(num.toString(16)); //a,十六进制 Null和Undefined没有toString方法。 String()就像Number()和parseInt()的关系一样，String()转型函数能够接收任意类型的值作为参数，但是区别在于Number()和parseInt()之间相对平等，而String()更像是toString()的超集。 如果传入的值有toString()方法，则调用该方法 Null类型，返回”null” Undefined类型，返回”undefined” 不过String()在转换数值时就不能指定基数了。 小结JavaScript基本数据类型有5种，分别是Null，Undefined，Boolean，Number和String。其中，Undefined派生自Null，故null==undefined返回true。 Boolean只有true和false两个值，注意Boolean()转型函数的转换规则，以及与if()等流程控制语句的关系。 Number类型不区分整数和浮点数，要注意其数值范围以及精度的问题，要当心0.1+0.2不等于0.3的判断问题。还有对NaN的理解，注意NaN与任何值都不相等的特性。此外，Number()转型函数，parseInt()和parseFloat()各有机制上的共通点和不同处，要做好区别。 String类型，包含字符字面量，转义字符，字符串的特点以及字符串的转换，重点理解如何使用toString()和String()来进行字符串转换。]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac：如何在Terminal中打开Finder]]></title>
    <url>%2F2017%2F04%2F07%2FMac%E5%9C%A8Terminal%E6%89%93%E5%BC%80Finder%2F</url>
    <content type="text"><![CDATA[前言对于习惯使用Terminal的小伙伴们来说，常常有“进入到某个目录中”并“在该目录中打开Finder”的需求。明明已经在目录下了，却还需要在桌面按个CMD+N来打开Finder再在Finder中一层一层打开，简直不要太痛苦。既然如此，那就试试open命令吧。 open命令在Terminal中输入open -h，可以看到如下的说明： Usage: open [-e] [-t] [-f] [-W] [-R] [-n] [-g] [-h] [-b &lt;bundle identifier&gt;] [-a &lt;application&gt;] [filenames] [--args arguments] Help: Open opens files from a shell. By default, opens each file using the default application for that file. If the file is in the form of a URL, the file will be opened as a URL. Options: -a Opens with the specified application. -b Opens with the specified application bundle identifier. -e Opens with TextEdit. -t Opens with default text editor. -f Reads input from standard input and opens with TextEdit. -F --fresh Launches the app fresh, that is, without restoring windows. Saved persistent state is lost, excluding Untitled documents. -R, --reveal Selects in the Finder instead of opening. -W, --wait-apps Blocks until the used applications are closed (even if they were already running). --args All remaining arguments are passed in argv to the application&apos;s main() function instead of opened. -n, --new Open a new instance of the application even if one is already running. -j, --hide Launches the app hidden. -g, --background Does not bring the application to the foreground. -h, --header Searches header file locations for headers matching the given filenames, and opens them. 部分翻译如下： 使用方法： open [-e] [-t] [-f] [-W] [-R] [-n] [-g] [-h] [-b &lt;bundle identifier&gt;] [-a &lt;应用名&gt;] [文件名] [--args arguments] Help: 用于在命令行中打开文件 默认情况下，使用默认的应用打开对应的文件。 如果是URL格式的文件，那么就会在浏览器中打开。 Options: -a 指定打开文件的应用 -e 用TextEdit打开该文件 -t 用默认文本编辑器打开该文件 -R, --reveal 在Finder中显示并选中 -g, --background 在后台打开该文件（此时焦点还在Terminal上） 打开目录的正确方式那么如何解决“在Terminal中打开当前目录”的问题呢？只要输入以下命令即可： $ open ./ 没错就这么简单。默认情况下，如果是个open之后是一个目录，那么就会用Finder打开。回车之后，会将焦点直接转移至打开的Finder目录。这时如果你是想打开多个Finder目录，就需要手动切回Terminal再执行命令了。这种情况下，你可以加一个-g参数，来让焦点始终保持在Terminal上。 $ open -g ./ 这样我们就可以一次性在命令行中打开所有想打开的目录了。 浏览文件除此之外，文件太多了，想在Finder中浏览指定文件怎么办呢。可以用-R来解决： $ open -R ./test.js 这样就可以在Finder显示，并且已经被选中了。 打开网站的正确方式除了打开目录之外，open命令也可以用于打开网站： $ open http://denight.leanote.com 记得一定要加http，否则是不会被识别成URL的。 指定浏览器打开默认情况下，是用Safari打开浏览器的： $ open http://denight.leanote.com 等同于 $ open -a Safari http://denight.leanote.com 如果要换成Firefox或者是Google Chrome，替换命令中的Safari即可 $ open -a Firefox http://denight.leanote.com $ open -a Google\ Chrome http://denight.leanote.com 打开代码的正确方式$open -e ./test.js 使用这个命令，可以在TextEdit中打开test.js文件。如果不加-e的话，就会用默认的应用打开。也可以指定想要的打开的编辑器。 $open -a Sublime\ Text ./test.js 参考在Mac终端下打开Finder]]></content>
      <tags>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS：line-height 不同取值的差异]]></title>
    <url>%2F2017%2F04%2F02%2Fline-height%20%E4%B8%8D%E5%90%8C%E5%8F%96%E5%80%BC%E7%9A%84%E5%B7%AE%E5%BC%82%2F</url>
    <content type="text"><![CDATA[百分比值 line-height = （父元素 font-size）×（百分比） 1234&lt;div class=&quot;outer&quot;&gt; 父元素 &lt;div class=&quot;inner&quot;&gt;子元素&lt;/div&gt;&lt;/div&gt; 123456789.outer &#123; /* 父元素行高 = 父元素font-size 30px × 150% = 45px */ line-height: 150%; font-size: 30px;&#125;.inner &#123; /* 子元素行高 = 父元素font-size 30px × 150% = 45px */ font-size: 20px; &#125; em值 line-height = （父元素 font-size）×（em值） 123456789.outer &#123; /* 父元素行高 = 父元素font-size 30px × 1.5 = 45px */ line-height: 1.5em; font-size: 30px;&#125;.inner &#123; /* 子元素行高 = 父元素font-size 30px × 1.5 = 45px */ font-size: 20px;&#125; 这里特别要注意尽管em是相对当前元素的font-size值来计算的，同时line-height也是可以被继承的属性，但是实际上子元素继承时并不是line-height: 1.5em，而是父元素计算完成后的line-height: 45px; 无单位数字 line-height = （当前元素 font-size）×（无单位数字） 123456789.outer &#123; /* 父元素行高 = 父元素font-size 30px × 1.5 = 45px */ line-height: 1.5; font-size: 30px;&#125;.inner &#123; /* 子元素行高 = 子元素font-size 20px × 1.5 = 30px */ font-size: 20px;&#125; 无单位数字与百分比值和em值相反，是根据当前元素的font-size来计算的。 小结其实仔细观察会发现，百分比值和em值，在子元素继承父元素的line-height属性时，继承的是计算完成后（以px为单位）的值。而无单位数字，则是需要根据子元素的font-size，让子元素自行计算的。 计算em值的大致流程： –&gt; 设置父元素font-size = 30px； –&gt; 设置父元素line-height = 1.5em; –&gt; 计算父元素line-height = font-size × 1.5 = 30px × 1.5 = 45px; –&gt; 设置子元素font-size = 20px; –&gt; 计算子元素line-height = 继承父元素line-height = 45px; 计算无单位数字的大致流程：–&gt; 设置父元素font-size = 30px; –&gt; 设置父元素line-height = 1.5; –&gt; 计算父元素line-height = 当前元素font-size × 1.5 = 30px × 1.5 = 45px; –&gt; 设置子元素font-size = 20px; –&gt; 计算子元素line-height = 继承父元素line-height = 1.5; –&gt; 计算实际子元素line-height = 当前元素font-size × 1.5 = 20px × 1.5 = 30px;]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sublime Text 3的基本安装与配置]]></title>
    <url>%2F2017%2F04%2F02%2FSublime-Text-3%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[下载官网下载 Package Control安装简易方法最简单的安装方法，是通过Sublime Text控制台来安装。你可以通过Ctrl + ` 快捷键或者通过菜单栏 View &gt; Show Console 来打开控制台。接着，输入下面这段代码按下回车即可。（最新的版本请参照官网） import urllib.request,os,hashlib; h = &apos;df21e130d211cfc94d9b0905775a7c0f&apos; + &apos;1e3d39e33b79698005270310898eea76&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by) 这段代码在必要的情况下会为你创建一个Installed Packages 文件夹，然后下载Package Control.sublime-package到这个文件夹中。这个下载由于Python标准库的限制，会通过HTTP而不是HTTPS来完成。文件会通过SHA-256来验证。 手动下载如果由于一些原因，你无法在控制台中完成下载，那么你可以通过以下几个步骤来手动安装Package Control： 点击菜单中的Preferences &gt; Browse Packages… 在打开的文件夹中创建一个Installed Packages文件夹 下载这个文件Package Control.sublime-package并放到新建的Installed Packages文件夹中 重启Sublime Text 安装插件完成Package Control的安装后，在Sublime中按住Shift + CMD + P。在输入框中输入Package Control:Install Package，这时Sublime会获取服务器上所有的Package信息，稍等一下后就可以选择自己需要的插件进行安装了。你可以在Package Control - Browse中查看所有插件的信息。Package Control也可以用于下载一些Sublime的主题，只要在Package安装选择界面中以Theme开头即可。 插件的配置和主题的选择都可以在Preferences菜单中进行。 进阶在Terminal中打开SublimeSublime Text 包含了一个命令行工具，subl，能让你在命令行中打开文件。这个工具可以用来在Sublime中打开对应的文件和项目文件夹。 设置在Terminal中输入以下这段代码： ln -s &quot;/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl&quot; /usr/local/bin/subl 接下来你就可以在命令行中用subl fileName的方式来打开文件了。 更多用法可以输入subl --help查看。 在Sublime Text中运行JavaScript点击菜单中的Tools &gt; Build System &gt; New Build System，复制以下代码： { &quot;cmd&quot;: [&quot;/usr/local/bin/node&quot;,&quot;$file&quot;], &quot;selector&quot;: &quot;source.js&quot; } 命名为JavaScript.sublime-build保存至Package或Package/User文件夹。 参考Package Control - Installation Sublime Text 3 - OS X Command Line Build Systems]]></content>
      <tags>
        <tag>sublime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS：如何去除 inline-block 带来的空白间距]]></title>
    <url>%2F2017%2F04%2F01%2F%E5%A6%82%E4%BD%95%E5%8E%BB%E9%99%A4%20inline-block%20%E5%B8%A6%E6%9D%A5%E7%9A%84%E7%A9%BA%E7%99%BD%E9%97%B4%E8%B7%9D%2F</url>
    <content type="text"><![CDATA[1、使用负margin12345&lt;ul&gt; &lt;li&gt;item&lt;/li&gt; &lt;li&gt;item&lt;/li&gt; &lt;li&gt;item&lt;/li&gt;&lt;/ul&gt; 1234567ul &#123; list-style:none;&#125;li &#123; display: inline-block; margin-left: -4px;&#125; 2、改变HTML结构，把li标签写在同一行123&lt;ul&gt; &lt;li&gt;item&lt;/li&gt;&lt;li&gt;item&lt;/li&gt;&lt;li&gt;item&lt;/li&gt;&lt;/ul&gt; 3、父元素中设置字体大小为012345&lt;ul&gt; &lt;li&gt;item&lt;/li&gt; &lt;li&gt;item&lt;/li&gt; &lt;li&gt;item&lt;/li&gt;&lt;/ul&gt; 12345678ul &#123; list-style: none; font-size: 0;&#125;li &#123; display: inline-block; font-size: 16px;&#125;]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS：那些居中的方法们]]></title>
    <url>%2F2017%2F04%2F01%2FCSS%EF%BC%9A%E9%82%A3%E4%BA%9B%E5%B1%85%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E4%BB%AC%2F</url>
    <content type="text"><![CDATA[水平居中1、宽度已知，使用margin123&lt;div&gt; &lt;div class=&quot;center&quot;&gt;需要居中的元素&lt;/div&gt;&lt;/div&gt; 1234.center &#123; width: 100px; margin: 0 auto;&#125; 2、宽度不定，使用text-align + inline-block123&lt;div class=&quot;wrapper&quot;&gt; &lt;div class=&quot;center&quot;&gt;需要居中的元素&lt;/divß&gt;&lt;/div&gt; 123456.wrapper &#123; text-align: center;&#125;.center &#123; display:inline-block;&#125; 3、宽度不定，使用弹性盒子123&lt;div class=&quot;wrapper&quot;&gt; &lt;div&gt;需要居中的元素&lt;/div&gt;&lt;/div&gt; 1234.wrapper &#123; display: flex; justify-content: center;&#125; 4、宽度已知，使用绝对定位123&lt;div class=&quot;wrapper&quot;&gt; &lt;div class=&quot;center&quot;&gt;需要居中的元素&lt;/div&gt;&lt;/div&gt; 123456789.wrapper &#123; position: relative;&#125;.center &#123; postion: absolute; width: 100px; left:50%; margin-left:-50px;&#125; 完全居中1、完全居中123&lt;div class=&quot;wrapper&quot;&gt; &lt;div class=&quot;center&quot;&gt;需要居中的元素&lt;/div&gt;&lt;/div&gt; 1234567891011121314.wrapper &#123; height:200px; position: relative;&#125;.center &#123; height: 50%; width: 50%; margin: auto; position: absolute; top: 0; bottom: 0; left: 0; right: 0；&#125; 2、使用负margin123&lt;div class=&quot;wrapper&quot;&gt; &lt;div class=&quot;center&quot;&gt;需要居中的元素&lt;/div&gt;&lt;/div&gt; 1234567891011121314.warpper &#123; height: 200px; position: relative;&#125;.center &#123; width: 100px; height: 100px; margin: auto; position: absolute; top: 50%; left: 50%; margin-top: -50px; margin-left: -50px;&#125; 优点：兼容IE6-7； 缺点：不能使用百分比的大小，内容高度不可变；内容可能会超出容器； 3、使用transform123&lt;div class=&quot;wrapper&quot;&gt; &lt;div class=&quot;center&quot;&gt;需要居中的元素&lt;/div&gt;&lt;/div&gt; 123456789101112.wrapper &#123; height: 200px; postion: relative;&#125;.center &#123; height: 50%; width: 50%; position: absolute; top: 50%; left: 50%; transform:translate(-50%,-50%);&#125; 优点：内容高度可变； 缺点：不兼容IE8；会和其他transform样式有冲突； 4、使用table-cell12345&lt;div class=&quot;table&quot;&gt; &lt;div class=&quot;table-cell&quot;&gt; &lt;div class=&quot;center&quot;&gt;需要居中的元素&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 12345678910111213.table &#123; display: table; width: 100%;&#125;.table-cell &#123; display: table-cell; vertical-align: middle; height: 200px;&#125;.center &#123; width: 50%; margin: 0 auto;&#125; 优点：内容高度可变；能自动撑开父元素；浏览器兼容性好； 缺点：需要额外的HTML标签； 5、使用flex-box123&lt;div class=&quot;wrapper&quot;&gt; &lt;div&gt;需要居中的元素&lt;/div&gt;&lt;/div&gt; 123456.wrapper &#123; display: flex; align-items: center; justify-content: center; height: 200px;&#125; 优点：内容高度可变； 缺点：不支持IE8-9；]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git：那些常用命令的整理]]></title>
    <url>%2F2017%2F01%2F30%2FGit%EF%BC%9A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[Git是一个分布式版本控制系统，相比集中式的版本控制系统，分布式版本控制系统每个人手上都是一个完整的版本库。 创建版本库git init 初始化一个git仓库。 git add &lt;file&gt; 添加文件到暂存区。 git commit -m &quot;message&quot; 把之前git add的文件提交到仓库，可以add多个文件，然后执行一次commit。 SVN上add之后直接就添加到版本库了，但是Git上还需要commit才行，注意SVN与Git之间commit与add的异同。 查看版本库的状态git status 查看当前工作区的状态。 git diff 查看difference，显示的格式是Unix通用的diff格式。 简单来说git status命令可以知道哪些文件做了修改，git diff命令可以知道被修改了哪些内容。 git log git log --pretty=oneline 显示从最近到最远的提交日志。 commit id是版本号，用 SHA1 十六进制表示 版本回退git reset --hard HEAD^ git reset --hard HEAD~100 git reset --hard 3628164 HEAD表示当前版本，HEAD^表示当前版本的上一个版本，~100等同于100个^。3628164是版本号，版本号不用写全，Git中只要知道commit id就可以回退。 git reflog 查看历史命令，通过历史命令可以知道版本号。 需要提交的文件通通使用git add放到暂存区（stage），然后使用git commit一次性提交暂存区所有修改到分之。工作区（working diretory）是电脑里能看到的目录，版本库（repository）则是工作区中一个隐藏的文件夹.git。git跟踪并管理的是修改，每次修改都需要add到暂存区，这样才能被commit到分支中。 管理修改git checkout --file 把file在工作区的修改全部撤销，也就是把这个文件回到最近一次git commit或者git add的状态（用版本库的版本替换工作区）。 git reset HEAD file 把暂存区的修改回退到工作区，不会影响工作区的状态。 git rm file 从版本库中删除某个文件。这个命令跟git add一样，需要git commit之后才能提交到版本库中。 分支管理创建分支git checkout -b dev 创建并切换到dev分支，-b参数表示创建并切换，这个命令实际上是下面两个命令的结合。 git branch dev git checkout dev git branch是创建一个dev分支，git checkout则是切换到dev分支。 git branch 查看当前分支，当前分支会标有一个*号。 git checkout master 切换到master分支。 git merge dev 合并指定分支到当前分支。 git branch -d dev 删除指定分支。 解决冲突当切换到master分支并尝试合并dev分支时，若有冲突存在，必须手动解决冲突再进行提交。 Git用&lt;&lt;&lt;&lt;&lt;&lt;，======，&gt;&gt;&gt;&gt;&gt;&gt;标记处不同分支的内容。 git log --graph --pretty=oneline --abbrev-commit 用带参数的git log命令可以看到分支的合并情况。 当Git无法自动合并分支时，必须首先解决冲突，再提交。合并后用git log --graph可以看到分支合并图。 分支管理策略默认情况下，Git会用Fast forward模式合并分支，但这种情况下，删除分支会丢掉分支信息，会看不出来曾经做过合并 git merge --no-ff -m &quot;message&quot; dev 本次合并会创建一个新的commit，通过-m把commit描述写进去，--no-ff表示禁用Fast forward。 master一般是最稳定的版本，用来发布新版本。建立以个dev分支来进行协作，每个人都在dev分支上写代码，时不时向dev分支上提交，dev提交到master上来发布稳定版本。 Bug分支git stash 可以把当前工作区存起来，等以后恢复现场继续工作。执行完后，工作区是clean的，可以拿来创建分支。 git checkout master git checkout -b issue-101 创建issue-101分支并修复Bug。 git stash list 查看保存的工作区。 git stash apply 恢复指定工作区。 git stash drop 删除stash。 git stash pop 恢复的同时会删除stash的内容。 配置git config 命令用来设置git的一些基本设置，包括全局配置以及针对特定仓库的配置。 使用方法设置名字git config user.name &lt;name&gt; 设置当前仓库commit时作者的名字。 git config --global user.name &lt;name&gt; 设置全局的作者名字，这样以后其他仓库commit时，都会以这个名字提交。 设置邮箱git config --global user.email &lt;email&gt; 设置全局的作者邮箱。 例子： git config --global user.name &quot;denight&quot; git config --global user.email denight@qq.com 设置简写/别名git config --global alias.&lt;alias-name&gt; &lt;git-comman&gt; 设置git命令的简写。比如git status可以通过下面的命令简写为git st。 git config --global alias.st status 更多Git把配置文件存储在三个不同的文件中，一个作用于当前仓库，一个作用于当前用户，一个作用于整个系统。 /.git/config 当前仓库的配置 ~/.gitconfig 当前用户所属的配置，即—global的配置 $(prefix)/etc/gitconfig 系统级别的配置 优先级从高到底。]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出React读后笔记]]></title>
    <url>%2F2016%2F04%2F24%2F%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAReact%E8%AF%BB%E5%90%8E%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[React的设计哲学React最有价值的是声明式的，直观的编程方式。编程方式 简单直观 且 符合习惯，可以使得代码 更容易理解 、易于维护和有助于演进。可理解，可维护的代码代表着工程的质量和效率。 JSX定义用户界面更加直观JSX定义的用户界面使得HTML可以直接嵌入到JS中，而不使用模板。原因在于，模板背后的代码逻辑严重依赖其模板中的内容和DOM结构，两者紧密耦合。虽然模板可以使得文件分离，且让非开发人员也可以对界面进行修改，但是为了保证两者之间的协作，需要引入更多的概念和机制。 而在JSX中，React并没有引入更多新的概念，你仍可以用HTML和JS的思路去构建自己的应用。这种直观的方式降低了React的学习门槛，也使得新手更容易理解。 所谓组件，其实就是状态机器组件是某个独立功能或界面的封装（定义），使其能够进行复用或是业务逻辑分离（目的）。 在React中，为了更加容易保证界面一致性，React把它看做简单的状态机器。即根据状态去输出基于状态的界面，React则负责以最高效的方式去更新整个界面和DOM树。 对组件的管理，实际就是对组件状态的管理。更新一个组件，就是更新一个组件的状态。设计者需要做的，就是关心不同状态的用户界面。这相比于原始的JS直接控制真实DOM（过于自由）来说，预先设定好组件的状态对应的用户界面，可以让问题缩小到组件中，而不需要开发者考虑整一个应用的DOM或是担心新加入的代码可能会产生不被期望的副作用。像这样将DOM限制在组件之中，尽管失去了“自由”，但是也可以使得开发者更好的对界面进行管理和控制。 组件作为用户界面的基本单位，与外界的交互方式除了状态（state）之外，还有其属性（props）。state由组件内部进行维护，而属性则是在外部初始化时传递进来，一旦赋值不建议进行变化。同一类组件就像是人一样，可以有着不同的身高和肤色（属性），但是其呼吸、运动等活动方式（状态）则是相通的。 每一次变化都是整体刷新数据模型驱动用户界面在概念上是直观的，但是在实践中确实困难重重。数据模型的变化可能会导致分散在整个用户界面各个角落的UI同时进行变化。界面越复杂，数据与界面的一致性越难以维护。 关于这个问题，在原文中并没有被解释的很清楚。所谓数据模型，是一个整体的、全局的数据，不同于AJAX获取那种局部的数据，数据模型代表了整个UI界面的状态。 考虑一下实际的开发场景，当我们拿到一个新的数据之后，我们需要做哪些事情。首先是分析数据，在概念上明确我们需要更新的UI，接着拿新数据与UI进行对比（检查），判断哪些需要更新而哪些不需要变化。接下来是实际通过编码的方式更新UI，进行DOM操作，最后检查UI是否被正确的刷新。 实际上在界面复杂并且有许多UI之间的依赖更新的情况下，开发者无法立刻得知当前的UI与之后刷新的UI是否一致。出于减少DOM操作的角度考虑，当然是只刷新那些有变化的UI就好。但是想要实现它，开发者必须对UI一一进行前后对比，界面越复杂越难以实现。而如果把涉及到的所有UI都进行更新，则会产生不必要的性能损耗（把一个UI删除了又产生一个同样的UI）。为此，React引入了虚拟DOM的概念。既然整体进行渲染（把所有涉及到的UI都进行刷新）一定可以保证数据模型与用户界面的一致性，那不如就整体进行刷新吧，让框架来解决哪些需要进行DOM操作而哪些UI则保持原样。React通过虚拟DOM把所有的现有UI的数据模型与新的数据模型进行一一的对比，最终进行最优化的局部真实DOM更新。虚拟DOM可以通过其算法获得不论界面多么复杂的情况下，都可以接受的性能代价。何时是React的最有价值的时候？当你的界面越来越复杂时。 单向数据流动Flux既然已经有了组件机制去定义界面，那么也还需要一定的机制来定义组件之间，以及组件和数据模型之间如何通信。为此Facebook提出了Flux，其提倡的是单向数据流动。即永远只有模型到视图的数据流动。 Flux的定义非常宽松，目前社区中还出现了很多不同的实现，如Flexible，Reflux等。 让数据模型也变简单React提倡只用只读数据来建立数据模型，所有的数据都是只读的，如果你想要进行修改，那么就只能产生一份包含新的修改的数据。这有点像同一个类的实例，其成员变量是私有的并且在实例化之后没有相关函数能够对其进行修改，如果想要进行修改，那么就只能重新实例一个。 只读的数据可以让代码更加的安全和易于维护，至少开发者不用担心数据在某个角落被某段神奇的代码所修改。数据的来源只有数据出生的时候，这无疑可以抹杀很多bug出现的可能。 其他React Native：移动开发。React把UI层进行了完美的抽象使得开发者不需要进行DOM操作，而React Native正是把DOM替换成了iOS或Android的原声控件。其开发方式都是一致的。 React Canvas：所有的界面元素都通过Canvas来进行绘制，彻底舍弃了DOM。 总结任何框架诞生的初衷都离不开对开发问题的解决。React同样是为了解决前端开发中的痛点而生。原文总结分析了其相关技术背后的设计思想，是一篇质量很高的文章。 我一直坚信在计算机这样的人造学科中，理解一门技术的初衷，能够使自己更好的去学习和使用。很多人都可以在短时间入门一门技术，但是很少有人去关注其背后的设计思想和方式。尽管我现在技术基础不扎实，但是React的设计思路确确实实是我在实际开发中会遇到和疑惑的问题。这样一想，React就变得十分可爱了，我也期望自己能在实际的开发中，遵循简单直观的原则，进行高效率和高质量的开发。 参考深入浅出React（一）：React的设计哲学 - 简单之美]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SVN：同步版本库与网站目录]]></title>
    <url>%2F2016%2F03%2F04%2FSVN%EF%BC%9A%E5%90%8C%E6%AD%A5%E7%89%88%E6%9C%AC%E5%BA%93%E4%B8%8E%E7%BD%91%E7%AB%99%E7%9B%AE%E5%BD%95%2F</url>
    <content type="text"><![CDATA[承接之前Lnmp下搭建Svn服务器的步骤，接下来要使用Svn中的hooks来进行版本库与网站目录的同步更新。以方便对网站代码进行管理和发布。 注意，下文中PATH、PROJECT等全大写的字符串均为举例用，实际操作时请替换成自己的目录和版本库或项目名称。 原理首先切换到版本库的目录 cd /PATH/svn/PROJECT ls 会看到有hooks文件夹 cd hooks ls 可以看到有一个post-commit.tmpl，这个是svn官方的一个模板，在每次commit操作之后都会执行这个脚本，其他的hooks同理。 看到这里你应该可以想到，版本库与网站目录同步的原理，就是在客户端commit了代码之后，执行这个脚本来同时update网站目录的内容，保证两者的同步。 配置操作首先需要在网站目录checkout版本库先不要着急打接下来的命令 cd PATH/wwwroot/www.example.com svn checkout file://PATH/svn/PROJECT 因为执行了这个命令之后你也许会发现，在网站目录下多了一个PROJECT文件夹，这个文件夹里面才是版本库控制的内容。 然而我们的目的是想让当前网站的根目录与svn直接同步，因此我们在上一级目录进行checkout。 接下来正确的做法是 cd PATH/wwwroot svn checkout file://PATH/svn/PROJECT www.example.com 上述命令是在checkout版本库的同时对它进行了重命名，这样子，网站的根目录就如预想的一样在版本库的控制之下了。 接下来配置hookscd PATH/svn/PROJECT/hooks cp post-commit.tmpl post-commit 复制一份post-commit并去掉它的后缀名，这么做的原因是，.tmpl是一个模板文件，实际并不会执行，只有去掉后缀名之后它才会生效。 vi post-commit 在末尾加入 export LANG=zh_CN.UTF-8 svn update PATH/wwwroot/www.example.com --username USER1 --password PASSWD1 --no-auth-cache export的作用是防止乱码。 update则是对网站目录进行更新，让网站目录与版本库同步，这里USER1和PASSWD1是之前的教程里配置的用户名和密码，请根据实际情况进行替换。编辑完成之后，按ESC并输入:wq，保存并退出。 测试hooks添加可执行权限chmod +x post-commit 运行测试./post-commit 如果有报错，请重新vi一遍看看是不是有打错 切换用户进行测试由于ssh VPS之后大多数情况用的都是root用户，而svn commit之后执行hooks的是另外一个用户，所以在root权限下执行没有问题，在另外的用户下可能就没有那么足够的权限了。所以接下来 su www ./post-commit 如果执行成功，那么基本不会有问题。如果su www时出现not available的情况，尝试下面这个命令 usermod -s /bin/bash www 如果出现各种权限不足的情况，我建议上述所有步骤都在www用户下执行（除了部分更改文件执行权限操作等必须用root用户的）。 实际测试使用你的svn客户端checkout该版本库并上传一些文件或做一些改动，接着进行commit，查看网站目录是否与版本库同步。 总结Svn的hooks是非常好用的脚本，在每次commit之后，你也可以加入日志记录、通知提醒等等功能。当然，这些功能也是需要一定的shell能力才写的出来。]]></content>
      <tags>
        <tag>svn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SVN：LNMP下搭建SVN服务器简明步骤]]></title>
    <url>%2F2016%2F03%2F04%2FSVN%EF%BC%9ALNMP%E4%B8%8B%E6%90%AD%E5%BB%BASVN%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%80%E6%98%8E%E6%AD%A5%E9%AA%A4%2F</url>
    <content type="text"><![CDATA[下文中PATH、PROJECT等全大写的字符串均为举例用，实际操作时请替换成自己的目录和版本库或项目名称等。 安装yum install subversion 等待一段时间完成svn的安装。 ##建立版本库的文件夹，并给与777的权限 mkdir PATH/svn chmod 777 -R PATH/svn 创建版本库svnadmin create PATH/svn/PROJECT 接下来对Svn进行配置配置svnserve.confvi PATH/svn/PROJECT/conf/svnserve.conf 将内容中注释掉的以下部分去掉#和空格，并将anon-access = read改为none： # anon-access = read # auth-access = write # password-db = passwd # authz-db = authz 变成 anon-access = none auth-access = write password-db = passwd authz-db = authz 配置authzvi PATH/svn/PROJECT/conf/authz 在[group]下加入 YOUR_GROUP = USER1,USER2 在# [/foo/bar]下加入 [/] @YOUR_GROUP=rw * = r 配置passwdvi PATH/svn/PROJECT/conf/passwd 在[users]下加入 USER1=PASSWD1 USER2=PASSWD2 启动SVN服务svnserve -d -r PATH/svn/ 这里需要注意，这里设置的是svn服务器的根目录。在checkout的时候，以这个目录（PATH/svn/)作为起点，可以添加多个版本库，访问的时候则可以用“svn://域名/版本库名”来进行checkout。 如何关闭服务 直接杀死相关进程即可 killall svnserve 客户端访问方式svn checkout svn://domain/project 可能出现的问题CentOS7下客户端无法访问这是因为在CentOS7下，原先的iptables被替换了firewalld，所以对iptables的防火墙设置是没有用的。 因此如果想要让3690端口（SVN服务器端口）对外开放的话，则需要对firewalld进行配置。 firewall-cmd --permanent --query-port=3690/tcp 通过上述命令可以查看3690端口是否开放。 irewall-cmd --permanent --add-port=3690/tcp 通过上述命令则可以添加开放端口。]]></content>
      <tags>
        <tag>svn</tag>
      </tags>
  </entry>
</search>
