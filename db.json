{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/FE-Hybrid-interaction.png","path":"images/FE-Hybrid-interaction.png","modified":0,"renderable":0},{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"1e98c71644e1df5610d8d14844c7cabe3638ca29","modified":1501429110000},{"_id":"themes/landscape/.DS_Store","hash":"a490474aed8f0a9d0e1989756248136d5e012024","modified":1501420104000},{"_id":"themes/landscape/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1501174069000},{"_id":"themes/landscape/.gitignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1501174069000},{"_id":"themes/landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1501174069000},{"_id":"themes/landscape/README.md","hash":"c7e83cfe8f2c724fc9cac32bd71bb5faf9ceeddb","modified":1501174069000},{"_id":"themes/landscape/_config.yml","hash":"fb8c98a0f6ff9f962637f329c22699721854cd73","modified":1501174069000},{"_id":"themes/landscape/package.json","hash":"85358dc34311c6662e841584e206a4679183943f","modified":1501174069000},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1501428231000},{"_id":"source/_posts/2016-03-04-SVN：LNMP下搭建SVN服务器简明步骤.markdown","hash":"0058c171fae8bdc3d16e260f9e632ce36dbeb051","modified":1501428089000},{"_id":"source/_posts/2016-03-04-SVN：同步版本库与网站目录.markdown","hash":"ba3d14a117b3df4a814660d542b7bf3579129081","modified":1501428084000},{"_id":"source/_posts/2016-04-24-深入浅出React读后笔记.markdown","hash":"b8c91f3424af4d56c80e36f54bcb0479ea86fee2","modified":1501428096000},{"_id":"source/_posts/2017-01-03-Git：常用命令整理.markdown","hash":"ccc92a90d63f8f954228e61516244728e52b63ec","modified":1501428161000},{"_id":"source/_posts/2017-04-02-Sublime-Text-3的基本安装与配置.markdown","hash":"0e154802ca4d1a19022c1590e0dd8b05f545ac8a","modified":1501428104000},{"_id":"source/_posts/2017-04-07-Mac在Terminal打开Finder.markdown","hash":"d77d3443e4555c26f4176bf74079fa4b91cdc64e","modified":1501428170000},{"_id":"source/_posts/2017-04-11-HTTP：协议基础.markdown","hash":"0a0d1f2fefff3a735fb5ccdcea324fb2d8a7c32d","modified":1501428185000},{"_id":"source/_posts/2017-04-11-JavaScript：基本数据类型整理.markdown","hash":"0c794f8ff92cb2bb7d325f4a015dc8a2efd23a49","modified":1501428123000},{"_id":"source/_posts/2017-04-12-HTTP：常见的状态码.markdown","hash":"a49b13289722b8309c92f2412358ab7c4c2fbf25","modified":1501428931000},{"_id":"source/_posts/2017-04-14-React：基本环境搭建简明步骤.markdown","hash":"4eee7deb74ec3ccdb8bd525b15f84a0713ff9489","modified":1501428130000},{"_id":"source/_posts/2017-05-23-什么是Hybrid App.markdown","hash":"16c4f20ec10d16403c1bfbea7ac4e5328f89170e","modified":1501429131000},{"_id":"source/_posts/2017-07-06-Shell 脚本入门.md","hash":"5c561ad782abc97c14112a30102ea2ffc598e46a","modified":1501428828000},{"_id":"themes/landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1501174069000},{"_id":"themes/landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1501174069000},{"_id":"themes/landscape/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1501174069000},{"_id":"themes/landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1501174069000},{"_id":"themes/landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1501174069000},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1501174069000},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1501174069000},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1501174069000},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1501174069000},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1501174069000},{"_id":"themes/landscape/layout/layout.ejs","hash":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1501174069000},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1501174069000},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1501174069000},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1501174069000},{"_id":"themes/landscape/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1501174069000},{"_id":"themes/landscape/source/.DS_Store","hash":"b025c850f026231b4e4cbfd81e43443aefe3f0bb","modified":1501420104000},{"_id":"source/images/FE-Hybrid-interaction.png","hash":"3cb09a129f16a5f53cb5194c155f8895336eee7c","modified":1495556132000},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"82a30f81c0e8ba4a8af17acd6cc99e93834e4d5e","modified":1501174069000},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1501174069000},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"c99d362dcc5f367a0b21291a7714d2528edb9a21","modified":1501427998000},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"f7e102eebf4f6ec8da829dce16b33a0f1789fe12","modified":1501427869000},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"93518893cf91287e797ebac543c560e2a63b8d0e","modified":1501174069000},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1501174069000},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"4fe8853e864d192701c03e5cd3a5390287b90612","modified":1501174069000},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"ded70f83c4aca62c321a3a0cde9f6f3020083d7e","modified":1501427634000},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1501174069000},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1501174069000},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1501174069000},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1501174069000},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1501174069000},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1501174069000},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1501174069000},{"_id":"themes/landscape/source/css/.DS_Store","hash":"955a41242e526c230f6d1b34c662a161cd0b50b9","modified":1501427493000},{"_id":"themes/landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1501174069000},{"_id":"themes/landscape/source/css/_variables.styl","hash":"5e37a6571caf87149af83ac1cc0cdef99f117350","modified":1501174069000},{"_id":"themes/landscape/source/css/style.styl","hash":"a70d9c44dac348d742702f6ba87e5bb3084d65db","modified":1501174069000},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1501174069000},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1501174069000},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1501174069000},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1501174069000},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1501174069000},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1501174069000},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1501174069000},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1501174069000},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1501174069000},{"_id":"themes/landscape/source/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1501174069000},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1501174069000},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1501174069000},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1501174069000},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1501174069000},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1501174069000},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1501174069000},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1501174069000},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"10685f8787a79f79c9a26c2f943253450c498e3e","modified":1501174069000},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1501174069000},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1501174069000},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"32a5d50a0f55fa62460c365c7b17a63ee03e039b","modified":1501424309000},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1501174069000},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1501174069000},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1501174069000},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1501174069000},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1501174069000},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1501174069000},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1501174069000},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1501174069000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1501174069000},{"_id":"themes/landscape/source/css/images/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1501420653000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1501174069000},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1501174069000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1501174069000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1501174069000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1501174069000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1501174069000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1501174069000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1501174069000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1501174069000},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"0da5aa5c379ae626c7ad34b0b20e7d7822e5494a","modified":1501419839000},{"_id":"public/2017/05/23/2017-05-23-什么是Hybrid App/index.html","hash":"d539d538b8b676c71a968c2f748808a9d814ce87","modified":1501430700559},{"_id":"public/2017/04/14/2017-04-14-React：基本环境搭建简明步骤/index.html","hash":"7a552df6e2ff7fc2ae784d6113dcd51a2a4d193c","modified":1501430700559},{"_id":"public/2017/04/07/2017-04-07-Mac在Terminal打开Finder/index.html","hash":"5b162af00261e2c652245cb87881fc5a688041ab","modified":1501430700560},{"_id":"public/2017/04/02/2017-04-02-Sublime-Text-3的基本安装与配置/index.html","hash":"b949f6c63be7a311ed266aacd1b4bfe8d88245c3","modified":1501430700560},{"_id":"public/2016/03/04/2016-03-04-SVN：同步版本库与网站目录/index.html","hash":"9f43da3783f937bdc2056d4895936c6665c5a8b4","modified":1501430700560},{"_id":"public/2016/03/04/2016-03-04-SVN：LNMP下搭建SVN服务器简明步骤/index.html","hash":"857fc2b9ce2ae8405d75052f69a8b2cd60846127","modified":1501430700560},{"_id":"public/archives/index.html","hash":"15379f3c1217d9669fa6b43a2a853b01fa59b62c","modified":1501430700560},{"_id":"public/archives/page/2/index.html","hash":"3d45cb6195cb4b50fe02a867b7dcebc6384cd862","modified":1501430700560},{"_id":"public/archives/2016/index.html","hash":"99e544b140fca3b0ba28e45d32a10bf8d0ebc7ec","modified":1501430700560},{"_id":"public/archives/2016/03/index.html","hash":"d8cf274bc7c31bd0b1b7900bd742dae5ea87f545","modified":1501430700560},{"_id":"public/archives/2016/04/index.html","hash":"a4a5e40fcea1c18f6bb8221bdad23a5610348743","modified":1501430700560},{"_id":"public/archives/2017/index.html","hash":"e5652282c8867aae3a21575a8fa37d535ad03965","modified":1501430700560},{"_id":"public/archives/2017/01/index.html","hash":"3464d8e3451a9b1854d09fd9a4a679501c0069ee","modified":1501430700560},{"_id":"public/archives/2017/04/index.html","hash":"0fba03db10cd0faf52ed98ead575e2908615d114","modified":1501430700560},{"_id":"public/archives/2017/05/index.html","hash":"b19336e9420c4951a16015cdc09dcb8e9f488f1c","modified":1501430700560},{"_id":"public/archives/2017/07/index.html","hash":"0fc2be04cceabccbd08e3496deda0d979f72f0ce","modified":1501430700560},{"_id":"public/categories/SVN/index.html","hash":"cf6bbada2012e1333586000639407d6e7f092fe2","modified":1501430700560},{"_id":"public/categories/React/index.html","hash":"b7c6dc3e0d14c258af67e2e4ae68a0e497813b1d","modified":1501430700560},{"_id":"public/categories/Git/index.html","hash":"e9e8e33e53c21497bd0c9f869056490b02110e04","modified":1501430700560},{"_id":"public/categories/Sublime/index.html","hash":"62730ee5b18cc62c3f78f5eb726afa8fa4c8e9f0","modified":1501430700560},{"_id":"public/categories/Mac/index.html","hash":"cc0c2da74b4fae3062dd43df7ae66b983534c2b7","modified":1501430700561},{"_id":"public/categories/HTTP/index.html","hash":"72c958f87cb4ff1ee7dc1775fc831682f7535c7f","modified":1501430700561},{"_id":"public/categories/JavaScript/index.html","hash":"cc840f0026927800ceb8e51321a6845f3c5bd481","modified":1501430700561},{"_id":"public/categories/FE/index.html","hash":"eddc67b099569c0d10a573e89dc01987f8093b2e","modified":1501430700561},{"_id":"public/categories/shell/index.html","hash":"d8484de5f1902b317b1f379659cd7fdc2786c4c1","modified":1501430700561},{"_id":"public/page/2/index.html","hash":"d9c546e70b48672ecf65a0372c2a90382be19a53","modified":1501430700561},{"_id":"public/2017/07/06/2017-07-06-Shell 脚本入门/index.html","hash":"9b8d3a6b8de94427b80ad366dda1b244d4b34d9d","modified":1501430700561},{"_id":"public/2017/04/12/2017-04-12-HTTP：常见的状态码/index.html","hash":"b4241b464e6faa8352bc278246555d82c05564ed","modified":1501430700561},{"_id":"public/2017/04/11/2017-04-11-HTTP：协议基础/index.html","hash":"05d445c43b048df7f8a52a49aa53fc9e2731c125","modified":1501430700561},{"_id":"public/2017/04/11/2017-04-11-JavaScript：基本数据类型整理/index.html","hash":"10b9cfd9604fd05067ec1a4ffadf6a479bba32b8","modified":1501430700561},{"_id":"public/2017/01/30/2017-01-03-Git：常用命令整理/index.html","hash":"0b6c2f5b99846b13e62f33fef509abe4491df1ba","modified":1501430700561},{"_id":"public/2016/04/24/2016-04-24-深入浅出React读后笔记/index.html","hash":"2259441b52cd3a35ababda6b24e285fcc371a420","modified":1501430700561},{"_id":"public/index.html","hash":"9ae39ec6f89dd9493fef24e3e8e0b3e22f94c617","modified":1501430700561},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1501430700569},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1501430700569},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1501430700569},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1501430700569},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1501430700569},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1501430700569},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1501430700569},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1501430700569},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1501430700569},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1501430700569},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1501430700999},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1501430701005},{"_id":"public/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1501430701005},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1501430701005},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1501430701005},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1501430701005},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1501430701005},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1501430701005},{"_id":"public/css/style.css","hash":"199b1196bcf01c2a8d72df0557141de0f99c4106","modified":1501430701005},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1501430701005},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1501430701005},{"_id":"public/images/FE-Hybrid-interaction.png","hash":"3cb09a129f16a5f53cb5194c155f8895336eee7c","modified":1501430701005},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1501430701008},{"_id":"public/css/images/banner.jpg","hash":"0da5aa5c379ae626c7ad34b0b20e7d7822e5494a","modified":1501430701012}],"Category":[{"name":"SVN","_id":"cj5qx2ml80002b4orio7jb1ah"},{"name":"React","_id":"cj5qx2mll000ab4or5que9f9e"},{"name":"Git","_id":"cj5qx2mlo000eb4orch16muu9"},{"name":"Sublime","_id":"cj5qx2mlr000ib4orxjq63fl3"},{"name":"Mac","_id":"cj5qx2mls000mb4orq39zwefg"},{"name":"HTTP","_id":"cj5qx2mlu000ob4orbqani19k"},{"name":"JavaScript","_id":"cj5qx2mlv000qb4orz4mstigi"},{"name":"FE","_id":"cj5qx2mlx000ub4or3dgjzshk"},{"name":"shell","_id":"cj5qx2mly000wb4orr9ed1hl0"}],"Data":[],"Page":[],"Post":[{"layout":"post","title":"SVN：同步版本库与网站目录","date":"2016-03-04T15:10:15.000Z","_content":"\n承接之前[Lnmp下搭建Svn服务器]({% post_url 2016-03-04-SVN：LNMP下搭建SVN服务器简明步骤 %})的步骤，接下来要使用Svn中的hooks来进行版本库与网站目录的同步更新。以方便对网站代码进行管理和发布。\n\n注意，下文中PATH、PROJECT等全大写的字符串均为举例用，实际操作时请替换成自己的目录和版本库或项目名称。\n\n## 原理\n\n首先切换到版本库的目录\n\n    cd /PATH/svn/PROJECT\n    ls\n\n会看到有hooks文件夹\n\n    cd hooks\n    ls\n\n可以看到有一个post-commit.tmpl，这个是svn官方的一个模板，在每次commit操作之后都会执行这个脚本，其他的hooks同理。\n\n看到这里你应该可以想到，版本库与网站目录同步的原理，就是在客户端commit了代码之后，执行这个脚本来同时update网站目录的内容，保证两者的同步。\n\n## 配置操作\n\n### 首先需要在网站目录checkout版本库\n\n先不要着急打接下来的命令\n\n    cd PATH/wwwroot/www.example.com\n    svn checkout file://PATH/svn/PROJECT\n    \n因为执行了这个命令之后你也许会发现，在网站目录下多了一个PROJECT文件夹，这个文件夹里面才是版本库控制的内容。\n\n然而我们的目的是想让当前网站的根目录与svn直接同步，因此我们在上一级目录进行checkout。\n\n接下来正确的做法是\n\n    cd PATH/wwwroot\n    svn checkout file://PATH/svn/PROJECT www.example.com\n\n上述命令是在checkout版本库的同时对它进行了重命名，这样子，网站的根目录就如预想的一样在版本库的控制之下了。\n\n### 接下来配置hooks\n\n    cd PATH/svn/PROJECT/hooks\n    cp post-commit.tmpl post-commit\n\n复制一份post-commit并去掉它的后缀名，这么做的原因是，.tmpl是一个模板文件，实际并不会执行，只有去掉后缀名之后它才会生效。\n\n    vi post-commit\n\n在末尾加入\n\n    export LANG=zh_CN.UTF-8\n    svn update PATH/wwwroot/www.example.com --username USER1 --password PASSWD1 --no-auth-cache\n\nexport的作用是防止乱码。\n\nupdate则是对网站目录进行更新，让网站目录与版本库同步，这里USER1和PASSWD1是之前的教程里配置的用户名和密码，请根据实际情况进行替换。\n编辑完成之后，按ESC并输入:wq，保存并退出。\n\n### 测试hooks\n#### 添加可执行权限\n\n    chmod +x post-commit\n\n#### 运行测试\n\n    ./post-commit\n    \n　　如果有报错，请重新vi一遍看看是不是有打错\n\n#### 切换用户进行测试\n\n由于ssh VPS之后大多数情况用的都是root用户，而svn commit之后执行hooks的是另外一个用户，所以在root权限下执行没有问题，在另外的用户下可能就没有那么足够的权限了。所以接下来\n\n    su www\n    ./post-commit\n\n如果执行成功，那么基本不会有问题。\n如果su www时出现not available的情况，尝试下面这个命令\n\n    usermod -s /bin/bash www\n\n　　如果出现各种权限不足的情况，我建议上述所有步骤都在www用户下执行（除了部分更改文件执行权限操作等必须用root用户的）。\n\n### 实际测试\n\n使用你的svn客户端checkout该版本库并上传一些文件或做一些改动，接着进行commit，查看网站目录是否与版本库同步。\n\n## 总结\n\nSvn的hooks是非常好用的脚本，在每次commit之后，你也可以加入日志记录、通知提醒等等功能。当然，这些功能也是需要一定的shell能力才写的出来。\n","source":"_posts/2016-03-04-SVN：同步版本库与网站目录.markdown","raw":"---\nlayout: post\ntitle:  \"SVN：同步版本库与网站目录\"\ndate:   2016-03-04 23:10:15 +0800\ncategories: SVN\n---\n\n承接之前[Lnmp下搭建Svn服务器]({% post_url 2016-03-04-SVN：LNMP下搭建SVN服务器简明步骤 %})的步骤，接下来要使用Svn中的hooks来进行版本库与网站目录的同步更新。以方便对网站代码进行管理和发布。\n\n注意，下文中PATH、PROJECT等全大写的字符串均为举例用，实际操作时请替换成自己的目录和版本库或项目名称。\n\n## 原理\n\n首先切换到版本库的目录\n\n    cd /PATH/svn/PROJECT\n    ls\n\n会看到有hooks文件夹\n\n    cd hooks\n    ls\n\n可以看到有一个post-commit.tmpl，这个是svn官方的一个模板，在每次commit操作之后都会执行这个脚本，其他的hooks同理。\n\n看到这里你应该可以想到，版本库与网站目录同步的原理，就是在客户端commit了代码之后，执行这个脚本来同时update网站目录的内容，保证两者的同步。\n\n## 配置操作\n\n### 首先需要在网站目录checkout版本库\n\n先不要着急打接下来的命令\n\n    cd PATH/wwwroot/www.example.com\n    svn checkout file://PATH/svn/PROJECT\n    \n因为执行了这个命令之后你也许会发现，在网站目录下多了一个PROJECT文件夹，这个文件夹里面才是版本库控制的内容。\n\n然而我们的目的是想让当前网站的根目录与svn直接同步，因此我们在上一级目录进行checkout。\n\n接下来正确的做法是\n\n    cd PATH/wwwroot\n    svn checkout file://PATH/svn/PROJECT www.example.com\n\n上述命令是在checkout版本库的同时对它进行了重命名，这样子，网站的根目录就如预想的一样在版本库的控制之下了。\n\n### 接下来配置hooks\n\n    cd PATH/svn/PROJECT/hooks\n    cp post-commit.tmpl post-commit\n\n复制一份post-commit并去掉它的后缀名，这么做的原因是，.tmpl是一个模板文件，实际并不会执行，只有去掉后缀名之后它才会生效。\n\n    vi post-commit\n\n在末尾加入\n\n    export LANG=zh_CN.UTF-8\n    svn update PATH/wwwroot/www.example.com --username USER1 --password PASSWD1 --no-auth-cache\n\nexport的作用是防止乱码。\n\nupdate则是对网站目录进行更新，让网站目录与版本库同步，这里USER1和PASSWD1是之前的教程里配置的用户名和密码，请根据实际情况进行替换。\n编辑完成之后，按ESC并输入:wq，保存并退出。\n\n### 测试hooks\n#### 添加可执行权限\n\n    chmod +x post-commit\n\n#### 运行测试\n\n    ./post-commit\n    \n　　如果有报错，请重新vi一遍看看是不是有打错\n\n#### 切换用户进行测试\n\n由于ssh VPS之后大多数情况用的都是root用户，而svn commit之后执行hooks的是另外一个用户，所以在root权限下执行没有问题，在另外的用户下可能就没有那么足够的权限了。所以接下来\n\n    su www\n    ./post-commit\n\n如果执行成功，那么基本不会有问题。\n如果su www时出现not available的情况，尝试下面这个命令\n\n    usermod -s /bin/bash www\n\n　　如果出现各种权限不足的情况，我建议上述所有步骤都在www用户下执行（除了部分更改文件执行权限操作等必须用root用户的）。\n\n### 实际测试\n\n使用你的svn客户端checkout该版本库并上传一些文件或做一些改动，接着进行commit，查看网站目录是否与版本库同步。\n\n## 总结\n\nSvn的hooks是非常好用的脚本，在每次commit之后，你也可以加入日志记录、通知提醒等等功能。当然，这些功能也是需要一定的shell能力才写的出来。\n","slug":"2016-03-04-SVN：同步版本库与网站目录","published":1,"updated":"2017-07-30T15:21:24.000Z","comments":1,"photos":[],"link":"","_id":"cj5qx2ml10000b4or613n6816","content":"<p>承接之前<a href=\"!--￼0--\">Lnmp下搭建Svn服务器</a>的步骤，接下来要使用Svn中的hooks来进行版本库与网站目录的同步更新。以方便对网站代码进行管理和发布。</p>\n<p>注意，下文中PATH、PROJECT等全大写的字符串均为举例用，实际操作时请替换成自己的目录和版本库或项目名称。</p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>首先切换到版本库的目录</p>\n<pre><code>cd /PATH/svn/PROJECT\nls\n</code></pre><p>会看到有hooks文件夹</p>\n<pre><code>cd hooks\nls\n</code></pre><p>可以看到有一个post-commit.tmpl，这个是svn官方的一个模板，在每次commit操作之后都会执行这个脚本，其他的hooks同理。</p>\n<p>看到这里你应该可以想到，版本库与网站目录同步的原理，就是在客户端commit了代码之后，执行这个脚本来同时update网站目录的内容，保证两者的同步。</p>\n<h2 id=\"配置操作\"><a href=\"#配置操作\" class=\"headerlink\" title=\"配置操作\"></a>配置操作</h2><h3 id=\"首先需要在网站目录checkout版本库\"><a href=\"#首先需要在网站目录checkout版本库\" class=\"headerlink\" title=\"首先需要在网站目录checkout版本库\"></a>首先需要在网站目录checkout版本库</h3><p>先不要着急打接下来的命令</p>\n<pre><code>cd PATH/wwwroot/www.example.com\nsvn checkout file://PATH/svn/PROJECT\n</code></pre><p>因为执行了这个命令之后你也许会发现，在网站目录下多了一个PROJECT文件夹，这个文件夹里面才是版本库控制的内容。</p>\n<p>然而我们的目的是想让当前网站的根目录与svn直接同步，因此我们在上一级目录进行checkout。</p>\n<p>接下来正确的做法是</p>\n<pre><code>cd PATH/wwwroot\nsvn checkout file://PATH/svn/PROJECT www.example.com\n</code></pre><p>上述命令是在checkout版本库的同时对它进行了重命名，这样子，网站的根目录就如预想的一样在版本库的控制之下了。</p>\n<h3 id=\"接下来配置hooks\"><a href=\"#接下来配置hooks\" class=\"headerlink\" title=\"接下来配置hooks\"></a>接下来配置hooks</h3><pre><code>cd PATH/svn/PROJECT/hooks\ncp post-commit.tmpl post-commit\n</code></pre><p>复制一份post-commit并去掉它的后缀名，这么做的原因是，.tmpl是一个模板文件，实际并不会执行，只有去掉后缀名之后它才会生效。</p>\n<pre><code>vi post-commit\n</code></pre><p>在末尾加入</p>\n<pre><code>export LANG=zh_CN.UTF-8\nsvn update PATH/wwwroot/www.example.com --username USER1 --password PASSWD1 --no-auth-cache\n</code></pre><p>export的作用是防止乱码。</p>\n<p>update则是对网站目录进行更新，让网站目录与版本库同步，这里USER1和PASSWD1是之前的教程里配置的用户名和密码，请根据实际情况进行替换。<br>编辑完成之后，按ESC并输入:wq，保存并退出。</p>\n<h3 id=\"测试hooks\"><a href=\"#测试hooks\" class=\"headerlink\" title=\"测试hooks\"></a>测试hooks</h3><h4 id=\"添加可执行权限\"><a href=\"#添加可执行权限\" class=\"headerlink\" title=\"添加可执行权限\"></a>添加可执行权限</h4><pre><code>chmod +x post-commit\n</code></pre><h4 id=\"运行测试\"><a href=\"#运行测试\" class=\"headerlink\" title=\"运行测试\"></a>运行测试</h4><pre><code>./post-commit\n</code></pre><p>　　如果有报错，请重新vi一遍看看是不是有打错</p>\n<h4 id=\"切换用户进行测试\"><a href=\"#切换用户进行测试\" class=\"headerlink\" title=\"切换用户进行测试\"></a>切换用户进行测试</h4><p>由于ssh VPS之后大多数情况用的都是root用户，而svn commit之后执行hooks的是另外一个用户，所以在root权限下执行没有问题，在另外的用户下可能就没有那么足够的权限了。所以接下来</p>\n<pre><code>su www\n./post-commit\n</code></pre><p>如果执行成功，那么基本不会有问题。<br>如果su www时出现not available的情况，尝试下面这个命令</p>\n<pre><code>usermod -s /bin/bash www\n</code></pre><p>　　如果出现各种权限不足的情况，我建议上述所有步骤都在www用户下执行（除了部分更改文件执行权限操作等必须用root用户的）。</p>\n<h3 id=\"实际测试\"><a href=\"#实际测试\" class=\"headerlink\" title=\"实际测试\"></a>实际测试</h3><p>使用你的svn客户端checkout该版本库并上传一些文件或做一些改动，接着进行commit，查看网站目录是否与版本库同步。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>Svn的hooks是非常好用的脚本，在每次commit之后，你也可以加入日志记录、通知提醒等等功能。当然，这些功能也是需要一定的shell能力才写的出来。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>承接之前<a href=\"!--￼0--\">Lnmp下搭建Svn服务器</a>的步骤，接下来要使用Svn中的hooks来进行版本库与网站目录的同步更新。以方便对网站代码进行管理和发布。</p>\n<p>注意，下文中PATH、PROJECT等全大写的字符串均为举例用，实际操作时请替换成自己的目录和版本库或项目名称。</p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>首先切换到版本库的目录</p>\n<pre><code>cd /PATH/svn/PROJECT\nls\n</code></pre><p>会看到有hooks文件夹</p>\n<pre><code>cd hooks\nls\n</code></pre><p>可以看到有一个post-commit.tmpl，这个是svn官方的一个模板，在每次commit操作之后都会执行这个脚本，其他的hooks同理。</p>\n<p>看到这里你应该可以想到，版本库与网站目录同步的原理，就是在客户端commit了代码之后，执行这个脚本来同时update网站目录的内容，保证两者的同步。</p>\n<h2 id=\"配置操作\"><a href=\"#配置操作\" class=\"headerlink\" title=\"配置操作\"></a>配置操作</h2><h3 id=\"首先需要在网站目录checkout版本库\"><a href=\"#首先需要在网站目录checkout版本库\" class=\"headerlink\" title=\"首先需要在网站目录checkout版本库\"></a>首先需要在网站目录checkout版本库</h3><p>先不要着急打接下来的命令</p>\n<pre><code>cd PATH/wwwroot/www.example.com\nsvn checkout file://PATH/svn/PROJECT\n</code></pre><p>因为执行了这个命令之后你也许会发现，在网站目录下多了一个PROJECT文件夹，这个文件夹里面才是版本库控制的内容。</p>\n<p>然而我们的目的是想让当前网站的根目录与svn直接同步，因此我们在上一级目录进行checkout。</p>\n<p>接下来正确的做法是</p>\n<pre><code>cd PATH/wwwroot\nsvn checkout file://PATH/svn/PROJECT www.example.com\n</code></pre><p>上述命令是在checkout版本库的同时对它进行了重命名，这样子，网站的根目录就如预想的一样在版本库的控制之下了。</p>\n<h3 id=\"接下来配置hooks\"><a href=\"#接下来配置hooks\" class=\"headerlink\" title=\"接下来配置hooks\"></a>接下来配置hooks</h3><pre><code>cd PATH/svn/PROJECT/hooks\ncp post-commit.tmpl post-commit\n</code></pre><p>复制一份post-commit并去掉它的后缀名，这么做的原因是，.tmpl是一个模板文件，实际并不会执行，只有去掉后缀名之后它才会生效。</p>\n<pre><code>vi post-commit\n</code></pre><p>在末尾加入</p>\n<pre><code>export LANG=zh_CN.UTF-8\nsvn update PATH/wwwroot/www.example.com --username USER1 --password PASSWD1 --no-auth-cache\n</code></pre><p>export的作用是防止乱码。</p>\n<p>update则是对网站目录进行更新，让网站目录与版本库同步，这里USER1和PASSWD1是之前的教程里配置的用户名和密码，请根据实际情况进行替换。<br>编辑完成之后，按ESC并输入:wq，保存并退出。</p>\n<h3 id=\"测试hooks\"><a href=\"#测试hooks\" class=\"headerlink\" title=\"测试hooks\"></a>测试hooks</h3><h4 id=\"添加可执行权限\"><a href=\"#添加可执行权限\" class=\"headerlink\" title=\"添加可执行权限\"></a>添加可执行权限</h4><pre><code>chmod +x post-commit\n</code></pre><h4 id=\"运行测试\"><a href=\"#运行测试\" class=\"headerlink\" title=\"运行测试\"></a>运行测试</h4><pre><code>./post-commit\n</code></pre><p>　　如果有报错，请重新vi一遍看看是不是有打错</p>\n<h4 id=\"切换用户进行测试\"><a href=\"#切换用户进行测试\" class=\"headerlink\" title=\"切换用户进行测试\"></a>切换用户进行测试</h4><p>由于ssh VPS之后大多数情况用的都是root用户，而svn commit之后执行hooks的是另外一个用户，所以在root权限下执行没有问题，在另外的用户下可能就没有那么足够的权限了。所以接下来</p>\n<pre><code>su www\n./post-commit\n</code></pre><p>如果执行成功，那么基本不会有问题。<br>如果su www时出现not available的情况，尝试下面这个命令</p>\n<pre><code>usermod -s /bin/bash www\n</code></pre><p>　　如果出现各种权限不足的情况，我建议上述所有步骤都在www用户下执行（除了部分更改文件执行权限操作等必须用root用户的）。</p>\n<h3 id=\"实际测试\"><a href=\"#实际测试\" class=\"headerlink\" title=\"实际测试\"></a>实际测试</h3><p>使用你的svn客户端checkout该版本库并上传一些文件或做一些改动，接着进行commit，查看网站目录是否与版本库同步。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>Svn的hooks是非常好用的脚本，在每次commit之后，你也可以加入日志记录、通知提醒等等功能。当然，这些功能也是需要一定的shell能力才写的出来。</p>\n"},{"layout":"post","title":"SVN：LNMP下搭建SVN服务器简明步骤","date":"2016-03-04T06:47:11.000Z","_content":"下文中PATH、PROJECT等全大写的字符串均为举例用，实际操作时请替换成自己的目录和版本库或项目名称等。\n## 安装\n\n    yum install subversion\n\n等待一段时间完成svn的安装。\n\n##建立版本库的文件夹，并给与777的权限\n\n    mkdir PATH/svn\n    chmod 777 -R PATH/svn\n    \n## 创建版本库\n\n    svnadmin create PATH/svn/PROJECT\n\n## 接下来对Svn进行配置\n### 配置svnserve.conf\n\n    vi PATH/svn/PROJECT/conf/svnserve.conf\n\n将内容中注释掉的以下部分去掉#和空格，并将anon-access = read改为none：\n\n\n     # anon-access = read\n     # auth-access = write\n     # password-db = passwd\n     # authz-db = authz\n\n变成\n\n     anon-access = none\n     auth-access = write\n     password-db = passwd\n     authz-db = authz\n\n### 配置authz\n    vi PATH/svn/PROJECT/conf/authz\n\n　　在[group]下加入\n\n    YOUR_GROUP = USER1,USER2\n\n　　在# [/foo/bar]下加入\n\n    [/]\n    @YOUR_GROUP=rw\n    * = r\n\n### 配置passwd\n    vi PATH/svn/PROJECT/conf/passwd\n\n　　在[users]下加入\n\n    USER1=PASSWD1\n    USER2=PASSWD2\n\n## 启动SVN服务\n\n    svnserve -d -r PATH/svn/\n\n这里需要注意，这里设置的是svn服务器的根目录。在checkout的时候，以这个目录（PATH/svn/)作为起点，可以添加多个版本库，访问的时候则可以用“svn://域名/版本库名”来进行checkout。\n\n### 如何关闭服务\n　　直接杀死相关进程即可\n   \n\n     killall svnserve\n    \n## 客户端访问方式\n\n    svn checkout svn://domain/project\n\n## 可能出现的问题\n### CentOS7下客户端无法访问\n\n这是因为在CentOS7下，原先的iptables被替换了firewalld，所以对iptables的防火墙设置是没有用的。\n\n因此如果想要让3690端口（SVN服务器端口）对外开放的话，则需要对firewalld进行配置。\n\n    firewall-cmd --permanent --query-port=3690/tcp\n\n通过上述命令可以查看3690端口是否开放。\n\n    irewall-cmd --permanent --add-port=3690/tcp\n\n通过上述命令则可以添加开放端口。","source":"_posts/2016-03-04-SVN：LNMP下搭建SVN服务器简明步骤.markdown","raw":"---\nlayout: post\ntitle:  \"SVN：LNMP下搭建SVN服务器简明步骤\"\ndate:   2016-03-04 14:47:11 +0800\ncategories: SVN\n---\n下文中PATH、PROJECT等全大写的字符串均为举例用，实际操作时请替换成自己的目录和版本库或项目名称等。\n## 安装\n\n    yum install subversion\n\n等待一段时间完成svn的安装。\n\n##建立版本库的文件夹，并给与777的权限\n\n    mkdir PATH/svn\n    chmod 777 -R PATH/svn\n    \n## 创建版本库\n\n    svnadmin create PATH/svn/PROJECT\n\n## 接下来对Svn进行配置\n### 配置svnserve.conf\n\n    vi PATH/svn/PROJECT/conf/svnserve.conf\n\n将内容中注释掉的以下部分去掉#和空格，并将anon-access = read改为none：\n\n\n     # anon-access = read\n     # auth-access = write\n     # password-db = passwd\n     # authz-db = authz\n\n变成\n\n     anon-access = none\n     auth-access = write\n     password-db = passwd\n     authz-db = authz\n\n### 配置authz\n    vi PATH/svn/PROJECT/conf/authz\n\n　　在[group]下加入\n\n    YOUR_GROUP = USER1,USER2\n\n　　在# [/foo/bar]下加入\n\n    [/]\n    @YOUR_GROUP=rw\n    * = r\n\n### 配置passwd\n    vi PATH/svn/PROJECT/conf/passwd\n\n　　在[users]下加入\n\n    USER1=PASSWD1\n    USER2=PASSWD2\n\n## 启动SVN服务\n\n    svnserve -d -r PATH/svn/\n\n这里需要注意，这里设置的是svn服务器的根目录。在checkout的时候，以这个目录（PATH/svn/)作为起点，可以添加多个版本库，访问的时候则可以用“svn://域名/版本库名”来进行checkout。\n\n### 如何关闭服务\n　　直接杀死相关进程即可\n   \n\n     killall svnserve\n    \n## 客户端访问方式\n\n    svn checkout svn://domain/project\n\n## 可能出现的问题\n### CentOS7下客户端无法访问\n\n这是因为在CentOS7下，原先的iptables被替换了firewalld，所以对iptables的防火墙设置是没有用的。\n\n因此如果想要让3690端口（SVN服务器端口）对外开放的话，则需要对firewalld进行配置。\n\n    firewall-cmd --permanent --query-port=3690/tcp\n\n通过上述命令可以查看3690端口是否开放。\n\n    irewall-cmd --permanent --add-port=3690/tcp\n\n通过上述命令则可以添加开放端口。","slug":"2016-03-04-SVN：LNMP下搭建SVN服务器简明步骤","published":1,"updated":"2017-07-30T15:21:29.000Z","comments":1,"photos":[],"link":"","_id":"cj5qx2ml60001b4or3dnd471m","content":"<p>下文中PATH、PROJECT等全大写的字符串均为举例用，实际操作时请替换成自己的目录和版本库或项目名称等。</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><pre><code>yum install subversion\n</code></pre><p>等待一段时间完成svn的安装。</p>\n<p>##建立版本库的文件夹，并给与777的权限</p>\n<pre><code>mkdir PATH/svn\nchmod 777 -R PATH/svn\n</code></pre><h2 id=\"创建版本库\"><a href=\"#创建版本库\" class=\"headerlink\" title=\"创建版本库\"></a>创建版本库</h2><pre><code>svnadmin create PATH/svn/PROJECT\n</code></pre><h2 id=\"接下来对Svn进行配置\"><a href=\"#接下来对Svn进行配置\" class=\"headerlink\" title=\"接下来对Svn进行配置\"></a>接下来对Svn进行配置</h2><h3 id=\"配置svnserve-conf\"><a href=\"#配置svnserve-conf\" class=\"headerlink\" title=\"配置svnserve.conf\"></a>配置svnserve.conf</h3><pre><code>vi PATH/svn/PROJECT/conf/svnserve.conf\n</code></pre><p>将内容中注释掉的以下部分去掉#和空格，并将anon-access = read改为none：</p>\n<pre><code># anon-access = read\n# auth-access = write\n# password-db = passwd\n# authz-db = authz\n</code></pre><p>变成</p>\n<pre><code>anon-access = none\nauth-access = write\npassword-db = passwd\nauthz-db = authz\n</code></pre><h3 id=\"配置authz\"><a href=\"#配置authz\" class=\"headerlink\" title=\"配置authz\"></a>配置authz</h3><pre><code>vi PATH/svn/PROJECT/conf/authz\n</code></pre><p>　　在[group]下加入</p>\n<pre><code>YOUR_GROUP = USER1,USER2\n</code></pre><p>　　在# [/foo/bar]下加入</p>\n<pre><code>[/]\n@YOUR_GROUP=rw\n* = r\n</code></pre><h3 id=\"配置passwd\"><a href=\"#配置passwd\" class=\"headerlink\" title=\"配置passwd\"></a>配置passwd</h3><pre><code>vi PATH/svn/PROJECT/conf/passwd\n</code></pre><p>　　在[users]下加入</p>\n<pre><code>USER1=PASSWD1\nUSER2=PASSWD2\n</code></pre><h2 id=\"启动SVN服务\"><a href=\"#启动SVN服务\" class=\"headerlink\" title=\"启动SVN服务\"></a>启动SVN服务</h2><pre><code>svnserve -d -r PATH/svn/\n</code></pre><p>这里需要注意，这里设置的是svn服务器的根目录。在checkout的时候，以这个目录（PATH/svn/)作为起点，可以添加多个版本库，访问的时候则可以用“svn://域名/版本库名”来进行checkout。</p>\n<h3 id=\"如何关闭服务\"><a href=\"#如何关闭服务\" class=\"headerlink\" title=\"如何关闭服务\"></a>如何关闭服务</h3><p>　　直接杀死相关进程即可</p>\n<pre><code>killall svnserve\n</code></pre><h2 id=\"客户端访问方式\"><a href=\"#客户端访问方式\" class=\"headerlink\" title=\"客户端访问方式\"></a>客户端访问方式</h2><pre><code>svn checkout svn://domain/project\n</code></pre><h2 id=\"可能出现的问题\"><a href=\"#可能出现的问题\" class=\"headerlink\" title=\"可能出现的问题\"></a>可能出现的问题</h2><h3 id=\"CentOS7下客户端无法访问\"><a href=\"#CentOS7下客户端无法访问\" class=\"headerlink\" title=\"CentOS7下客户端无法访问\"></a>CentOS7下客户端无法访问</h3><p>这是因为在CentOS7下，原先的iptables被替换了firewalld，所以对iptables的防火墙设置是没有用的。</p>\n<p>因此如果想要让3690端口（SVN服务器端口）对外开放的话，则需要对firewalld进行配置。</p>\n<pre><code>firewall-cmd --permanent --query-port=3690/tcp\n</code></pre><p>通过上述命令可以查看3690端口是否开放。</p>\n<pre><code>irewall-cmd --permanent --add-port=3690/tcp\n</code></pre><p>通过上述命令则可以添加开放端口。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>下文中PATH、PROJECT等全大写的字符串均为举例用，实际操作时请替换成自己的目录和版本库或项目名称等。</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><pre><code>yum install subversion\n</code></pre><p>等待一段时间完成svn的安装。</p>\n<p>##建立版本库的文件夹，并给与777的权限</p>\n<pre><code>mkdir PATH/svn\nchmod 777 -R PATH/svn\n</code></pre><h2 id=\"创建版本库\"><a href=\"#创建版本库\" class=\"headerlink\" title=\"创建版本库\"></a>创建版本库</h2><pre><code>svnadmin create PATH/svn/PROJECT\n</code></pre><h2 id=\"接下来对Svn进行配置\"><a href=\"#接下来对Svn进行配置\" class=\"headerlink\" title=\"接下来对Svn进行配置\"></a>接下来对Svn进行配置</h2><h3 id=\"配置svnserve-conf\"><a href=\"#配置svnserve-conf\" class=\"headerlink\" title=\"配置svnserve.conf\"></a>配置svnserve.conf</h3><pre><code>vi PATH/svn/PROJECT/conf/svnserve.conf\n</code></pre><p>将内容中注释掉的以下部分去掉#和空格，并将anon-access = read改为none：</p>\n<pre><code># anon-access = read\n# auth-access = write\n# password-db = passwd\n# authz-db = authz\n</code></pre><p>变成</p>\n<pre><code>anon-access = none\nauth-access = write\npassword-db = passwd\nauthz-db = authz\n</code></pre><h3 id=\"配置authz\"><a href=\"#配置authz\" class=\"headerlink\" title=\"配置authz\"></a>配置authz</h3><pre><code>vi PATH/svn/PROJECT/conf/authz\n</code></pre><p>　　在[group]下加入</p>\n<pre><code>YOUR_GROUP = USER1,USER2\n</code></pre><p>　　在# [/foo/bar]下加入</p>\n<pre><code>[/]\n@YOUR_GROUP=rw\n* = r\n</code></pre><h3 id=\"配置passwd\"><a href=\"#配置passwd\" class=\"headerlink\" title=\"配置passwd\"></a>配置passwd</h3><pre><code>vi PATH/svn/PROJECT/conf/passwd\n</code></pre><p>　　在[users]下加入</p>\n<pre><code>USER1=PASSWD1\nUSER2=PASSWD2\n</code></pre><h2 id=\"启动SVN服务\"><a href=\"#启动SVN服务\" class=\"headerlink\" title=\"启动SVN服务\"></a>启动SVN服务</h2><pre><code>svnserve -d -r PATH/svn/\n</code></pre><p>这里需要注意，这里设置的是svn服务器的根目录。在checkout的时候，以这个目录（PATH/svn/)作为起点，可以添加多个版本库，访问的时候则可以用“svn://域名/版本库名”来进行checkout。</p>\n<h3 id=\"如何关闭服务\"><a href=\"#如何关闭服务\" class=\"headerlink\" title=\"如何关闭服务\"></a>如何关闭服务</h3><p>　　直接杀死相关进程即可</p>\n<pre><code>killall svnserve\n</code></pre><h2 id=\"客户端访问方式\"><a href=\"#客户端访问方式\" class=\"headerlink\" title=\"客户端访问方式\"></a>客户端访问方式</h2><pre><code>svn checkout svn://domain/project\n</code></pre><h2 id=\"可能出现的问题\"><a href=\"#可能出现的问题\" class=\"headerlink\" title=\"可能出现的问题\"></a>可能出现的问题</h2><h3 id=\"CentOS7下客户端无法访问\"><a href=\"#CentOS7下客户端无法访问\" class=\"headerlink\" title=\"CentOS7下客户端无法访问\"></a>CentOS7下客户端无法访问</h3><p>这是因为在CentOS7下，原先的iptables被替换了firewalld，所以对iptables的防火墙设置是没有用的。</p>\n<p>因此如果想要让3690端口（SVN服务器端口）对外开放的话，则需要对firewalld进行配置。</p>\n<pre><code>firewall-cmd --permanent --query-port=3690/tcp\n</code></pre><p>通过上述命令可以查看3690端口是否开放。</p>\n<pre><code>irewall-cmd --permanent --add-port=3690/tcp\n</code></pre><p>通过上述命令则可以添加开放端口。</p>\n"},{"layout":"post","title":"深入浅出React读后笔记","date":"2016-04-24T10:36:56.000Z","_content":"## React的设计哲学\n\nReact最有价值的是声明式的，直观的编程方式。编程方式 简单直观 且 符合习惯，可以使得代码 更容易理解 、易于维护和有助于演进。可理解，可维护的代码代表着工程的质量和效率。\n \n## JSX定义用户界面更加直观\n\nJSX定义的用户界面使得HTML可以直接嵌入到JS中，而不使用模板。原因在于，模板背后的代码逻辑严重依赖其模板中的内容和DOM结构，两者紧密耦合。虽然模板可以使得文件分离，且让非开发人员也可以对界面进行修改，但是为了保证两者之间的协作，需要引入更多的概念和机制。\n\n而在JSX中，React并没有引入更多新的概念，你仍可以用HTML和JS的思路去构建自己的应用。这种直观的方式降低了React的学习门槛，也使得新手更容易理解。\n\n## 所谓组件，其实就是状态机器\n组件是某个独立功能或界面的封装（定义），使其能够进行复用或是业务逻辑分离（目的）。\n\n在React中，为了更加容易保证界面一致性，React把它看做简单的状态机器。即根据状态去输出基于状态的界面，React则负责以最高效的方式去更新整个界面和DOM树。\n\n对组件的管理，实际就是对组件状态的管理。更新一个组件，就是更新一个组件的状态。设计者需要做的，就是关心不同状态的用户界面。这相比于原始的JS直接控制真实DOM（过于自由）来说，预先设定好组件的状态对应的用户界面，可以让问题缩小到组件中，而不需要开发者考虑整一个应用的DOM或是担心新加入的代码可能会产生不被期望的副作用。像这样将DOM限制在组件之中，尽管失去了“自由”，但是也可以使得开发者更好的对界面进行管理和控制。\n\n组件作为用户界面的基本单位，与外界的交互方式除了状态（state）之外，还有其属性（props）。state由组件内部进行维护，而属性则是在外部初始化时传递进来，一旦赋值不建议进行变化。同一类组件就像是人一样，可以有着不同的身高和肤色（属性），但是其呼吸、运动等活动方式（状态）则是相通的。\n \n## 每一次变化都是整体刷新\n数据模型驱动用户界面在概念上是直观的，但是在实践中确实困难重重。数据模型的变化可能会导致分散在整个用户界面各个角落的UI同时进行变化。界面越复杂，数据与界面的一致性越难以维护。\n\n关于这个问题，在原文中并没有被解释的很清楚。所谓数据模型，是一个整体的、全局的数据，不同于AJAX获取那种局部的数据，数据模型代表了整个UI界面的状态。\n\n考虑一下实际的开发场景，当我们拿到一个新的数据之后，我们需要做哪些事情。首先是分析数据，在概念上明确我们需要更新的UI，接着拿新数据与UI进行对比（检查），判断哪些需要更新而哪些不需要变化。接下来是实际通过编码的方式更新UI，进行DOM操作，最后检查UI是否被正确的刷新。\n\n实际上在界面复杂并且有许多UI之间的依赖更新的情况下，开发者无法立刻得知当前的UI与之后刷新的UI是否一致。出于减少DOM操作的角度考虑，当然是只刷新那些有变化的UI就好。但是想要实现它，开发者必须对UI一一进行前后对比，界面越复杂越难以实现。而如果把涉及到的所有UI都进行更新，则会产生不必要的性能损耗（把一个UI删除了又产生一个同样的UI）。\n为此，React引入了虚拟DOM的概念。既然整体进行渲染（把所有涉及到的UI都进行刷新）一定可以保证数据模型与用户界面的一致性，那不如就整体进行刷新吧，让框架来解决哪些需要进行DOM操作而哪些UI则保持原样。React通过虚拟DOM把所有的现有UI的数据模型与新的数据模型进行一一的对比，最终进行最优化的局部真实DOM更新。虚拟DOM可以通过其算法获得不论界面多么复杂的情况下，都可以接受的性能代价。\n何时是React的最有价值的时候？当你的界面越来越复杂时。\n \n## 单向数据流动Flux\n\n既然已经有了组件机制去定义界面，那么也还需要一定的机制来定义组件之间，以及组件和数据模型之间如何通信。为此Facebook提出了Flux，其提倡的是单向数据流动。即永远只有模型到视图的数据流动。\n\nFlux的定义非常宽松，目前社区中还出现了很多不同的实现，如Flexible，Reflux等。\n \n## 让数据模型也变简单\n\nReact提倡只用只读数据来建立数据模型，所有的数据都是只读的，如果你想要进行修改，那么就只能产生一份包含新的修改的数据。这有点像同一个类的实例，其成员变量是私有的并且在实例化之后没有相关函数能够对其进行修改，如果想要进行修改，那么就只能重新实例一个。\n\n只读的数据可以让代码更加的安全和易于维护，至少开发者不用担心数据在某个角落被某段神奇的代码所修改。数据的来源只有数据出生的时候，这无疑可以抹杀很多bug出现的可能。\n \n## 其他\n\nReact Native：移动开发。React把UI层进行了完美的抽象使得开发者不需要进行DOM操作，而React Native正是把DOM替换成了iOS或Android的原声控件。其开发方式都是一致的。\n\nReact Canvas：所有的界面元素都通过Canvas来进行绘制，彻底舍弃了DOM。\n \n## 总结\n\n任何框架诞生的初衷都离不开对开发问题的解决。React同样是为了解决前端开发中的痛点而生。原文总结分析了其相关技术背后的设计思想，是一篇质量很高的文章。\n\n我一直坚信在计算机这样的人造学科中，理解一门技术的初衷，能够使自己更好的去学习和使用。很多人都可以在短时间入门一门技术，但是很少有人去关注其背后的设计思想和方式。尽管我现在技术基础不扎实，但是React的设计思路确确实实是我在实际开发中会遇到和疑惑的问题。这样一想，React就变得十分可爱了，我也期望自己能在实际的开发中，遵循简单直观的原则，进行高效率和高质量的开发。\n\n## 参考\n[深入浅出React（一）：React的设计哲学 - 简单之美](http://www.infoq.com/cn/articles/react-art-of-simplity)","source":"_posts/2016-04-24-深入浅出React读后笔记.markdown","raw":"---\nlayout: post\ntitle:  \"深入浅出React读后笔记\"\ndate:   2016-04-24 18:36:56 +0800\ncategories: React\n---\n## React的设计哲学\n\nReact最有价值的是声明式的，直观的编程方式。编程方式 简单直观 且 符合习惯，可以使得代码 更容易理解 、易于维护和有助于演进。可理解，可维护的代码代表着工程的质量和效率。\n \n## JSX定义用户界面更加直观\n\nJSX定义的用户界面使得HTML可以直接嵌入到JS中，而不使用模板。原因在于，模板背后的代码逻辑严重依赖其模板中的内容和DOM结构，两者紧密耦合。虽然模板可以使得文件分离，且让非开发人员也可以对界面进行修改，但是为了保证两者之间的协作，需要引入更多的概念和机制。\n\n而在JSX中，React并没有引入更多新的概念，你仍可以用HTML和JS的思路去构建自己的应用。这种直观的方式降低了React的学习门槛，也使得新手更容易理解。\n\n## 所谓组件，其实就是状态机器\n组件是某个独立功能或界面的封装（定义），使其能够进行复用或是业务逻辑分离（目的）。\n\n在React中，为了更加容易保证界面一致性，React把它看做简单的状态机器。即根据状态去输出基于状态的界面，React则负责以最高效的方式去更新整个界面和DOM树。\n\n对组件的管理，实际就是对组件状态的管理。更新一个组件，就是更新一个组件的状态。设计者需要做的，就是关心不同状态的用户界面。这相比于原始的JS直接控制真实DOM（过于自由）来说，预先设定好组件的状态对应的用户界面，可以让问题缩小到组件中，而不需要开发者考虑整一个应用的DOM或是担心新加入的代码可能会产生不被期望的副作用。像这样将DOM限制在组件之中，尽管失去了“自由”，但是也可以使得开发者更好的对界面进行管理和控制。\n\n组件作为用户界面的基本单位，与外界的交互方式除了状态（state）之外，还有其属性（props）。state由组件内部进行维护，而属性则是在外部初始化时传递进来，一旦赋值不建议进行变化。同一类组件就像是人一样，可以有着不同的身高和肤色（属性），但是其呼吸、运动等活动方式（状态）则是相通的。\n \n## 每一次变化都是整体刷新\n数据模型驱动用户界面在概念上是直观的，但是在实践中确实困难重重。数据模型的变化可能会导致分散在整个用户界面各个角落的UI同时进行变化。界面越复杂，数据与界面的一致性越难以维护。\n\n关于这个问题，在原文中并没有被解释的很清楚。所谓数据模型，是一个整体的、全局的数据，不同于AJAX获取那种局部的数据，数据模型代表了整个UI界面的状态。\n\n考虑一下实际的开发场景，当我们拿到一个新的数据之后，我们需要做哪些事情。首先是分析数据，在概念上明确我们需要更新的UI，接着拿新数据与UI进行对比（检查），判断哪些需要更新而哪些不需要变化。接下来是实际通过编码的方式更新UI，进行DOM操作，最后检查UI是否被正确的刷新。\n\n实际上在界面复杂并且有许多UI之间的依赖更新的情况下，开发者无法立刻得知当前的UI与之后刷新的UI是否一致。出于减少DOM操作的角度考虑，当然是只刷新那些有变化的UI就好。但是想要实现它，开发者必须对UI一一进行前后对比，界面越复杂越难以实现。而如果把涉及到的所有UI都进行更新，则会产生不必要的性能损耗（把一个UI删除了又产生一个同样的UI）。\n为此，React引入了虚拟DOM的概念。既然整体进行渲染（把所有涉及到的UI都进行刷新）一定可以保证数据模型与用户界面的一致性，那不如就整体进行刷新吧，让框架来解决哪些需要进行DOM操作而哪些UI则保持原样。React通过虚拟DOM把所有的现有UI的数据模型与新的数据模型进行一一的对比，最终进行最优化的局部真实DOM更新。虚拟DOM可以通过其算法获得不论界面多么复杂的情况下，都可以接受的性能代价。\n何时是React的最有价值的时候？当你的界面越来越复杂时。\n \n## 单向数据流动Flux\n\n既然已经有了组件机制去定义界面，那么也还需要一定的机制来定义组件之间，以及组件和数据模型之间如何通信。为此Facebook提出了Flux，其提倡的是单向数据流动。即永远只有模型到视图的数据流动。\n\nFlux的定义非常宽松，目前社区中还出现了很多不同的实现，如Flexible，Reflux等。\n \n## 让数据模型也变简单\n\nReact提倡只用只读数据来建立数据模型，所有的数据都是只读的，如果你想要进行修改，那么就只能产生一份包含新的修改的数据。这有点像同一个类的实例，其成员变量是私有的并且在实例化之后没有相关函数能够对其进行修改，如果想要进行修改，那么就只能重新实例一个。\n\n只读的数据可以让代码更加的安全和易于维护，至少开发者不用担心数据在某个角落被某段神奇的代码所修改。数据的来源只有数据出生的时候，这无疑可以抹杀很多bug出现的可能。\n \n## 其他\n\nReact Native：移动开发。React把UI层进行了完美的抽象使得开发者不需要进行DOM操作，而React Native正是把DOM替换成了iOS或Android的原声控件。其开发方式都是一致的。\n\nReact Canvas：所有的界面元素都通过Canvas来进行绘制，彻底舍弃了DOM。\n \n## 总结\n\n任何框架诞生的初衷都离不开对开发问题的解决。React同样是为了解决前端开发中的痛点而生。原文总结分析了其相关技术背后的设计思想，是一篇质量很高的文章。\n\n我一直坚信在计算机这样的人造学科中，理解一门技术的初衷，能够使自己更好的去学习和使用。很多人都可以在短时间入门一门技术，但是很少有人去关注其背后的设计思想和方式。尽管我现在技术基础不扎实，但是React的设计思路确确实实是我在实际开发中会遇到和疑惑的问题。这样一想，React就变得十分可爱了，我也期望自己能在实际的开发中，遵循简单直观的原则，进行高效率和高质量的开发。\n\n## 参考\n[深入浅出React（一）：React的设计哲学 - 简单之美](http://www.infoq.com/cn/articles/react-art-of-simplity)","slug":"2016-04-24-深入浅出React读后笔记","published":1,"updated":"2017-07-30T15:21:36.000Z","comments":1,"photos":[],"link":"","_id":"cj5qx2mla0003b4orkvmaedpm","content":"<h2 id=\"React的设计哲学\"><a href=\"#React的设计哲学\" class=\"headerlink\" title=\"React的设计哲学\"></a>React的设计哲学</h2><p>React最有价值的是声明式的，直观的编程方式。编程方式 简单直观 且 符合习惯，可以使得代码 更容易理解 、易于维护和有助于演进。可理解，可维护的代码代表着工程的质量和效率。</p>\n<h2 id=\"JSX定义用户界面更加直观\"><a href=\"#JSX定义用户界面更加直观\" class=\"headerlink\" title=\"JSX定义用户界面更加直观\"></a>JSX定义用户界面更加直观</h2><p>JSX定义的用户界面使得HTML可以直接嵌入到JS中，而不使用模板。原因在于，模板背后的代码逻辑严重依赖其模板中的内容和DOM结构，两者紧密耦合。虽然模板可以使得文件分离，且让非开发人员也可以对界面进行修改，但是为了保证两者之间的协作，需要引入更多的概念和机制。</p>\n<p>而在JSX中，React并没有引入更多新的概念，你仍可以用HTML和JS的思路去构建自己的应用。这种直观的方式降低了React的学习门槛，也使得新手更容易理解。</p>\n<h2 id=\"所谓组件，其实就是状态机器\"><a href=\"#所谓组件，其实就是状态机器\" class=\"headerlink\" title=\"所谓组件，其实就是状态机器\"></a>所谓组件，其实就是状态机器</h2><p>组件是某个独立功能或界面的封装（定义），使其能够进行复用或是业务逻辑分离（目的）。</p>\n<p>在React中，为了更加容易保证界面一致性，React把它看做简单的状态机器。即根据状态去输出基于状态的界面，React则负责以最高效的方式去更新整个界面和DOM树。</p>\n<p>对组件的管理，实际就是对组件状态的管理。更新一个组件，就是更新一个组件的状态。设计者需要做的，就是关心不同状态的用户界面。这相比于原始的JS直接控制真实DOM（过于自由）来说，预先设定好组件的状态对应的用户界面，可以让问题缩小到组件中，而不需要开发者考虑整一个应用的DOM或是担心新加入的代码可能会产生不被期望的副作用。像这样将DOM限制在组件之中，尽管失去了“自由”，但是也可以使得开发者更好的对界面进行管理和控制。</p>\n<p>组件作为用户界面的基本单位，与外界的交互方式除了状态（state）之外，还有其属性（props）。state由组件内部进行维护，而属性则是在外部初始化时传递进来，一旦赋值不建议进行变化。同一类组件就像是人一样，可以有着不同的身高和肤色（属性），但是其呼吸、运动等活动方式（状态）则是相通的。</p>\n<h2 id=\"每一次变化都是整体刷新\"><a href=\"#每一次变化都是整体刷新\" class=\"headerlink\" title=\"每一次变化都是整体刷新\"></a>每一次变化都是整体刷新</h2><p>数据模型驱动用户界面在概念上是直观的，但是在实践中确实困难重重。数据模型的变化可能会导致分散在整个用户界面各个角落的UI同时进行变化。界面越复杂，数据与界面的一致性越难以维护。</p>\n<p>关于这个问题，在原文中并没有被解释的很清楚。所谓数据模型，是一个整体的、全局的数据，不同于AJAX获取那种局部的数据，数据模型代表了整个UI界面的状态。</p>\n<p>考虑一下实际的开发场景，当我们拿到一个新的数据之后，我们需要做哪些事情。首先是分析数据，在概念上明确我们需要更新的UI，接着拿新数据与UI进行对比（检查），判断哪些需要更新而哪些不需要变化。接下来是实际通过编码的方式更新UI，进行DOM操作，最后检查UI是否被正确的刷新。</p>\n<p>实际上在界面复杂并且有许多UI之间的依赖更新的情况下，开发者无法立刻得知当前的UI与之后刷新的UI是否一致。出于减少DOM操作的角度考虑，当然是只刷新那些有变化的UI就好。但是想要实现它，开发者必须对UI一一进行前后对比，界面越复杂越难以实现。而如果把涉及到的所有UI都进行更新，则会产生不必要的性能损耗（把一个UI删除了又产生一个同样的UI）。<br>为此，React引入了虚拟DOM的概念。既然整体进行渲染（把所有涉及到的UI都进行刷新）一定可以保证数据模型与用户界面的一致性，那不如就整体进行刷新吧，让框架来解决哪些需要进行DOM操作而哪些UI则保持原样。React通过虚拟DOM把所有的现有UI的数据模型与新的数据模型进行一一的对比，最终进行最优化的局部真实DOM更新。虚拟DOM可以通过其算法获得不论界面多么复杂的情况下，都可以接受的性能代价。<br>何时是React的最有价值的时候？当你的界面越来越复杂时。</p>\n<h2 id=\"单向数据流动Flux\"><a href=\"#单向数据流动Flux\" class=\"headerlink\" title=\"单向数据流动Flux\"></a>单向数据流动Flux</h2><p>既然已经有了组件机制去定义界面，那么也还需要一定的机制来定义组件之间，以及组件和数据模型之间如何通信。为此Facebook提出了Flux，其提倡的是单向数据流动。即永远只有模型到视图的数据流动。</p>\n<p>Flux的定义非常宽松，目前社区中还出现了很多不同的实现，如Flexible，Reflux等。</p>\n<h2 id=\"让数据模型也变简单\"><a href=\"#让数据模型也变简单\" class=\"headerlink\" title=\"让数据模型也变简单\"></a>让数据模型也变简单</h2><p>React提倡只用只读数据来建立数据模型，所有的数据都是只读的，如果你想要进行修改，那么就只能产生一份包含新的修改的数据。这有点像同一个类的实例，其成员变量是私有的并且在实例化之后没有相关函数能够对其进行修改，如果想要进行修改，那么就只能重新实例一个。</p>\n<p>只读的数据可以让代码更加的安全和易于维护，至少开发者不用担心数据在某个角落被某段神奇的代码所修改。数据的来源只有数据出生的时候，这无疑可以抹杀很多bug出现的可能。</p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>React Native：移动开发。React把UI层进行了完美的抽象使得开发者不需要进行DOM操作，而React Native正是把DOM替换成了iOS或Android的原声控件。其开发方式都是一致的。</p>\n<p>React Canvas：所有的界面元素都通过Canvas来进行绘制，彻底舍弃了DOM。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>任何框架诞生的初衷都离不开对开发问题的解决。React同样是为了解决前端开发中的痛点而生。原文总结分析了其相关技术背后的设计思想，是一篇质量很高的文章。</p>\n<p>我一直坚信在计算机这样的人造学科中，理解一门技术的初衷，能够使自己更好的去学习和使用。很多人都可以在短时间入门一门技术，但是很少有人去关注其背后的设计思想和方式。尽管我现在技术基础不扎实，但是React的设计思路确确实实是我在实际开发中会遇到和疑惑的问题。这样一想，React就变得十分可爱了，我也期望自己能在实际的开发中，遵循简单直观的原则，进行高效率和高质量的开发。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://www.infoq.com/cn/articles/react-art-of-simplity\" target=\"_blank\" rel=\"external\">深入浅出React（一）：React的设计哲学 - 简单之美</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"React的设计哲学\"><a href=\"#React的设计哲学\" class=\"headerlink\" title=\"React的设计哲学\"></a>React的设计哲学</h2><p>React最有价值的是声明式的，直观的编程方式。编程方式 简单直观 且 符合习惯，可以使得代码 更容易理解 、易于维护和有助于演进。可理解，可维护的代码代表着工程的质量和效率。</p>\n<h2 id=\"JSX定义用户界面更加直观\"><a href=\"#JSX定义用户界面更加直观\" class=\"headerlink\" title=\"JSX定义用户界面更加直观\"></a>JSX定义用户界面更加直观</h2><p>JSX定义的用户界面使得HTML可以直接嵌入到JS中，而不使用模板。原因在于，模板背后的代码逻辑严重依赖其模板中的内容和DOM结构，两者紧密耦合。虽然模板可以使得文件分离，且让非开发人员也可以对界面进行修改，但是为了保证两者之间的协作，需要引入更多的概念和机制。</p>\n<p>而在JSX中，React并没有引入更多新的概念，你仍可以用HTML和JS的思路去构建自己的应用。这种直观的方式降低了React的学习门槛，也使得新手更容易理解。</p>\n<h2 id=\"所谓组件，其实就是状态机器\"><a href=\"#所谓组件，其实就是状态机器\" class=\"headerlink\" title=\"所谓组件，其实就是状态机器\"></a>所谓组件，其实就是状态机器</h2><p>组件是某个独立功能或界面的封装（定义），使其能够进行复用或是业务逻辑分离（目的）。</p>\n<p>在React中，为了更加容易保证界面一致性，React把它看做简单的状态机器。即根据状态去输出基于状态的界面，React则负责以最高效的方式去更新整个界面和DOM树。</p>\n<p>对组件的管理，实际就是对组件状态的管理。更新一个组件，就是更新一个组件的状态。设计者需要做的，就是关心不同状态的用户界面。这相比于原始的JS直接控制真实DOM（过于自由）来说，预先设定好组件的状态对应的用户界面，可以让问题缩小到组件中，而不需要开发者考虑整一个应用的DOM或是担心新加入的代码可能会产生不被期望的副作用。像这样将DOM限制在组件之中，尽管失去了“自由”，但是也可以使得开发者更好的对界面进行管理和控制。</p>\n<p>组件作为用户界面的基本单位，与外界的交互方式除了状态（state）之外，还有其属性（props）。state由组件内部进行维护，而属性则是在外部初始化时传递进来，一旦赋值不建议进行变化。同一类组件就像是人一样，可以有着不同的身高和肤色（属性），但是其呼吸、运动等活动方式（状态）则是相通的。</p>\n<h2 id=\"每一次变化都是整体刷新\"><a href=\"#每一次变化都是整体刷新\" class=\"headerlink\" title=\"每一次变化都是整体刷新\"></a>每一次变化都是整体刷新</h2><p>数据模型驱动用户界面在概念上是直观的，但是在实践中确实困难重重。数据模型的变化可能会导致分散在整个用户界面各个角落的UI同时进行变化。界面越复杂，数据与界面的一致性越难以维护。</p>\n<p>关于这个问题，在原文中并没有被解释的很清楚。所谓数据模型，是一个整体的、全局的数据，不同于AJAX获取那种局部的数据，数据模型代表了整个UI界面的状态。</p>\n<p>考虑一下实际的开发场景，当我们拿到一个新的数据之后，我们需要做哪些事情。首先是分析数据，在概念上明确我们需要更新的UI，接着拿新数据与UI进行对比（检查），判断哪些需要更新而哪些不需要变化。接下来是实际通过编码的方式更新UI，进行DOM操作，最后检查UI是否被正确的刷新。</p>\n<p>实际上在界面复杂并且有许多UI之间的依赖更新的情况下，开发者无法立刻得知当前的UI与之后刷新的UI是否一致。出于减少DOM操作的角度考虑，当然是只刷新那些有变化的UI就好。但是想要实现它，开发者必须对UI一一进行前后对比，界面越复杂越难以实现。而如果把涉及到的所有UI都进行更新，则会产生不必要的性能损耗（把一个UI删除了又产生一个同样的UI）。<br>为此，React引入了虚拟DOM的概念。既然整体进行渲染（把所有涉及到的UI都进行刷新）一定可以保证数据模型与用户界面的一致性，那不如就整体进行刷新吧，让框架来解决哪些需要进行DOM操作而哪些UI则保持原样。React通过虚拟DOM把所有的现有UI的数据模型与新的数据模型进行一一的对比，最终进行最优化的局部真实DOM更新。虚拟DOM可以通过其算法获得不论界面多么复杂的情况下，都可以接受的性能代价。<br>何时是React的最有价值的时候？当你的界面越来越复杂时。</p>\n<h2 id=\"单向数据流动Flux\"><a href=\"#单向数据流动Flux\" class=\"headerlink\" title=\"单向数据流动Flux\"></a>单向数据流动Flux</h2><p>既然已经有了组件机制去定义界面，那么也还需要一定的机制来定义组件之间，以及组件和数据模型之间如何通信。为此Facebook提出了Flux，其提倡的是单向数据流动。即永远只有模型到视图的数据流动。</p>\n<p>Flux的定义非常宽松，目前社区中还出现了很多不同的实现，如Flexible，Reflux等。</p>\n<h2 id=\"让数据模型也变简单\"><a href=\"#让数据模型也变简单\" class=\"headerlink\" title=\"让数据模型也变简单\"></a>让数据模型也变简单</h2><p>React提倡只用只读数据来建立数据模型，所有的数据都是只读的，如果你想要进行修改，那么就只能产生一份包含新的修改的数据。这有点像同一个类的实例，其成员变量是私有的并且在实例化之后没有相关函数能够对其进行修改，如果想要进行修改，那么就只能重新实例一个。</p>\n<p>只读的数据可以让代码更加的安全和易于维护，至少开发者不用担心数据在某个角落被某段神奇的代码所修改。数据的来源只有数据出生的时候，这无疑可以抹杀很多bug出现的可能。</p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>React Native：移动开发。React把UI层进行了完美的抽象使得开发者不需要进行DOM操作，而React Native正是把DOM替换成了iOS或Android的原声控件。其开发方式都是一致的。</p>\n<p>React Canvas：所有的界面元素都通过Canvas来进行绘制，彻底舍弃了DOM。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>任何框架诞生的初衷都离不开对开发问题的解决。React同样是为了解决前端开发中的痛点而生。原文总结分析了其相关技术背后的设计思想，是一篇质量很高的文章。</p>\n<p>我一直坚信在计算机这样的人造学科中，理解一门技术的初衷，能够使自己更好的去学习和使用。很多人都可以在短时间入门一门技术，但是很少有人去关注其背后的设计思想和方式。尽管我现在技术基础不扎实，但是React的设计思路确确实实是我在实际开发中会遇到和疑惑的问题。这样一想，React就变得十分可爱了，我也期望自己能在实际的开发中，遵循简单直观的原则，进行高效率和高质量的开发。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://www.infoq.com/cn/articles/react-art-of-simplity\" target=\"_blank\" rel=\"external\">深入浅出React（一）：React的设计哲学 - 简单之美</a></p>\n"},{"layout":"post","title":"Git：那些常用命令的整理","date":"2017-01-30T14:45:14.000Z","_content":"Git是一个分布式版本控制系统，相比集中式的版本控制系统，分布式版本控制系统每个人手上都是一个完整的版本库。\n\n## 创建版本库\n\n    git init\n\n初始化一个git仓库。\n\n    git add <file>\n\n添加文件到暂存区。\n\n    git commit -m \"message\"\n\n把之前`git add`的文件提交到仓库，可以add多个文件，然后执行一次commit。\n\n> SVN上`add`之后直接就添加到版本库了，但是Git上还需要`commit`才行，注意SVN与Git之间`commit`与`add`的异同。\n\n## 查看版本库的状态\n\n    git status\n\n查看当前工作区的状态。\n\n    git diff\n\n查看difference，显示的格式是Unix通用的diff格式。\n\n> 简单来说`git status`命令可以知道哪些文件做了修改，`git diff`命令可以知道被修改了哪些内容。\n\n    git log\n    git log --pretty=oneline\n\n显示从最近到最远的提交日志。\n\n> `commit id`是版本号，用 SHA1 十六进制表示\n\n## 版本回退\n\n    git reset --hard HEAD^\n    git reset --hard HEAD~100\n    git reset --hard 3628164\n\n`HEAD`表示当前版本，`HEAD^`表示当前版本的上一个版本，`~100`等同于100个`^`。`3628164`是版本号，版本号不用写全，Git中只要知道`commit id`就可以回退。\n\n    git reflog\n\n查看历史命令，通过历史命令可以知道版本号。\n\n> 需要提交的文件通通使用`git add`放到暂存区（stage），然后使用`git commit`一次性提交暂存区所有修改到分之。工作区（working diretory）是电脑里能看到的目录，版本库（repository）则是工作区中一个隐藏的文件夹`.git`。\ngit跟踪并管理的是修改，每次修改都需要`add`到暂存区，这样才能被`commit`到分支中。\n\n## 管理修改\n\n    git checkout --file\n\n把file在工作区的修改全部撤销，也就是把这个文件回到最近一次`git commit`或者`git add`的状态（用版本库的版本替换工作区）。\n\n    git reset HEAD file\n\n把暂存区的修改回退到工作区，不会影响工作区的状态。\n\n    git rm file\n\n从版本库中删除某个文件。这个命令跟`git add`一样，需要`git commit`之后才能提交到版本库中。\n\n## 分支管理\n\n### 创建分支\n\n    git checkout -b dev\n\n创建并切换到dev分支，`-b`参数表示**创建并切换**，这个命令实际上是下面两个命令的结合。\n\n    git branch dev\n    git checkout dev \n`git branch`是创建一个dev分支，`git checkout`则是切换到dev分支。\n\n    git branch\n\n查看当前分支，当前分支会标有一个*号。\n\n    git checkout master\n\n切换到master分支。\n\n    git merge dev\n\n合并指定分支到当前分支。\n\n    git branch -d dev\n\n删除指定分支。\n\n### 解决冲突\n\n当切换到master分支并尝试合并dev分支时，若有冲突存在，必须手动解决冲突再进行提交。\n\nGit用<<<<<<，======，>>>>>>标记处不同分支的内容。\n\n    git log --graph --pretty=oneline --abbrev-commit\n\n用带参数的`git log`命令可以看到分支的合并情况。\n\n> 当Git无法自动合并分支时，必须首先解决冲突，再提交。合并后用`git log --graph`可以看到分支合并图。\n\n### 分支管理策略\n\n默认情况下，Git会用`Fast forward`模式合并分支，但这种情况下，删除分支会丢掉分支信息，会看不出来曾经做过合并\n\n    git merge --no-ff -m \"message\" dev\n\n本次合并会创建一个新的commit，通过`-m`把commit描述写进去，`--no-ff`表示禁用`Fast forward`。\n\n> `master`一般是最稳定的版本，用来发布新版本。\n建立以个`dev`分支来进行协作，每个人都在`dev`分支上写代码，时不时向`dev`分支上提交，dev提交到`master`上来发布稳定版本。\n\n### Bug分支\n\n    git stash\n\n可以把当前工作区存起来，等以后恢复现场继续工作。执行完后，工作区是clean的，可以拿来创建分支。\n\n    git checkout master\n    git checkout -b issue-101\n\n创建`issue-101`分支并修复Bug。\n\n    git stash list\n\n查看保存的工作区。\n\n    git stash apply\n\n恢复指定工作区。\n\n    git stash drop\n\n删除stash。\n\n    git stash pop\n\n恢复的同时会删除stash的内容。\n\n## 配置\ngit config 命令用来设置git的一些基本设置，包括全局配置以及针对特定仓库的配置。\n### 使用方法\n#### 设置名字\n    git config user.name <name>\n\n设置当前仓库`commit`时作者的名字。\n\n    git config --global user.name <name>\n\n设置全局的作者名字，这样以后其他仓库`commit`时，都会以这个名字提交。\n#### 设置邮箱\n    git config --global user.email <email>\n\n设置全局的作者邮箱。\n\n例子：\n\n    git config --global user.name \"denight\"\n    git config --global user.email denight@qq.com\n\n#### 设置简写/别名\n    git config --global alias.<alias-name> <git-comman>\n    \n\n设置git命令的简写。比如`git status`可以通过下面的命令简写为`git st`。\n\n    git config --global alias.st status\n\n### 更多\nGit把配置文件存储在三个不同的文件中，一个作用于当前仓库，一个作用于当前用户，一个作用于整个系统。\n\n - <repo>/.git/config 当前仓库的配置\n - ~/.gitconfig 当前用户所属的配置，即---global的配置\n - $(prefix)/etc/gitconfig 系统级别的配置\n\n优先级从高到底。\n","source":"_posts/2017-01-03-Git：常用命令整理.markdown","raw":"---\nlayout: post\ntitle:  \"Git：那些常用命令的整理\"\ndate:   2017-01-30 22:45:14 +0800\ncategories: Git\n---\nGit是一个分布式版本控制系统，相比集中式的版本控制系统，分布式版本控制系统每个人手上都是一个完整的版本库。\n\n## 创建版本库\n\n    git init\n\n初始化一个git仓库。\n\n    git add <file>\n\n添加文件到暂存区。\n\n    git commit -m \"message\"\n\n把之前`git add`的文件提交到仓库，可以add多个文件，然后执行一次commit。\n\n> SVN上`add`之后直接就添加到版本库了，但是Git上还需要`commit`才行，注意SVN与Git之间`commit`与`add`的异同。\n\n## 查看版本库的状态\n\n    git status\n\n查看当前工作区的状态。\n\n    git diff\n\n查看difference，显示的格式是Unix通用的diff格式。\n\n> 简单来说`git status`命令可以知道哪些文件做了修改，`git diff`命令可以知道被修改了哪些内容。\n\n    git log\n    git log --pretty=oneline\n\n显示从最近到最远的提交日志。\n\n> `commit id`是版本号，用 SHA1 十六进制表示\n\n## 版本回退\n\n    git reset --hard HEAD^\n    git reset --hard HEAD~100\n    git reset --hard 3628164\n\n`HEAD`表示当前版本，`HEAD^`表示当前版本的上一个版本，`~100`等同于100个`^`。`3628164`是版本号，版本号不用写全，Git中只要知道`commit id`就可以回退。\n\n    git reflog\n\n查看历史命令，通过历史命令可以知道版本号。\n\n> 需要提交的文件通通使用`git add`放到暂存区（stage），然后使用`git commit`一次性提交暂存区所有修改到分之。工作区（working diretory）是电脑里能看到的目录，版本库（repository）则是工作区中一个隐藏的文件夹`.git`。\ngit跟踪并管理的是修改，每次修改都需要`add`到暂存区，这样才能被`commit`到分支中。\n\n## 管理修改\n\n    git checkout --file\n\n把file在工作区的修改全部撤销，也就是把这个文件回到最近一次`git commit`或者`git add`的状态（用版本库的版本替换工作区）。\n\n    git reset HEAD file\n\n把暂存区的修改回退到工作区，不会影响工作区的状态。\n\n    git rm file\n\n从版本库中删除某个文件。这个命令跟`git add`一样，需要`git commit`之后才能提交到版本库中。\n\n## 分支管理\n\n### 创建分支\n\n    git checkout -b dev\n\n创建并切换到dev分支，`-b`参数表示**创建并切换**，这个命令实际上是下面两个命令的结合。\n\n    git branch dev\n    git checkout dev \n`git branch`是创建一个dev分支，`git checkout`则是切换到dev分支。\n\n    git branch\n\n查看当前分支，当前分支会标有一个*号。\n\n    git checkout master\n\n切换到master分支。\n\n    git merge dev\n\n合并指定分支到当前分支。\n\n    git branch -d dev\n\n删除指定分支。\n\n### 解决冲突\n\n当切换到master分支并尝试合并dev分支时，若有冲突存在，必须手动解决冲突再进行提交。\n\nGit用<<<<<<，======，>>>>>>标记处不同分支的内容。\n\n    git log --graph --pretty=oneline --abbrev-commit\n\n用带参数的`git log`命令可以看到分支的合并情况。\n\n> 当Git无法自动合并分支时，必须首先解决冲突，再提交。合并后用`git log --graph`可以看到分支合并图。\n\n### 分支管理策略\n\n默认情况下，Git会用`Fast forward`模式合并分支，但这种情况下，删除分支会丢掉分支信息，会看不出来曾经做过合并\n\n    git merge --no-ff -m \"message\" dev\n\n本次合并会创建一个新的commit，通过`-m`把commit描述写进去，`--no-ff`表示禁用`Fast forward`。\n\n> `master`一般是最稳定的版本，用来发布新版本。\n建立以个`dev`分支来进行协作，每个人都在`dev`分支上写代码，时不时向`dev`分支上提交，dev提交到`master`上来发布稳定版本。\n\n### Bug分支\n\n    git stash\n\n可以把当前工作区存起来，等以后恢复现场继续工作。执行完后，工作区是clean的，可以拿来创建分支。\n\n    git checkout master\n    git checkout -b issue-101\n\n创建`issue-101`分支并修复Bug。\n\n    git stash list\n\n查看保存的工作区。\n\n    git stash apply\n\n恢复指定工作区。\n\n    git stash drop\n\n删除stash。\n\n    git stash pop\n\n恢复的同时会删除stash的内容。\n\n## 配置\ngit config 命令用来设置git的一些基本设置，包括全局配置以及针对特定仓库的配置。\n### 使用方法\n#### 设置名字\n    git config user.name <name>\n\n设置当前仓库`commit`时作者的名字。\n\n    git config --global user.name <name>\n\n设置全局的作者名字，这样以后其他仓库`commit`时，都会以这个名字提交。\n#### 设置邮箱\n    git config --global user.email <email>\n\n设置全局的作者邮箱。\n\n例子：\n\n    git config --global user.name \"denight\"\n    git config --global user.email denight@qq.com\n\n#### 设置简写/别名\n    git config --global alias.<alias-name> <git-comman>\n    \n\n设置git命令的简写。比如`git status`可以通过下面的命令简写为`git st`。\n\n    git config --global alias.st status\n\n### 更多\nGit把配置文件存储在三个不同的文件中，一个作用于当前仓库，一个作用于当前用户，一个作用于整个系统。\n\n - <repo>/.git/config 当前仓库的配置\n - ~/.gitconfig 当前用户所属的配置，即---global的配置\n - $(prefix)/etc/gitconfig 系统级别的配置\n\n优先级从高到底。\n","slug":"2017-01-03-Git：常用命令整理","published":1,"updated":"2017-07-30T15:22:41.000Z","comments":1,"photos":[],"link":"","_id":"cj5qx2mla0004b4or8g5m76qf","content":"<p>Git是一个分布式版本控制系统，相比集中式的版本控制系统，分布式版本控制系统每个人手上都是一个完整的版本库。</p>\n<h2 id=\"创建版本库\"><a href=\"#创建版本库\" class=\"headerlink\" title=\"创建版本库\"></a>创建版本库</h2><pre><code>git init\n</code></pre><p>初始化一个git仓库。</p>\n<pre><code>git add &lt;file&gt;\n</code></pre><p>添加文件到暂存区。</p>\n<pre><code>git commit -m &quot;message&quot;\n</code></pre><p>把之前<code>git add</code>的文件提交到仓库，可以add多个文件，然后执行一次commit。</p>\n<blockquote>\n<p>SVN上<code>add</code>之后直接就添加到版本库了，但是Git上还需要<code>commit</code>才行，注意SVN与Git之间<code>commit</code>与<code>add</code>的异同。</p>\n</blockquote>\n<h2 id=\"查看版本库的状态\"><a href=\"#查看版本库的状态\" class=\"headerlink\" title=\"查看版本库的状态\"></a>查看版本库的状态</h2><pre><code>git status\n</code></pre><p>查看当前工作区的状态。</p>\n<pre><code>git diff\n</code></pre><p>查看difference，显示的格式是Unix通用的diff格式。</p>\n<blockquote>\n<p>简单来说<code>git status</code>命令可以知道哪些文件做了修改，<code>git diff</code>命令可以知道被修改了哪些内容。</p>\n</blockquote>\n<pre><code>git log\ngit log --pretty=oneline\n</code></pre><p>显示从最近到最远的提交日志。</p>\n<blockquote>\n<p><code>commit id</code>是版本号，用 SHA1 十六进制表示</p>\n</blockquote>\n<h2 id=\"版本回退\"><a href=\"#版本回退\" class=\"headerlink\" title=\"版本回退\"></a>版本回退</h2><pre><code>git reset --hard HEAD^\ngit reset --hard HEAD~100\ngit reset --hard 3628164\n</code></pre><p><code>HEAD</code>表示当前版本，<code>HEAD^</code>表示当前版本的上一个版本，<code>~100</code>等同于100个<code>^</code>。<code>3628164</code>是版本号，版本号不用写全，Git中只要知道<code>commit id</code>就可以回退。</p>\n<pre><code>git reflog\n</code></pre><p>查看历史命令，通过历史命令可以知道版本号。</p>\n<blockquote>\n<p>需要提交的文件通通使用<code>git add</code>放到暂存区（stage），然后使用<code>git commit</code>一次性提交暂存区所有修改到分之。工作区（working diretory）是电脑里能看到的目录，版本库（repository）则是工作区中一个隐藏的文件夹<code>.git</code>。<br>git跟踪并管理的是修改，每次修改都需要<code>add</code>到暂存区，这样才能被<code>commit</code>到分支中。</p>\n</blockquote>\n<h2 id=\"管理修改\"><a href=\"#管理修改\" class=\"headerlink\" title=\"管理修改\"></a>管理修改</h2><pre><code>git checkout --file\n</code></pre><p>把file在工作区的修改全部撤销，也就是把这个文件回到最近一次<code>git commit</code>或者<code>git add</code>的状态（用版本库的版本替换工作区）。</p>\n<pre><code>git reset HEAD file\n</code></pre><p>把暂存区的修改回退到工作区，不会影响工作区的状态。</p>\n<pre><code>git rm file\n</code></pre><p>从版本库中删除某个文件。这个命令跟<code>git add</code>一样，需要<code>git commit</code>之后才能提交到版本库中。</p>\n<h2 id=\"分支管理\"><a href=\"#分支管理\" class=\"headerlink\" title=\"分支管理\"></a>分支管理</h2><h3 id=\"创建分支\"><a href=\"#创建分支\" class=\"headerlink\" title=\"创建分支\"></a>创建分支</h3><pre><code>git checkout -b dev\n</code></pre><p>创建并切换到dev分支，<code>-b</code>参数表示<strong>创建并切换</strong>，这个命令实际上是下面两个命令的结合。</p>\n<pre><code>git branch dev\ngit checkout dev \n</code></pre><p><code>git branch</code>是创建一个dev分支，<code>git checkout</code>则是切换到dev分支。</p>\n<pre><code>git branch\n</code></pre><p>查看当前分支，当前分支会标有一个*号。</p>\n<pre><code>git checkout master\n</code></pre><p>切换到master分支。</p>\n<pre><code>git merge dev\n</code></pre><p>合并指定分支到当前分支。</p>\n<pre><code>git branch -d dev\n</code></pre><p>删除指定分支。</p>\n<h3 id=\"解决冲突\"><a href=\"#解决冲突\" class=\"headerlink\" title=\"解决冲突\"></a>解决冲突</h3><p>当切换到master分支并尝试合并dev分支时，若有冲突存在，必须手动解决冲突再进行提交。</p>\n<p>Git用&lt;&lt;&lt;&lt;&lt;&lt;，======，&gt;&gt;&gt;&gt;&gt;&gt;标记处不同分支的内容。</p>\n<pre><code>git log --graph --pretty=oneline --abbrev-commit\n</code></pre><p>用带参数的<code>git log</code>命令可以看到分支的合并情况。</p>\n<blockquote>\n<p>当Git无法自动合并分支时，必须首先解决冲突，再提交。合并后用<code>git log --graph</code>可以看到分支合并图。</p>\n</blockquote>\n<h3 id=\"分支管理策略\"><a href=\"#分支管理策略\" class=\"headerlink\" title=\"分支管理策略\"></a>分支管理策略</h3><p>默认情况下，Git会用<code>Fast forward</code>模式合并分支，但这种情况下，删除分支会丢掉分支信息，会看不出来曾经做过合并</p>\n<pre><code>git merge --no-ff -m &quot;message&quot; dev\n</code></pre><p>本次合并会创建一个新的commit，通过<code>-m</code>把commit描述写进去，<code>--no-ff</code>表示禁用<code>Fast forward</code>。</p>\n<blockquote>\n<p><code>master</code>一般是最稳定的版本，用来发布新版本。<br>建立以个<code>dev</code>分支来进行协作，每个人都在<code>dev</code>分支上写代码，时不时向<code>dev</code>分支上提交，dev提交到<code>master</code>上来发布稳定版本。</p>\n</blockquote>\n<h3 id=\"Bug分支\"><a href=\"#Bug分支\" class=\"headerlink\" title=\"Bug分支\"></a>Bug分支</h3><pre><code>git stash\n</code></pre><p>可以把当前工作区存起来，等以后恢复现场继续工作。执行完后，工作区是clean的，可以拿来创建分支。</p>\n<pre><code>git checkout master\ngit checkout -b issue-101\n</code></pre><p>创建<code>issue-101</code>分支并修复Bug。</p>\n<pre><code>git stash list\n</code></pre><p>查看保存的工作区。</p>\n<pre><code>git stash apply\n</code></pre><p>恢复指定工作区。</p>\n<pre><code>git stash drop\n</code></pre><p>删除stash。</p>\n<pre><code>git stash pop\n</code></pre><p>恢复的同时会删除stash的内容。</p>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><p>git config 命令用来设置git的一些基本设置，包括全局配置以及针对特定仓库的配置。</p>\n<h3 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h3><h4 id=\"设置名字\"><a href=\"#设置名字\" class=\"headerlink\" title=\"设置名字\"></a>设置名字</h4><pre><code>git config user.name &lt;name&gt;\n</code></pre><p>设置当前仓库<code>commit</code>时作者的名字。</p>\n<pre><code>git config --global user.name &lt;name&gt;\n</code></pre><p>设置全局的作者名字，这样以后其他仓库<code>commit</code>时，都会以这个名字提交。</p>\n<h4 id=\"设置邮箱\"><a href=\"#设置邮箱\" class=\"headerlink\" title=\"设置邮箱\"></a>设置邮箱</h4><pre><code>git config --global user.email &lt;email&gt;\n</code></pre><p>设置全局的作者邮箱。</p>\n<p>例子：</p>\n<pre><code>git config --global user.name &quot;denight&quot;\ngit config --global user.email denight@qq.com\n</code></pre><h4 id=\"设置简写-别名\"><a href=\"#设置简写-别名\" class=\"headerlink\" title=\"设置简写/别名\"></a>设置简写/别名</h4><pre><code>git config --global alias.&lt;alias-name&gt; &lt;git-comman&gt;\n</code></pre><p>设置git命令的简写。比如<code>git status</code>可以通过下面的命令简写为<code>git st</code>。</p>\n<pre><code>git config --global alias.st status\n</code></pre><h3 id=\"更多\"><a href=\"#更多\" class=\"headerlink\" title=\"更多\"></a>更多</h3><p>Git把配置文件存储在三个不同的文件中，一个作用于当前仓库，一个作用于当前用户，一个作用于整个系统。</p>\n<ul>\n<li><repo>/.git/config 当前仓库的配置</repo></li>\n<li>~/.gitconfig 当前用户所属的配置，即—global的配置</li>\n<li>$(prefix)/etc/gitconfig 系统级别的配置</li>\n</ul>\n<p>优先级从高到底。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Git是一个分布式版本控制系统，相比集中式的版本控制系统，分布式版本控制系统每个人手上都是一个完整的版本库。</p>\n<h2 id=\"创建版本库\"><a href=\"#创建版本库\" class=\"headerlink\" title=\"创建版本库\"></a>创建版本库</h2><pre><code>git init\n</code></pre><p>初始化一个git仓库。</p>\n<pre><code>git add &lt;file&gt;\n</code></pre><p>添加文件到暂存区。</p>\n<pre><code>git commit -m &quot;message&quot;\n</code></pre><p>把之前<code>git add</code>的文件提交到仓库，可以add多个文件，然后执行一次commit。</p>\n<blockquote>\n<p>SVN上<code>add</code>之后直接就添加到版本库了，但是Git上还需要<code>commit</code>才行，注意SVN与Git之间<code>commit</code>与<code>add</code>的异同。</p>\n</blockquote>\n<h2 id=\"查看版本库的状态\"><a href=\"#查看版本库的状态\" class=\"headerlink\" title=\"查看版本库的状态\"></a>查看版本库的状态</h2><pre><code>git status\n</code></pre><p>查看当前工作区的状态。</p>\n<pre><code>git diff\n</code></pre><p>查看difference，显示的格式是Unix通用的diff格式。</p>\n<blockquote>\n<p>简单来说<code>git status</code>命令可以知道哪些文件做了修改，<code>git diff</code>命令可以知道被修改了哪些内容。</p>\n</blockquote>\n<pre><code>git log\ngit log --pretty=oneline\n</code></pre><p>显示从最近到最远的提交日志。</p>\n<blockquote>\n<p><code>commit id</code>是版本号，用 SHA1 十六进制表示</p>\n</blockquote>\n<h2 id=\"版本回退\"><a href=\"#版本回退\" class=\"headerlink\" title=\"版本回退\"></a>版本回退</h2><pre><code>git reset --hard HEAD^\ngit reset --hard HEAD~100\ngit reset --hard 3628164\n</code></pre><p><code>HEAD</code>表示当前版本，<code>HEAD^</code>表示当前版本的上一个版本，<code>~100</code>等同于100个<code>^</code>。<code>3628164</code>是版本号，版本号不用写全，Git中只要知道<code>commit id</code>就可以回退。</p>\n<pre><code>git reflog\n</code></pre><p>查看历史命令，通过历史命令可以知道版本号。</p>\n<blockquote>\n<p>需要提交的文件通通使用<code>git add</code>放到暂存区（stage），然后使用<code>git commit</code>一次性提交暂存区所有修改到分之。工作区（working diretory）是电脑里能看到的目录，版本库（repository）则是工作区中一个隐藏的文件夹<code>.git</code>。<br>git跟踪并管理的是修改，每次修改都需要<code>add</code>到暂存区，这样才能被<code>commit</code>到分支中。</p>\n</blockquote>\n<h2 id=\"管理修改\"><a href=\"#管理修改\" class=\"headerlink\" title=\"管理修改\"></a>管理修改</h2><pre><code>git checkout --file\n</code></pre><p>把file在工作区的修改全部撤销，也就是把这个文件回到最近一次<code>git commit</code>或者<code>git add</code>的状态（用版本库的版本替换工作区）。</p>\n<pre><code>git reset HEAD file\n</code></pre><p>把暂存区的修改回退到工作区，不会影响工作区的状态。</p>\n<pre><code>git rm file\n</code></pre><p>从版本库中删除某个文件。这个命令跟<code>git add</code>一样，需要<code>git commit</code>之后才能提交到版本库中。</p>\n<h2 id=\"分支管理\"><a href=\"#分支管理\" class=\"headerlink\" title=\"分支管理\"></a>分支管理</h2><h3 id=\"创建分支\"><a href=\"#创建分支\" class=\"headerlink\" title=\"创建分支\"></a>创建分支</h3><pre><code>git checkout -b dev\n</code></pre><p>创建并切换到dev分支，<code>-b</code>参数表示<strong>创建并切换</strong>，这个命令实际上是下面两个命令的结合。</p>\n<pre><code>git branch dev\ngit checkout dev \n</code></pre><p><code>git branch</code>是创建一个dev分支，<code>git checkout</code>则是切换到dev分支。</p>\n<pre><code>git branch\n</code></pre><p>查看当前分支，当前分支会标有一个*号。</p>\n<pre><code>git checkout master\n</code></pre><p>切换到master分支。</p>\n<pre><code>git merge dev\n</code></pre><p>合并指定分支到当前分支。</p>\n<pre><code>git branch -d dev\n</code></pre><p>删除指定分支。</p>\n<h3 id=\"解决冲突\"><a href=\"#解决冲突\" class=\"headerlink\" title=\"解决冲突\"></a>解决冲突</h3><p>当切换到master分支并尝试合并dev分支时，若有冲突存在，必须手动解决冲突再进行提交。</p>\n<p>Git用&lt;&lt;&lt;&lt;&lt;&lt;，======，&gt;&gt;&gt;&gt;&gt;&gt;标记处不同分支的内容。</p>\n<pre><code>git log --graph --pretty=oneline --abbrev-commit\n</code></pre><p>用带参数的<code>git log</code>命令可以看到分支的合并情况。</p>\n<blockquote>\n<p>当Git无法自动合并分支时，必须首先解决冲突，再提交。合并后用<code>git log --graph</code>可以看到分支合并图。</p>\n</blockquote>\n<h3 id=\"分支管理策略\"><a href=\"#分支管理策略\" class=\"headerlink\" title=\"分支管理策略\"></a>分支管理策略</h3><p>默认情况下，Git会用<code>Fast forward</code>模式合并分支，但这种情况下，删除分支会丢掉分支信息，会看不出来曾经做过合并</p>\n<pre><code>git merge --no-ff -m &quot;message&quot; dev\n</code></pre><p>本次合并会创建一个新的commit，通过<code>-m</code>把commit描述写进去，<code>--no-ff</code>表示禁用<code>Fast forward</code>。</p>\n<blockquote>\n<p><code>master</code>一般是最稳定的版本，用来发布新版本。<br>建立以个<code>dev</code>分支来进行协作，每个人都在<code>dev</code>分支上写代码，时不时向<code>dev</code>分支上提交，dev提交到<code>master</code>上来发布稳定版本。</p>\n</blockquote>\n<h3 id=\"Bug分支\"><a href=\"#Bug分支\" class=\"headerlink\" title=\"Bug分支\"></a>Bug分支</h3><pre><code>git stash\n</code></pre><p>可以把当前工作区存起来，等以后恢复现场继续工作。执行完后，工作区是clean的，可以拿来创建分支。</p>\n<pre><code>git checkout master\ngit checkout -b issue-101\n</code></pre><p>创建<code>issue-101</code>分支并修复Bug。</p>\n<pre><code>git stash list\n</code></pre><p>查看保存的工作区。</p>\n<pre><code>git stash apply\n</code></pre><p>恢复指定工作区。</p>\n<pre><code>git stash drop\n</code></pre><p>删除stash。</p>\n<pre><code>git stash pop\n</code></pre><p>恢复的同时会删除stash的内容。</p>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><p>git config 命令用来设置git的一些基本设置，包括全局配置以及针对特定仓库的配置。</p>\n<h3 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h3><h4 id=\"设置名字\"><a href=\"#设置名字\" class=\"headerlink\" title=\"设置名字\"></a>设置名字</h4><pre><code>git config user.name &lt;name&gt;\n</code></pre><p>设置当前仓库<code>commit</code>时作者的名字。</p>\n<pre><code>git config --global user.name &lt;name&gt;\n</code></pre><p>设置全局的作者名字，这样以后其他仓库<code>commit</code>时，都会以这个名字提交。</p>\n<h4 id=\"设置邮箱\"><a href=\"#设置邮箱\" class=\"headerlink\" title=\"设置邮箱\"></a>设置邮箱</h4><pre><code>git config --global user.email &lt;email&gt;\n</code></pre><p>设置全局的作者邮箱。</p>\n<p>例子：</p>\n<pre><code>git config --global user.name &quot;denight&quot;\ngit config --global user.email denight@qq.com\n</code></pre><h4 id=\"设置简写-别名\"><a href=\"#设置简写-别名\" class=\"headerlink\" title=\"设置简写/别名\"></a>设置简写/别名</h4><pre><code>git config --global alias.&lt;alias-name&gt; &lt;git-comman&gt;\n</code></pre><p>设置git命令的简写。比如<code>git status</code>可以通过下面的命令简写为<code>git st</code>。</p>\n<pre><code>git config --global alias.st status\n</code></pre><h3 id=\"更多\"><a href=\"#更多\" class=\"headerlink\" title=\"更多\"></a>更多</h3><p>Git把配置文件存储在三个不同的文件中，一个作用于当前仓库，一个作用于当前用户，一个作用于整个系统。</p>\n<ul>\n<li><repo>/.git/config 当前仓库的配置</repo></li>\n<li>~/.gitconfig 当前用户所属的配置，即—global的配置</li>\n<li>$(prefix)/etc/gitconfig 系统级别的配置</li>\n</ul>\n<p>优先级从高到底。</p>\n"},{"layout":"post","title":"Sublime Text 3的基本安装与配置","date":"2017-04-01T16:13:06.000Z","_content":"## 下载\n[官网下载](https://www.sublimetext.com/)\n\n## Package Control\n### 安装\n### 简易方法\n最简单的安装方法，是通过Sublime Text控制台来安装。你可以通过Ctrl + ` 快捷键或者通过菜单栏 View > Show Console 来打开控制台。接着，输入下面这段代码按下回车即可。（最新的版本请参照官网）\n\n    import urllib.request,os,hashlib; h = 'df21e130d211cfc94d9b0905775a7c0f' + '1e3d39e33b79698005270310898eea76'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by)\n\n这段代码在必要的情况下会为你创建一个Installed Packages 文件夹，然后下载Package Control.sublime-package到这个文件夹中。这个下载由于Python标准库的限制，会通过HTTP而不是HTTPS来完成。文件会通过SHA-256来验证。\n### 手动下载\n如果由于一些原因，你无法在控制台中完成下载，那么你可以通过以下几个步骤来手动安装Package Control：\n\n 1. 点击菜单中的Preferences > Browse Packages...\n 2. 在打开的文件夹中创建一个Installed Packages文件夹\n 3. 下载这个文件[Package Control.sublime-package](https://packagecontrol.io/Package%20Control.sublime-package)并放到新建的Installed Packages文件夹中\n 4. 重启Sublime Text\n\n### 安装插件\n完成Package Control的安装后，在Sublime中按住`Shift + CMD + P`。在输入框中输入`Package Control:Install Package`，这时Sublime会获取服务器上所有的Package信息，稍等一下后就可以选择自己需要的插件进行安装了。\n你可以在[Package Control - Browse](https://packagecontrol.io/browse)中查看所有插件的信息。Package Control也可以用于下载一些Sublime的主题，只要在Package安装选择界面中以Theme开头即可。\n\n插件的配置和主题的选择都可以在Preferences菜单中进行。\n\n \n## 进阶\n### 在Terminal中打开Sublime\nSublime Text 包含了一个命令行工具，`subl`，能让你在命令行中打开文件。这个工具可以用来在Sublime中打开对应的文件和项目文件夹。\n#### 设置\n在Terminal中输入以下这段代码：\n\n    ln -s \"/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl\" /usr/local/bin/subl\n\n接下来你就可以在命令行中用`subl fileName`的方式来打开文件了。\n\n更多用法可以输入`subl --help`查看。\n### 在Sublime Text中运行JavaScript\n点击菜单中的Tools > Build System > New Build System，复制以下代码：\n\n    {\n\t    \"cmd\": [\"/usr/local/bin/node\",\"$file\"],\n\t    \"selector\": \"source.js\"\n    }\n\n命名为`JavaScript.sublime-build`保存至Package或Package/User文件夹。\n\n## 参考\n[Package Control - Installation](https://packagecontrol.io/installation)\n\n[Sublime Text 3 - OS X Command Line](https://www.sublimetext.com/docs/3/osx_command_line.html)\n\n[Build Systems](http://docs.sublimetext.info/en/latest/file_processing/build_systems.html)","source":"_posts/2017-04-02-Sublime-Text-3的基本安装与配置.markdown","raw":"---\nlayout: post\ntitle:  \"Sublime Text 3的基本安装与配置\"\ndate:   2017-04-02 00:13:06 +0800\ncategories: Sublime\n---\n## 下载\n[官网下载](https://www.sublimetext.com/)\n\n## Package Control\n### 安装\n### 简易方法\n最简单的安装方法，是通过Sublime Text控制台来安装。你可以通过Ctrl + ` 快捷键或者通过菜单栏 View > Show Console 来打开控制台。接着，输入下面这段代码按下回车即可。（最新的版本请参照官网）\n\n    import urllib.request,os,hashlib; h = 'df21e130d211cfc94d9b0905775a7c0f' + '1e3d39e33b79698005270310898eea76'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by)\n\n这段代码在必要的情况下会为你创建一个Installed Packages 文件夹，然后下载Package Control.sublime-package到这个文件夹中。这个下载由于Python标准库的限制，会通过HTTP而不是HTTPS来完成。文件会通过SHA-256来验证。\n### 手动下载\n如果由于一些原因，你无法在控制台中完成下载，那么你可以通过以下几个步骤来手动安装Package Control：\n\n 1. 点击菜单中的Preferences > Browse Packages...\n 2. 在打开的文件夹中创建一个Installed Packages文件夹\n 3. 下载这个文件[Package Control.sublime-package](https://packagecontrol.io/Package%20Control.sublime-package)并放到新建的Installed Packages文件夹中\n 4. 重启Sublime Text\n\n### 安装插件\n完成Package Control的安装后，在Sublime中按住`Shift + CMD + P`。在输入框中输入`Package Control:Install Package`，这时Sublime会获取服务器上所有的Package信息，稍等一下后就可以选择自己需要的插件进行安装了。\n你可以在[Package Control - Browse](https://packagecontrol.io/browse)中查看所有插件的信息。Package Control也可以用于下载一些Sublime的主题，只要在Package安装选择界面中以Theme开头即可。\n\n插件的配置和主题的选择都可以在Preferences菜单中进行。\n\n \n## 进阶\n### 在Terminal中打开Sublime\nSublime Text 包含了一个命令行工具，`subl`，能让你在命令行中打开文件。这个工具可以用来在Sublime中打开对应的文件和项目文件夹。\n#### 设置\n在Terminal中输入以下这段代码：\n\n    ln -s \"/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl\" /usr/local/bin/subl\n\n接下来你就可以在命令行中用`subl fileName`的方式来打开文件了。\n\n更多用法可以输入`subl --help`查看。\n### 在Sublime Text中运行JavaScript\n点击菜单中的Tools > Build System > New Build System，复制以下代码：\n\n    {\n\t    \"cmd\": [\"/usr/local/bin/node\",\"$file\"],\n\t    \"selector\": \"source.js\"\n    }\n\n命名为`JavaScript.sublime-build`保存至Package或Package/User文件夹。\n\n## 参考\n[Package Control - Installation](https://packagecontrol.io/installation)\n\n[Sublime Text 3 - OS X Command Line](https://www.sublimetext.com/docs/3/osx_command_line.html)\n\n[Build Systems](http://docs.sublimetext.info/en/latest/file_processing/build_systems.html)","slug":"2017-04-02-Sublime-Text-3的基本安装与配置","published":1,"updated":"2017-07-30T15:21:44.000Z","comments":1,"photos":[],"link":"","_id":"cj5qx2mld0005b4orb6zyex4h","content":"<h2 id=\"下载\"><a href=\"#下载\" class=\"headerlink\" title=\"下载\"></a>下载</h2><p><a href=\"https://www.sublimetext.com/\" target=\"_blank\" rel=\"external\">官网下载</a></p>\n<h2 id=\"Package-Control\"><a href=\"#Package-Control\" class=\"headerlink\" title=\"Package Control\"></a>Package Control</h2><h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><h3 id=\"简易方法\"><a href=\"#简易方法\" class=\"headerlink\" title=\"简易方法\"></a>简易方法</h3><p>最简单的安装方法，是通过Sublime Text控制台来安装。你可以通过Ctrl + ` 快捷键或者通过菜单栏 View &gt; Show Console 来打开控制台。接着，输入下面这段代码按下回车即可。（最新的版本请参照官网）</p>\n<pre><code>import urllib.request,os,hashlib; h = &apos;df21e130d211cfc94d9b0905775a7c0f&apos; + &apos;1e3d39e33b79698005270310898eea76&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by)\n</code></pre><p>这段代码在必要的情况下会为你创建一个Installed Packages 文件夹，然后下载Package Control.sublime-package到这个文件夹中。这个下载由于Python标准库的限制，会通过HTTP而不是HTTPS来完成。文件会通过SHA-256来验证。</p>\n<h3 id=\"手动下载\"><a href=\"#手动下载\" class=\"headerlink\" title=\"手动下载\"></a>手动下载</h3><p>如果由于一些原因，你无法在控制台中完成下载，那么你可以通过以下几个步骤来手动安装Package Control：</p>\n<ol>\n<li>点击菜单中的Preferences &gt; Browse Packages…</li>\n<li>在打开的文件夹中创建一个Installed Packages文件夹</li>\n<li>下载这个文件<a href=\"https://packagecontrol.io/Package%20Control.sublime-package\" target=\"_blank\" rel=\"external\">Package Control.sublime-package</a>并放到新建的Installed Packages文件夹中</li>\n<li>重启Sublime Text</li>\n</ol>\n<h3 id=\"安装插件\"><a href=\"#安装插件\" class=\"headerlink\" title=\"安装插件\"></a>安装插件</h3><p>完成Package Control的安装后，在Sublime中按住<code>Shift + CMD + P</code>。在输入框中输入<code>Package Control:Install Package</code>，这时Sublime会获取服务器上所有的Package信息，稍等一下后就可以选择自己需要的插件进行安装了。<br>你可以在<a href=\"https://packagecontrol.io/browse\" target=\"_blank\" rel=\"external\">Package Control - Browse</a>中查看所有插件的信息。Package Control也可以用于下载一些Sublime的主题，只要在Package安装选择界面中以Theme开头即可。</p>\n<p>插件的配置和主题的选择都可以在Preferences菜单中进行。</p>\n<h2 id=\"进阶\"><a href=\"#进阶\" class=\"headerlink\" title=\"进阶\"></a>进阶</h2><h3 id=\"在Terminal中打开Sublime\"><a href=\"#在Terminal中打开Sublime\" class=\"headerlink\" title=\"在Terminal中打开Sublime\"></a>在Terminal中打开Sublime</h3><p>Sublime Text 包含了一个命令行工具，<code>subl</code>，能让你在命令行中打开文件。这个工具可以用来在Sublime中打开对应的文件和项目文件夹。</p>\n<h4 id=\"设置\"><a href=\"#设置\" class=\"headerlink\" title=\"设置\"></a>设置</h4><p>在Terminal中输入以下这段代码：</p>\n<pre><code>ln -s &quot;/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl&quot; /usr/local/bin/subl\n</code></pre><p>接下来你就可以在命令行中用<code>subl fileName</code>的方式来打开文件了。</p>\n<p>更多用法可以输入<code>subl --help</code>查看。</p>\n<h3 id=\"在Sublime-Text中运行JavaScript\"><a href=\"#在Sublime-Text中运行JavaScript\" class=\"headerlink\" title=\"在Sublime Text中运行JavaScript\"></a>在Sublime Text中运行JavaScript</h3><p>点击菜单中的Tools &gt; Build System &gt; New Build System，复制以下代码：</p>\n<pre><code>{\n    &quot;cmd&quot;: [&quot;/usr/local/bin/node&quot;,&quot;$file&quot;],\n    &quot;selector&quot;: &quot;source.js&quot;\n}\n</code></pre><p>命名为<code>JavaScript.sublime-build</code>保存至Package或Package/User文件夹。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://packagecontrol.io/installation\" target=\"_blank\" rel=\"external\">Package Control - Installation</a></p>\n<p><a href=\"https://www.sublimetext.com/docs/3/osx_command_line.html\" target=\"_blank\" rel=\"external\">Sublime Text 3 - OS X Command Line</a></p>\n<p><a href=\"http://docs.sublimetext.info/en/latest/file_processing/build_systems.html\" target=\"_blank\" rel=\"external\">Build Systems</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"下载\"><a href=\"#下载\" class=\"headerlink\" title=\"下载\"></a>下载</h2><p><a href=\"https://www.sublimetext.com/\" target=\"_blank\" rel=\"external\">官网下载</a></p>\n<h2 id=\"Package-Control\"><a href=\"#Package-Control\" class=\"headerlink\" title=\"Package Control\"></a>Package Control</h2><h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><h3 id=\"简易方法\"><a href=\"#简易方法\" class=\"headerlink\" title=\"简易方法\"></a>简易方法</h3><p>最简单的安装方法，是通过Sublime Text控制台来安装。你可以通过Ctrl + ` 快捷键或者通过菜单栏 View &gt; Show Console 来打开控制台。接着，输入下面这段代码按下回车即可。（最新的版本请参照官网）</p>\n<pre><code>import urllib.request,os,hashlib; h = &apos;df21e130d211cfc94d9b0905775a7c0f&apos; + &apos;1e3d39e33b79698005270310898eea76&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by)\n</code></pre><p>这段代码在必要的情况下会为你创建一个Installed Packages 文件夹，然后下载Package Control.sublime-package到这个文件夹中。这个下载由于Python标准库的限制，会通过HTTP而不是HTTPS来完成。文件会通过SHA-256来验证。</p>\n<h3 id=\"手动下载\"><a href=\"#手动下载\" class=\"headerlink\" title=\"手动下载\"></a>手动下载</h3><p>如果由于一些原因，你无法在控制台中完成下载，那么你可以通过以下几个步骤来手动安装Package Control：</p>\n<ol>\n<li>点击菜单中的Preferences &gt; Browse Packages…</li>\n<li>在打开的文件夹中创建一个Installed Packages文件夹</li>\n<li>下载这个文件<a href=\"https://packagecontrol.io/Package%20Control.sublime-package\" target=\"_blank\" rel=\"external\">Package Control.sublime-package</a>并放到新建的Installed Packages文件夹中</li>\n<li>重启Sublime Text</li>\n</ol>\n<h3 id=\"安装插件\"><a href=\"#安装插件\" class=\"headerlink\" title=\"安装插件\"></a>安装插件</h3><p>完成Package Control的安装后，在Sublime中按住<code>Shift + CMD + P</code>。在输入框中输入<code>Package Control:Install Package</code>，这时Sublime会获取服务器上所有的Package信息，稍等一下后就可以选择自己需要的插件进行安装了。<br>你可以在<a href=\"https://packagecontrol.io/browse\" target=\"_blank\" rel=\"external\">Package Control - Browse</a>中查看所有插件的信息。Package Control也可以用于下载一些Sublime的主题，只要在Package安装选择界面中以Theme开头即可。</p>\n<p>插件的配置和主题的选择都可以在Preferences菜单中进行。</p>\n<h2 id=\"进阶\"><a href=\"#进阶\" class=\"headerlink\" title=\"进阶\"></a>进阶</h2><h3 id=\"在Terminal中打开Sublime\"><a href=\"#在Terminal中打开Sublime\" class=\"headerlink\" title=\"在Terminal中打开Sublime\"></a>在Terminal中打开Sublime</h3><p>Sublime Text 包含了一个命令行工具，<code>subl</code>，能让你在命令行中打开文件。这个工具可以用来在Sublime中打开对应的文件和项目文件夹。</p>\n<h4 id=\"设置\"><a href=\"#设置\" class=\"headerlink\" title=\"设置\"></a>设置</h4><p>在Terminal中输入以下这段代码：</p>\n<pre><code>ln -s &quot;/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl&quot; /usr/local/bin/subl\n</code></pre><p>接下来你就可以在命令行中用<code>subl fileName</code>的方式来打开文件了。</p>\n<p>更多用法可以输入<code>subl --help</code>查看。</p>\n<h3 id=\"在Sublime-Text中运行JavaScript\"><a href=\"#在Sublime-Text中运行JavaScript\" class=\"headerlink\" title=\"在Sublime Text中运行JavaScript\"></a>在Sublime Text中运行JavaScript</h3><p>点击菜单中的Tools &gt; Build System &gt; New Build System，复制以下代码：</p>\n<pre><code>{\n    &quot;cmd&quot;: [&quot;/usr/local/bin/node&quot;,&quot;$file&quot;],\n    &quot;selector&quot;: &quot;source.js&quot;\n}\n</code></pre><p>命名为<code>JavaScript.sublime-build</code>保存至Package或Package/User文件夹。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://packagecontrol.io/installation\" target=\"_blank\" rel=\"external\">Package Control - Installation</a></p>\n<p><a href=\"https://www.sublimetext.com/docs/3/osx_command_line.html\" target=\"_blank\" rel=\"external\">Sublime Text 3 - OS X Command Line</a></p>\n<p><a href=\"http://docs.sublimetext.info/en/latest/file_processing/build_systems.html\" target=\"_blank\" rel=\"external\">Build Systems</a></p>\n"},{"layout":"post","title":"Mac：如何在Terminal中打开Finder","date":"2017-04-07T14:16:35.000Z","_content":"## 前言\n对于习惯使用Terminal的小伙伴们来说，常常有“进入到某个目录中”并“在该目录中打开Finder”的需求。\n明明已经在目录下了，却还需要在桌面按个CMD+N来打开Finder再在Finder中一层一层打开，简直不要太痛苦。\n既然如此，那就试试open命令吧。\n## open命令\n在Terminal中输入`open -h`，可以看到如下的说明：\n\n\n\tUsage: open [-e] [-t] [-f] [-W] [-R] [-n] [-g] [-h] [-b <bundle identifier>] [-a <application>] [filenames] [--args arguments]\n\tHelp: Open opens files from a shell.\n\t      By default, opens each file using the default application for that file.  \n\t      If the file is in the form of a URL, the file will be opened as a URL.\n\tOptions: \n\t      -a                Opens with the specified application.\n\t      -b                Opens with the specified application bundle identifier.\n\t      -e                Opens with TextEdit.\n\t      -t                Opens with default text editor.\n\t      -f                Reads input from standard input and opens with TextEdit.\n\t      -F  --fresh       Launches the app fresh, that is, without restoring windows. Saved persistent state is lost, excluding Untitled documents.\n\t      -R, --reveal      Selects in the Finder instead of opening.\n\t      -W, --wait-apps   Blocks until the used applications are closed (even if they were already running).\n\t          --args        All remaining arguments are passed in argv to the application's main() function instead of opened.\n\t      -n, --new         Open a new instance of the application even if one is already running.\n\t      -j, --hide        Launches the app hidden.\n\t      -g, --background  Does not bring the application to the foreground.\n\t      -h, --header      Searches header file locations for headers matching the given filenames, and opens them.\n\n\n部分翻译如下：\n\n\n\t使用方法： open [-e] [-t] [-f] [-W] [-R] [-n] [-g] [-h] [-b <bundle identifier>] [-a <应用名>] [文件名] [--args arguments]\n\tHelp: 用于在命令行中打开文件\n\t      默认情况下，使用默认的应用打开对应的文件。\n\t      如果是URL格式的文件，那么就会在浏览器中打开。\n\tOptions: \n\t      -a                指定打开文件的应用\n\t      -e                用TextEdit打开该文件\n\t      -t                用默认文本编辑器打开该文件\n\t      -R, --reveal      在Finder中显示并选中\n\t      -g, --background  在后台打开该文件（此时焦点还在Terminal上）\n\n\n\n## 打开目录的正确方式\n那么如何解决“在Terminal中打开当前目录”的问题呢？只要输入以下命令即可：\n\n    $ open ./\n\n没错就这么简单。默认情况下，如果是个open之后是一个目录，那么就会用Finder打开。回车之后，会将焦点直接转移至打开的Finder目录。\n这时如果你是想打开多个Finder目录，就需要手动切回Terminal再执行命令了。这种情况下，你可以加一个-g参数，来让焦点始终保持在Terminal上。\n\n    $ open -g ./\n\n这样我们就可以一次性在命令行中打开所有想打开的目录了。\n### 浏览文件\n除此之外，文件太多了，想在Finder中浏览指定文件怎么办呢。可以用-R来解决：\n\n    $ open -R ./test.js\n\n这样就可以在Finder显示，并且已经被选中了。\n## 打开网站的正确方式\n除了打开目录之外，open命令也可以用于打开网站：\n\n    $ open http://denight.leanote.com\n\n记得一定要加http，否则是不会被识别成URL的。\n### 指定浏览器打开\n默认情况下，是用Safari打开浏览器的：\n\n    $ open http://denight.leanote.com\n\n等同于\n\n    $ open -a Safari http://denight.leanote.com\n\n如果要换成Firefox或者是Google Chrome，替换命令中的Safari即可\n\n    $ open -a Firefox http://denight.leanote.com\n    $ open -a Google\\ Chrome http://denight.leanote.com\n\n## 打开代码的正确方式\n\n    $open -e ./test.js\n\n使用这个命令，可以在TextEdit中打开test.js文件。如果不加-e的话，就会用默认的应用打开。\n也可以指定想要的打开的编辑器。\n\n    $open -a Sublime\\ Text ./test.js\n\n\n## 参考\n[在Mac终端下打开Finder](http://ju.outofmemory.cn/entry/75555)\n","source":"_posts/2017-04-07-Mac在Terminal打开Finder.markdown","raw":"---\nlayout: post\ntitle:  \"Mac：如何在Terminal中打开Finder\"\ndate:   2017-04-07 22:16:35 +0800\ncategories: Mac\n---\n## 前言\n对于习惯使用Terminal的小伙伴们来说，常常有“进入到某个目录中”并“在该目录中打开Finder”的需求。\n明明已经在目录下了，却还需要在桌面按个CMD+N来打开Finder再在Finder中一层一层打开，简直不要太痛苦。\n既然如此，那就试试open命令吧。\n## open命令\n在Terminal中输入`open -h`，可以看到如下的说明：\n\n\n\tUsage: open [-e] [-t] [-f] [-W] [-R] [-n] [-g] [-h] [-b <bundle identifier>] [-a <application>] [filenames] [--args arguments]\n\tHelp: Open opens files from a shell.\n\t      By default, opens each file using the default application for that file.  \n\t      If the file is in the form of a URL, the file will be opened as a URL.\n\tOptions: \n\t      -a                Opens with the specified application.\n\t      -b                Opens with the specified application bundle identifier.\n\t      -e                Opens with TextEdit.\n\t      -t                Opens with default text editor.\n\t      -f                Reads input from standard input and opens with TextEdit.\n\t      -F  --fresh       Launches the app fresh, that is, without restoring windows. Saved persistent state is lost, excluding Untitled documents.\n\t      -R, --reveal      Selects in the Finder instead of opening.\n\t      -W, --wait-apps   Blocks until the used applications are closed (even if they were already running).\n\t          --args        All remaining arguments are passed in argv to the application's main() function instead of opened.\n\t      -n, --new         Open a new instance of the application even if one is already running.\n\t      -j, --hide        Launches the app hidden.\n\t      -g, --background  Does not bring the application to the foreground.\n\t      -h, --header      Searches header file locations for headers matching the given filenames, and opens them.\n\n\n部分翻译如下：\n\n\n\t使用方法： open [-e] [-t] [-f] [-W] [-R] [-n] [-g] [-h] [-b <bundle identifier>] [-a <应用名>] [文件名] [--args arguments]\n\tHelp: 用于在命令行中打开文件\n\t      默认情况下，使用默认的应用打开对应的文件。\n\t      如果是URL格式的文件，那么就会在浏览器中打开。\n\tOptions: \n\t      -a                指定打开文件的应用\n\t      -e                用TextEdit打开该文件\n\t      -t                用默认文本编辑器打开该文件\n\t      -R, --reveal      在Finder中显示并选中\n\t      -g, --background  在后台打开该文件（此时焦点还在Terminal上）\n\n\n\n## 打开目录的正确方式\n那么如何解决“在Terminal中打开当前目录”的问题呢？只要输入以下命令即可：\n\n    $ open ./\n\n没错就这么简单。默认情况下，如果是个open之后是一个目录，那么就会用Finder打开。回车之后，会将焦点直接转移至打开的Finder目录。\n这时如果你是想打开多个Finder目录，就需要手动切回Terminal再执行命令了。这种情况下，你可以加一个-g参数，来让焦点始终保持在Terminal上。\n\n    $ open -g ./\n\n这样我们就可以一次性在命令行中打开所有想打开的目录了。\n### 浏览文件\n除此之外，文件太多了，想在Finder中浏览指定文件怎么办呢。可以用-R来解决：\n\n    $ open -R ./test.js\n\n这样就可以在Finder显示，并且已经被选中了。\n## 打开网站的正确方式\n除了打开目录之外，open命令也可以用于打开网站：\n\n    $ open http://denight.leanote.com\n\n记得一定要加http，否则是不会被识别成URL的。\n### 指定浏览器打开\n默认情况下，是用Safari打开浏览器的：\n\n    $ open http://denight.leanote.com\n\n等同于\n\n    $ open -a Safari http://denight.leanote.com\n\n如果要换成Firefox或者是Google Chrome，替换命令中的Safari即可\n\n    $ open -a Firefox http://denight.leanote.com\n    $ open -a Google\\ Chrome http://denight.leanote.com\n\n## 打开代码的正确方式\n\n    $open -e ./test.js\n\n使用这个命令，可以在TextEdit中打开test.js文件。如果不加-e的话，就会用默认的应用打开。\n也可以指定想要的打开的编辑器。\n\n    $open -a Sublime\\ Text ./test.js\n\n\n## 参考\n[在Mac终端下打开Finder](http://ju.outofmemory.cn/entry/75555)\n","slug":"2017-04-07-Mac在Terminal打开Finder","published":1,"updated":"2017-07-30T15:22:50.000Z","comments":1,"photos":[],"link":"","_id":"cj5qx2mlg0007b4orsfj4r09m","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>对于习惯使用Terminal的小伙伴们来说，常常有“进入到某个目录中”并“在该目录中打开Finder”的需求。<br>明明已经在目录下了，却还需要在桌面按个CMD+N来打开Finder再在Finder中一层一层打开，简直不要太痛苦。<br>既然如此，那就试试open命令吧。</p>\n<h2 id=\"open命令\"><a href=\"#open命令\" class=\"headerlink\" title=\"open命令\"></a>open命令</h2><p>在Terminal中输入<code>open -h</code>，可以看到如下的说明：</p>\n<pre><code>Usage: open [-e] [-t] [-f] [-W] [-R] [-n] [-g] [-h] [-b &lt;bundle identifier&gt;] [-a &lt;application&gt;] [filenames] [--args arguments]\nHelp: Open opens files from a shell.\n      By default, opens each file using the default application for that file.  \n      If the file is in the form of a URL, the file will be opened as a URL.\nOptions: \n      -a                Opens with the specified application.\n      -b                Opens with the specified application bundle identifier.\n      -e                Opens with TextEdit.\n      -t                Opens with default text editor.\n      -f                Reads input from standard input and opens with TextEdit.\n      -F  --fresh       Launches the app fresh, that is, without restoring windows. Saved persistent state is lost, excluding Untitled documents.\n      -R, --reveal      Selects in the Finder instead of opening.\n      -W, --wait-apps   Blocks until the used applications are closed (even if they were already running).\n          --args        All remaining arguments are passed in argv to the application&apos;s main() function instead of opened.\n      -n, --new         Open a new instance of the application even if one is already running.\n      -j, --hide        Launches the app hidden.\n      -g, --background  Does not bring the application to the foreground.\n      -h, --header      Searches header file locations for headers matching the given filenames, and opens them.\n</code></pre><p>部分翻译如下：</p>\n<pre><code>使用方法： open [-e] [-t] [-f] [-W] [-R] [-n] [-g] [-h] [-b &lt;bundle identifier&gt;] [-a &lt;应用名&gt;] [文件名] [--args arguments]\nHelp: 用于在命令行中打开文件\n      默认情况下，使用默认的应用打开对应的文件。\n      如果是URL格式的文件，那么就会在浏览器中打开。\nOptions: \n      -a                指定打开文件的应用\n      -e                用TextEdit打开该文件\n      -t                用默认文本编辑器打开该文件\n      -R, --reveal      在Finder中显示并选中\n      -g, --background  在后台打开该文件（此时焦点还在Terminal上）\n</code></pre><h2 id=\"打开目录的正确方式\"><a href=\"#打开目录的正确方式\" class=\"headerlink\" title=\"打开目录的正确方式\"></a>打开目录的正确方式</h2><p>那么如何解决“在Terminal中打开当前目录”的问题呢？只要输入以下命令即可：</p>\n<pre><code>$ open ./\n</code></pre><p>没错就这么简单。默认情况下，如果是个open之后是一个目录，那么就会用Finder打开。回车之后，会将焦点直接转移至打开的Finder目录。<br>这时如果你是想打开多个Finder目录，就需要手动切回Terminal再执行命令了。这种情况下，你可以加一个-g参数，来让焦点始终保持在Terminal上。</p>\n<pre><code>$ open -g ./\n</code></pre><p>这样我们就可以一次性在命令行中打开所有想打开的目录了。</p>\n<h3 id=\"浏览文件\"><a href=\"#浏览文件\" class=\"headerlink\" title=\"浏览文件\"></a>浏览文件</h3><p>除此之外，文件太多了，想在Finder中浏览指定文件怎么办呢。可以用-R来解决：</p>\n<pre><code>$ open -R ./test.js\n</code></pre><p>这样就可以在Finder显示，并且已经被选中了。</p>\n<h2 id=\"打开网站的正确方式\"><a href=\"#打开网站的正确方式\" class=\"headerlink\" title=\"打开网站的正确方式\"></a>打开网站的正确方式</h2><p>除了打开目录之外，open命令也可以用于打开网站：</p>\n<pre><code>$ open http://denight.leanote.com\n</code></pre><p>记得一定要加http，否则是不会被识别成URL的。</p>\n<h3 id=\"指定浏览器打开\"><a href=\"#指定浏览器打开\" class=\"headerlink\" title=\"指定浏览器打开\"></a>指定浏览器打开</h3><p>默认情况下，是用Safari打开浏览器的：</p>\n<pre><code>$ open http://denight.leanote.com\n</code></pre><p>等同于</p>\n<pre><code>$ open -a Safari http://denight.leanote.com\n</code></pre><p>如果要换成Firefox或者是Google Chrome，替换命令中的Safari即可</p>\n<pre><code>$ open -a Firefox http://denight.leanote.com\n$ open -a Google\\ Chrome http://denight.leanote.com\n</code></pre><h2 id=\"打开代码的正确方式\"><a href=\"#打开代码的正确方式\" class=\"headerlink\" title=\"打开代码的正确方式\"></a>打开代码的正确方式</h2><pre><code>$open -e ./test.js\n</code></pre><p>使用这个命令，可以在TextEdit中打开test.js文件。如果不加-e的话，就会用默认的应用打开。<br>也可以指定想要的打开的编辑器。</p>\n<pre><code>$open -a Sublime\\ Text ./test.js\n</code></pre><h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://ju.outofmemory.cn/entry/75555\" target=\"_blank\" rel=\"external\">在Mac终端下打开Finder</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>对于习惯使用Terminal的小伙伴们来说，常常有“进入到某个目录中”并“在该目录中打开Finder”的需求。<br>明明已经在目录下了，却还需要在桌面按个CMD+N来打开Finder再在Finder中一层一层打开，简直不要太痛苦。<br>既然如此，那就试试open命令吧。</p>\n<h2 id=\"open命令\"><a href=\"#open命令\" class=\"headerlink\" title=\"open命令\"></a>open命令</h2><p>在Terminal中输入<code>open -h</code>，可以看到如下的说明：</p>\n<pre><code>Usage: open [-e] [-t] [-f] [-W] [-R] [-n] [-g] [-h] [-b &lt;bundle identifier&gt;] [-a &lt;application&gt;] [filenames] [--args arguments]\nHelp: Open opens files from a shell.\n      By default, opens each file using the default application for that file.  \n      If the file is in the form of a URL, the file will be opened as a URL.\nOptions: \n      -a                Opens with the specified application.\n      -b                Opens with the specified application bundle identifier.\n      -e                Opens with TextEdit.\n      -t                Opens with default text editor.\n      -f                Reads input from standard input and opens with TextEdit.\n      -F  --fresh       Launches the app fresh, that is, without restoring windows. Saved persistent state is lost, excluding Untitled documents.\n      -R, --reveal      Selects in the Finder instead of opening.\n      -W, --wait-apps   Blocks until the used applications are closed (even if they were already running).\n          --args        All remaining arguments are passed in argv to the application&apos;s main() function instead of opened.\n      -n, --new         Open a new instance of the application even if one is already running.\n      -j, --hide        Launches the app hidden.\n      -g, --background  Does not bring the application to the foreground.\n      -h, --header      Searches header file locations for headers matching the given filenames, and opens them.\n</code></pre><p>部分翻译如下：</p>\n<pre><code>使用方法： open [-e] [-t] [-f] [-W] [-R] [-n] [-g] [-h] [-b &lt;bundle identifier&gt;] [-a &lt;应用名&gt;] [文件名] [--args arguments]\nHelp: 用于在命令行中打开文件\n      默认情况下，使用默认的应用打开对应的文件。\n      如果是URL格式的文件，那么就会在浏览器中打开。\nOptions: \n      -a                指定打开文件的应用\n      -e                用TextEdit打开该文件\n      -t                用默认文本编辑器打开该文件\n      -R, --reveal      在Finder中显示并选中\n      -g, --background  在后台打开该文件（此时焦点还在Terminal上）\n</code></pre><h2 id=\"打开目录的正确方式\"><a href=\"#打开目录的正确方式\" class=\"headerlink\" title=\"打开目录的正确方式\"></a>打开目录的正确方式</h2><p>那么如何解决“在Terminal中打开当前目录”的问题呢？只要输入以下命令即可：</p>\n<pre><code>$ open ./\n</code></pre><p>没错就这么简单。默认情况下，如果是个open之后是一个目录，那么就会用Finder打开。回车之后，会将焦点直接转移至打开的Finder目录。<br>这时如果你是想打开多个Finder目录，就需要手动切回Terminal再执行命令了。这种情况下，你可以加一个-g参数，来让焦点始终保持在Terminal上。</p>\n<pre><code>$ open -g ./\n</code></pre><p>这样我们就可以一次性在命令行中打开所有想打开的目录了。</p>\n<h3 id=\"浏览文件\"><a href=\"#浏览文件\" class=\"headerlink\" title=\"浏览文件\"></a>浏览文件</h3><p>除此之外，文件太多了，想在Finder中浏览指定文件怎么办呢。可以用-R来解决：</p>\n<pre><code>$ open -R ./test.js\n</code></pre><p>这样就可以在Finder显示，并且已经被选中了。</p>\n<h2 id=\"打开网站的正确方式\"><a href=\"#打开网站的正确方式\" class=\"headerlink\" title=\"打开网站的正确方式\"></a>打开网站的正确方式</h2><p>除了打开目录之外，open命令也可以用于打开网站：</p>\n<pre><code>$ open http://denight.leanote.com\n</code></pre><p>记得一定要加http，否则是不会被识别成URL的。</p>\n<h3 id=\"指定浏览器打开\"><a href=\"#指定浏览器打开\" class=\"headerlink\" title=\"指定浏览器打开\"></a>指定浏览器打开</h3><p>默认情况下，是用Safari打开浏览器的：</p>\n<pre><code>$ open http://denight.leanote.com\n</code></pre><p>等同于</p>\n<pre><code>$ open -a Safari http://denight.leanote.com\n</code></pre><p>如果要换成Firefox或者是Google Chrome，替换命令中的Safari即可</p>\n<pre><code>$ open -a Firefox http://denight.leanote.com\n$ open -a Google\\ Chrome http://denight.leanote.com\n</code></pre><h2 id=\"打开代码的正确方式\"><a href=\"#打开代码的正确方式\" class=\"headerlink\" title=\"打开代码的正确方式\"></a>打开代码的正确方式</h2><pre><code>$open -e ./test.js\n</code></pre><p>使用这个命令，可以在TextEdit中打开test.js文件。如果不加-e的话，就会用默认的应用打开。<br>也可以指定想要的打开的编辑器。</p>\n<pre><code>$open -a Sublime\\ Text ./test.js\n</code></pre><h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://ju.outofmemory.cn/entry/75555\" target=\"_blank\" rel=\"external\">在Mac终端下打开Finder</a></p>\n"},{"layout":"post","title":"HTTP基础（1）：概述","date":"2017-04-11T12:16:00.000Z","_content":"## HTTP协议\nHTTP，HyperText Tranfer Protocol，超文本传输协议（超文本转移协议）。\n\nHTTP协议用于客户端和服务器端之间的通信。访问文本或图像等资源的一端称为服务端（即浏览器），提供资源相应的一端称为服务端（即Web服务器）。\n\n客户端向服务器端发起一个HTTP请求，服务器端在收到HTTP请求后根据请求报文中的内容进行响应，随后返回一个HTTP响应报文。客户端得到响应后便获取到了想要获取的资源或者相关错误信息（如资源不存在）。\n\n## HTTP通过请求和响应的交换达成通信\n\nHTTP协议规定，请求从客户端发出，最后服务器端响应该请求并返回。\n\n### HTTP请求\n\n客户端发送请求：\n\n    GET /index.html HTTP/1.1\n    Host: www.example.com\n\nGET表示访问服务器的类型，称为方法（method）。随后的字符串`/index.html`指明了请求访问的资源对象，叫做请求URI（request-URI）。然后是HTTP/1.1，即HTTP的版本号。\n\n综上，这段请求的意思：通过GET方法，访问`www.example.com`这台主机上的`/index.html`页面资源。\n\n请求报文由以下几部分组成：\n\n- 请求方法\n- 请求URI\n- HTTP版本协议\n- 可选的请求首部字段\n- 可选的内容实体\n\n以下是一个用POST方法发起的HTTP请求：\n\n    POST /user/login HTTP/1.1\n    Host: www.example.com\n    Connect: keep-alive\n    Content-Type: application/x-www-form-urlencode\n    Content-Length: 16\n    \n    user=dxy&pwd=123\n    \n第一部分分别是请求方法（POST)，请求URI（/user/login），版本协议（HTTP/1.1）。接下来是请求首部字段（Host：...）。最后是内容实体（user=dxy&pwd=123）。\n\n这段请求的意思是：用POST方法，向`www.example.com/user/login`提交一个表单数据，表单数据为`user=dxy&pwd=123`。\n\n### HTTP响应\n\n服务器端发送响应：\n\n    HTTP/1.1 200 OK\n    Date: Mon, 10 Apr 2017 14:17:00 GMT\n    Content-Length: 3987\n    Content-Type: text/html\n    \n    <html>\n    ...\n\n第一部分分别是版本协议（HTTP/1.1），响应状态码（200，status code）和原因短语（reason-phrase）。接下来是创建响应的日期时间，和其他首部字段的内容。最后是一行隔开，为资源实体的主体（entity body）。\n\n响应报文由以下几部分组成：\n- HTTP版本协议\n- 状态码和原因短语\n- 创建响应的日期和可选的首部字段\n- 资源实体的主体\n\n## HTTP是不保存状态的协议\n\nHTTP是一种无状态的协议（stateless）,这意味着HTTP协议不会保存请求和响应时的通信状态，即对请求和响应都不会做持久化处理。\n\n这就会导致用户在访问一个网站时，其访问的状态无法得到保存，因为每次发起的HTTP请求都是“新”的请求，与之前是否发送过无关。\n\n为了解决这个问题，可以通过Cookie技术来实现用户状态的保存。\n\n## 请求URI定位资源\n\nHTTP协议使用URI（统一资源标识符）来定位互联网上的资源。当客户端请求访问某个资源时，需要指定该资源的URI作为HTTP请求中的请求URI。指定的方式由以下两种：\n第一种是在Host首部字段中写明访问的主机地址（域名或IP）\n\n    GET /index.html HTTP/1.1\n    Host: www.example.com\n\n第二种是完整的URI地址：\n\n    GET http://www.example.com/index.html HTTP/1.1\n\n如果不是访问特定资源而是对服务器发起请求，可以用*来代替URI。下面这个例子是查询HTTP服务器端支持的HTTP方法种类。\n\n    OPTIONS * HTTP/1.1\n\n## 基本的HTTP请求方法\n\n### GET：获取资源\nGET方法用来请求访问已被URI识别的资源。指定的资源经过服务器端解析后返回响应的内容。\n请求：\n\n    GET /index.html HTTP/1.1\n    Host: www.example.com\n    If-Modified-Since: Mon, 10 Apr 2017 14:17:00 GMT\n\n响应：\n返回2017年4月10日14点17分00秒后更新过的index.html内容，若没有更新过，则返回304 Not Modified。\n\n### POST：传输实体主体\n\n尽管GET也可以传输实体主体，但是一般来说GET用于获取资源，而POST则专门用于传输资源或更新数据。\n\n请求：\n\n    POST /submit HTTP/1.1\n    Host: www.example.com\n    ConTent-Length: 16\n    \n    user=dxy&pwd=123\n\n响应：\n返回submit响应后的处理结果\n\n### PUT：传输文件\n\nPUT方法用来传输文件，要求请求报文的主体中包含文件内容，然后保存到URI指定的位置。\n\n但是由于HTTP/1.1的PUT方法没有验证机制，任何人都可以上传文件，所以存在安全性问题。现在一般只用来配合RESTFul API。\n\n### DELETE：删除文件\n\nDELETE方法与PUT方法正好相反，用于删除指定URI上的文件。现在一般也只用在RESTFul API上。\n\n### HEAD：获取报文首部\n\nHEAD方法用来获取报文的首部，确认URI的有效性和资源的更新日期。HEAD方法基本和GET方法一样，只是GET方法获取资源内容，而HEAD方法不获取资源内容，仅获取响应报文的首部。\n\n### OPTIONS：询问支持的方法\n\nOPTIONS方法用来查询针对请求URI指定的资源支持的方法。\n\n请求：\n\n    OPTIONS * HTTP/1.1\n    Host: www.example.com\n\n响应：\n\n    HTTP/1.1 200 OK\n    Allow：Get,Post,Head,Options\n\n### TRACE：追踪路径\n\nTRACE方法是让Web服务器端将之前的请求通信环回给客户端的方法。客户端通过TRACE方法可以查询发送出去的请求是怎样被加工修改的。\n\n由于TRACE方法容易引发XST（Cross-Site Tracing 跨站追踪）攻击，且本身就不常用，这里不作展开。\n\n### CONNECT：要求用隧道协议连接代理\n\nCONNECT方法要求在与代理服务器通信时建立隧道，实现使用隧道协议进行TCP通信。主要使用SSL（Secure Sockets Layer，安全套接字）和TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。\n\n## 建立持久连接以节省通信量\n\n在HTTP协议的初始版本中，每次发送HTTP协议都会经历一次TCP连接和关闭。随着Web的发展，一个网页会包含多个HTTP请求去加载JS文件、CSS文件、图片文件等等。如果每次HTTP请求都要断开TCP连接的话，就会带来额外的通信量。为此，HTTP/1.1新增了持久化连接（HTTP keep-alive）的方案。\n\n持久连接的特点是：只要任意一方没有明确需要断开TCP连接，那么客户端和服务器端将一直保持TCP连接，旨在一次TCP连接中进行多次HTTP请求和响应。\n\nHTTP/1.1中，所有的连接默认都是持久连接。当然这需要客户端和服务器端同时支持。\n\n持久连接使得多数请求能够以管线化的方式发送，可以让客户端并行发送多个HTTP请求，大大降低Web页面的显示速度。如果没有持久化连接，那么每次发起HTTP请求，下一个HTTP请求都得等待上一个HTTP请求得到响应后才能发送。\n\n## 使用Cookie进行状态管理\n\n一方面，无状态协议能够节省服务器计算资源的开销，另一方面由于无状态的存在使得状态管理成为一个难题。\n\n为了保留无状态协议同时实现状态管理，引入了Cookie技术，通过在请求和响应的报文中写入Cookie信息来控制客户端的状态。\n\n第一次请求（没有Cookie信息）：\n\n    GET /reader HTTP/1.1\n    Host: www.example.com\n    \n响应（服务器生成Cookie信息）：\n\n    HTTP/1.1 200 OK\n    Date: Mon, 10 Apr 2017 14:17:00 GMT\n    Server: Apache\n    Set-Cookie: sid=1342077140226724; path=/; expires=Wed, 10-OCT-12 07:12:20 GMT\n    Content-Type: text/plain; charset=UTF-8\n\n之后再发起请求时，会自带Cookie信息：\n\n    GET /other HTTP/1.1\n    Host: www.example.com\n    Cookie: sid=1342077140226724\n\n可见服务器通过Set-Cookie来通知客户端保存Cookie信息，客户端随后针对这个站点的HTTP请求都会在请求头部中加入Cookie字段。如此一来，服务器端在接收到请求时就能根据客户端传来的Cookie中的sid信息，来辨别客户端了，客户端的状态就能够得到保持。\n\n## 小结\n\nHTTP协议是通过请求和响应来进行通信的无状态协议。\n\n其中要注意HTTP请求的基本格式，其组成（请求方法，请求URI，版本协议，可选的首部字段，可选的传输实体）。HTTP响应的基本格式，以及其组成（版本协议，状态码，原因短语，可选的首部字段，资源实体的主体）。\n\n要熟悉常见的请求方法（GET、POST、PUT、DELETE、OPTIONS、TRACE、CONNECT）。能写出基本的请求报文。\n\n能说出持久化连接的实现方法及其优点，以及如何通过Cookie解决客户端状态保持的问题。\n\n\n\n","source":"_posts/2017-04-11-HTTP：协议基础.markdown","raw":"---\nlayout: post\ntitle:  \"HTTP基础（1）：概述\"\ndate:   2017-04-11 20:16:00 +0800\ncategories: HTTP\n---\n## HTTP协议\nHTTP，HyperText Tranfer Protocol，超文本传输协议（超文本转移协议）。\n\nHTTP协议用于客户端和服务器端之间的通信。访问文本或图像等资源的一端称为服务端（即浏览器），提供资源相应的一端称为服务端（即Web服务器）。\n\n客户端向服务器端发起一个HTTP请求，服务器端在收到HTTP请求后根据请求报文中的内容进行响应，随后返回一个HTTP响应报文。客户端得到响应后便获取到了想要获取的资源或者相关错误信息（如资源不存在）。\n\n## HTTP通过请求和响应的交换达成通信\n\nHTTP协议规定，请求从客户端发出，最后服务器端响应该请求并返回。\n\n### HTTP请求\n\n客户端发送请求：\n\n    GET /index.html HTTP/1.1\n    Host: www.example.com\n\nGET表示访问服务器的类型，称为方法（method）。随后的字符串`/index.html`指明了请求访问的资源对象，叫做请求URI（request-URI）。然后是HTTP/1.1，即HTTP的版本号。\n\n综上，这段请求的意思：通过GET方法，访问`www.example.com`这台主机上的`/index.html`页面资源。\n\n请求报文由以下几部分组成：\n\n- 请求方法\n- 请求URI\n- HTTP版本协议\n- 可选的请求首部字段\n- 可选的内容实体\n\n以下是一个用POST方法发起的HTTP请求：\n\n    POST /user/login HTTP/1.1\n    Host: www.example.com\n    Connect: keep-alive\n    Content-Type: application/x-www-form-urlencode\n    Content-Length: 16\n    \n    user=dxy&pwd=123\n    \n第一部分分别是请求方法（POST)，请求URI（/user/login），版本协议（HTTP/1.1）。接下来是请求首部字段（Host：...）。最后是内容实体（user=dxy&pwd=123）。\n\n这段请求的意思是：用POST方法，向`www.example.com/user/login`提交一个表单数据，表单数据为`user=dxy&pwd=123`。\n\n### HTTP响应\n\n服务器端发送响应：\n\n    HTTP/1.1 200 OK\n    Date: Mon, 10 Apr 2017 14:17:00 GMT\n    Content-Length: 3987\n    Content-Type: text/html\n    \n    <html>\n    ...\n\n第一部分分别是版本协议（HTTP/1.1），响应状态码（200，status code）和原因短语（reason-phrase）。接下来是创建响应的日期时间，和其他首部字段的内容。最后是一行隔开，为资源实体的主体（entity body）。\n\n响应报文由以下几部分组成：\n- HTTP版本协议\n- 状态码和原因短语\n- 创建响应的日期和可选的首部字段\n- 资源实体的主体\n\n## HTTP是不保存状态的协议\n\nHTTP是一种无状态的协议（stateless）,这意味着HTTP协议不会保存请求和响应时的通信状态，即对请求和响应都不会做持久化处理。\n\n这就会导致用户在访问一个网站时，其访问的状态无法得到保存，因为每次发起的HTTP请求都是“新”的请求，与之前是否发送过无关。\n\n为了解决这个问题，可以通过Cookie技术来实现用户状态的保存。\n\n## 请求URI定位资源\n\nHTTP协议使用URI（统一资源标识符）来定位互联网上的资源。当客户端请求访问某个资源时，需要指定该资源的URI作为HTTP请求中的请求URI。指定的方式由以下两种：\n第一种是在Host首部字段中写明访问的主机地址（域名或IP）\n\n    GET /index.html HTTP/1.1\n    Host: www.example.com\n\n第二种是完整的URI地址：\n\n    GET http://www.example.com/index.html HTTP/1.1\n\n如果不是访问特定资源而是对服务器发起请求，可以用*来代替URI。下面这个例子是查询HTTP服务器端支持的HTTP方法种类。\n\n    OPTIONS * HTTP/1.1\n\n## 基本的HTTP请求方法\n\n### GET：获取资源\nGET方法用来请求访问已被URI识别的资源。指定的资源经过服务器端解析后返回响应的内容。\n请求：\n\n    GET /index.html HTTP/1.1\n    Host: www.example.com\n    If-Modified-Since: Mon, 10 Apr 2017 14:17:00 GMT\n\n响应：\n返回2017年4月10日14点17分00秒后更新过的index.html内容，若没有更新过，则返回304 Not Modified。\n\n### POST：传输实体主体\n\n尽管GET也可以传输实体主体，但是一般来说GET用于获取资源，而POST则专门用于传输资源或更新数据。\n\n请求：\n\n    POST /submit HTTP/1.1\n    Host: www.example.com\n    ConTent-Length: 16\n    \n    user=dxy&pwd=123\n\n响应：\n返回submit响应后的处理结果\n\n### PUT：传输文件\n\nPUT方法用来传输文件，要求请求报文的主体中包含文件内容，然后保存到URI指定的位置。\n\n但是由于HTTP/1.1的PUT方法没有验证机制，任何人都可以上传文件，所以存在安全性问题。现在一般只用来配合RESTFul API。\n\n### DELETE：删除文件\n\nDELETE方法与PUT方法正好相反，用于删除指定URI上的文件。现在一般也只用在RESTFul API上。\n\n### HEAD：获取报文首部\n\nHEAD方法用来获取报文的首部，确认URI的有效性和资源的更新日期。HEAD方法基本和GET方法一样，只是GET方法获取资源内容，而HEAD方法不获取资源内容，仅获取响应报文的首部。\n\n### OPTIONS：询问支持的方法\n\nOPTIONS方法用来查询针对请求URI指定的资源支持的方法。\n\n请求：\n\n    OPTIONS * HTTP/1.1\n    Host: www.example.com\n\n响应：\n\n    HTTP/1.1 200 OK\n    Allow：Get,Post,Head,Options\n\n### TRACE：追踪路径\n\nTRACE方法是让Web服务器端将之前的请求通信环回给客户端的方法。客户端通过TRACE方法可以查询发送出去的请求是怎样被加工修改的。\n\n由于TRACE方法容易引发XST（Cross-Site Tracing 跨站追踪）攻击，且本身就不常用，这里不作展开。\n\n### CONNECT：要求用隧道协议连接代理\n\nCONNECT方法要求在与代理服务器通信时建立隧道，实现使用隧道协议进行TCP通信。主要使用SSL（Secure Sockets Layer，安全套接字）和TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。\n\n## 建立持久连接以节省通信量\n\n在HTTP协议的初始版本中，每次发送HTTP协议都会经历一次TCP连接和关闭。随着Web的发展，一个网页会包含多个HTTP请求去加载JS文件、CSS文件、图片文件等等。如果每次HTTP请求都要断开TCP连接的话，就会带来额外的通信量。为此，HTTP/1.1新增了持久化连接（HTTP keep-alive）的方案。\n\n持久连接的特点是：只要任意一方没有明确需要断开TCP连接，那么客户端和服务器端将一直保持TCP连接，旨在一次TCP连接中进行多次HTTP请求和响应。\n\nHTTP/1.1中，所有的连接默认都是持久连接。当然这需要客户端和服务器端同时支持。\n\n持久连接使得多数请求能够以管线化的方式发送，可以让客户端并行发送多个HTTP请求，大大降低Web页面的显示速度。如果没有持久化连接，那么每次发起HTTP请求，下一个HTTP请求都得等待上一个HTTP请求得到响应后才能发送。\n\n## 使用Cookie进行状态管理\n\n一方面，无状态协议能够节省服务器计算资源的开销，另一方面由于无状态的存在使得状态管理成为一个难题。\n\n为了保留无状态协议同时实现状态管理，引入了Cookie技术，通过在请求和响应的报文中写入Cookie信息来控制客户端的状态。\n\n第一次请求（没有Cookie信息）：\n\n    GET /reader HTTP/1.1\n    Host: www.example.com\n    \n响应（服务器生成Cookie信息）：\n\n    HTTP/1.1 200 OK\n    Date: Mon, 10 Apr 2017 14:17:00 GMT\n    Server: Apache\n    Set-Cookie: sid=1342077140226724; path=/; expires=Wed, 10-OCT-12 07:12:20 GMT\n    Content-Type: text/plain; charset=UTF-8\n\n之后再发起请求时，会自带Cookie信息：\n\n    GET /other HTTP/1.1\n    Host: www.example.com\n    Cookie: sid=1342077140226724\n\n可见服务器通过Set-Cookie来通知客户端保存Cookie信息，客户端随后针对这个站点的HTTP请求都会在请求头部中加入Cookie字段。如此一来，服务器端在接收到请求时就能根据客户端传来的Cookie中的sid信息，来辨别客户端了，客户端的状态就能够得到保持。\n\n## 小结\n\nHTTP协议是通过请求和响应来进行通信的无状态协议。\n\n其中要注意HTTP请求的基本格式，其组成（请求方法，请求URI，版本协议，可选的首部字段，可选的传输实体）。HTTP响应的基本格式，以及其组成（版本协议，状态码，原因短语，可选的首部字段，资源实体的主体）。\n\n要熟悉常见的请求方法（GET、POST、PUT、DELETE、OPTIONS、TRACE、CONNECT）。能写出基本的请求报文。\n\n能说出持久化连接的实现方法及其优点，以及如何通过Cookie解决客户端状态保持的问题。\n\n\n\n","slug":"2017-04-11-HTTP：协议基础","published":1,"updated":"2017-07-30T15:23:05.000Z","comments":1,"photos":[],"link":"","_id":"cj5qx2mlj0009b4or99wocqa9","content":"<h2 id=\"HTTP协议\"><a href=\"#HTTP协议\" class=\"headerlink\" title=\"HTTP协议\"></a>HTTP协议</h2><p>HTTP，HyperText Tranfer Protocol，超文本传输协议（超文本转移协议）。</p>\n<p>HTTP协议用于客户端和服务器端之间的通信。访问文本或图像等资源的一端称为服务端（即浏览器），提供资源相应的一端称为服务端（即Web服务器）。</p>\n<p>客户端向服务器端发起一个HTTP请求，服务器端在收到HTTP请求后根据请求报文中的内容进行响应，随后返回一个HTTP响应报文。客户端得到响应后便获取到了想要获取的资源或者相关错误信息（如资源不存在）。</p>\n<h2 id=\"HTTP通过请求和响应的交换达成通信\"><a href=\"#HTTP通过请求和响应的交换达成通信\" class=\"headerlink\" title=\"HTTP通过请求和响应的交换达成通信\"></a>HTTP通过请求和响应的交换达成通信</h2><p>HTTP协议规定，请求从客户端发出，最后服务器端响应该请求并返回。</p>\n<h3 id=\"HTTP请求\"><a href=\"#HTTP请求\" class=\"headerlink\" title=\"HTTP请求\"></a>HTTP请求</h3><p>客户端发送请求：</p>\n<pre><code>GET /index.html HTTP/1.1\nHost: www.example.com\n</code></pre><p>GET表示访问服务器的类型，称为方法（method）。随后的字符串<code>/index.html</code>指明了请求访问的资源对象，叫做请求URI（request-URI）。然后是HTTP/1.1，即HTTP的版本号。</p>\n<p>综上，这段请求的意思：通过GET方法，访问<code>www.example.com</code>这台主机上的<code>/index.html</code>页面资源。</p>\n<p>请求报文由以下几部分组成：</p>\n<ul>\n<li>请求方法</li>\n<li>请求URI</li>\n<li>HTTP版本协议</li>\n<li>可选的请求首部字段</li>\n<li>可选的内容实体</li>\n</ul>\n<p>以下是一个用POST方法发起的HTTP请求：</p>\n<pre><code>POST /user/login HTTP/1.1\nHost: www.example.com\nConnect: keep-alive\nContent-Type: application/x-www-form-urlencode\nContent-Length: 16\n\nuser=dxy&amp;pwd=123\n</code></pre><p>第一部分分别是请求方法（POST)，请求URI（/user/login），版本协议（HTTP/1.1）。接下来是请求首部字段（Host：…）。最后是内容实体（user=dxy&amp;pwd=123）。</p>\n<p>这段请求的意思是：用POST方法，向<code>www.example.com/user/login</code>提交一个表单数据，表单数据为<code>user=dxy&amp;pwd=123</code>。</p>\n<h3 id=\"HTTP响应\"><a href=\"#HTTP响应\" class=\"headerlink\" title=\"HTTP响应\"></a>HTTP响应</h3><p>服务器端发送响应：</p>\n<pre><code>HTTP/1.1 200 OK\nDate: Mon, 10 Apr 2017 14:17:00 GMT\nContent-Length: 3987\nContent-Type: text/html\n\n&lt;html&gt;\n...\n</code></pre><p>第一部分分别是版本协议（HTTP/1.1），响应状态码（200，status code）和原因短语（reason-phrase）。接下来是创建响应的日期时间，和其他首部字段的内容。最后是一行隔开，为资源实体的主体（entity body）。</p>\n<p>响应报文由以下几部分组成：</p>\n<ul>\n<li>HTTP版本协议</li>\n<li>状态码和原因短语</li>\n<li>创建响应的日期和可选的首部字段</li>\n<li>资源实体的主体</li>\n</ul>\n<h2 id=\"HTTP是不保存状态的协议\"><a href=\"#HTTP是不保存状态的协议\" class=\"headerlink\" title=\"HTTP是不保存状态的协议\"></a>HTTP是不保存状态的协议</h2><p>HTTP是一种无状态的协议（stateless）,这意味着HTTP协议不会保存请求和响应时的通信状态，即对请求和响应都不会做持久化处理。</p>\n<p>这就会导致用户在访问一个网站时，其访问的状态无法得到保存，因为每次发起的HTTP请求都是“新”的请求，与之前是否发送过无关。</p>\n<p>为了解决这个问题，可以通过Cookie技术来实现用户状态的保存。</p>\n<h2 id=\"请求URI定位资源\"><a href=\"#请求URI定位资源\" class=\"headerlink\" title=\"请求URI定位资源\"></a>请求URI定位资源</h2><p>HTTP协议使用URI（统一资源标识符）来定位互联网上的资源。当客户端请求访问某个资源时，需要指定该资源的URI作为HTTP请求中的请求URI。指定的方式由以下两种：<br>第一种是在Host首部字段中写明访问的主机地址（域名或IP）</p>\n<pre><code>GET /index.html HTTP/1.1\nHost: www.example.com\n</code></pre><p>第二种是完整的URI地址：</p>\n<pre><code>GET http://www.example.com/index.html HTTP/1.1\n</code></pre><p>如果不是访问特定资源而是对服务器发起请求，可以用*来代替URI。下面这个例子是查询HTTP服务器端支持的HTTP方法种类。</p>\n<pre><code>OPTIONS * HTTP/1.1\n</code></pre><h2 id=\"基本的HTTP请求方法\"><a href=\"#基本的HTTP请求方法\" class=\"headerlink\" title=\"基本的HTTP请求方法\"></a>基本的HTTP请求方法</h2><h3 id=\"GET：获取资源\"><a href=\"#GET：获取资源\" class=\"headerlink\" title=\"GET：获取资源\"></a>GET：获取资源</h3><p>GET方法用来请求访问已被URI识别的资源。指定的资源经过服务器端解析后返回响应的内容。<br>请求：</p>\n<pre><code>GET /index.html HTTP/1.1\nHost: www.example.com\nIf-Modified-Since: Mon, 10 Apr 2017 14:17:00 GMT\n</code></pre><p>响应：<br>返回2017年4月10日14点17分00秒后更新过的index.html内容，若没有更新过，则返回304 Not Modified。</p>\n<h3 id=\"POST：传输实体主体\"><a href=\"#POST：传输实体主体\" class=\"headerlink\" title=\"POST：传输实体主体\"></a>POST：传输实体主体</h3><p>尽管GET也可以传输实体主体，但是一般来说GET用于获取资源，而POST则专门用于传输资源或更新数据。</p>\n<p>请求：</p>\n<pre><code>POST /submit HTTP/1.1\nHost: www.example.com\nConTent-Length: 16\n\nuser=dxy&amp;pwd=123\n</code></pre><p>响应：<br>返回submit响应后的处理结果</p>\n<h3 id=\"PUT：传输文件\"><a href=\"#PUT：传输文件\" class=\"headerlink\" title=\"PUT：传输文件\"></a>PUT：传输文件</h3><p>PUT方法用来传输文件，要求请求报文的主体中包含文件内容，然后保存到URI指定的位置。</p>\n<p>但是由于HTTP/1.1的PUT方法没有验证机制，任何人都可以上传文件，所以存在安全性问题。现在一般只用来配合RESTFul API。</p>\n<h3 id=\"DELETE：删除文件\"><a href=\"#DELETE：删除文件\" class=\"headerlink\" title=\"DELETE：删除文件\"></a>DELETE：删除文件</h3><p>DELETE方法与PUT方法正好相反，用于删除指定URI上的文件。现在一般也只用在RESTFul API上。</p>\n<h3 id=\"HEAD：获取报文首部\"><a href=\"#HEAD：获取报文首部\" class=\"headerlink\" title=\"HEAD：获取报文首部\"></a>HEAD：获取报文首部</h3><p>HEAD方法用来获取报文的首部，确认URI的有效性和资源的更新日期。HEAD方法基本和GET方法一样，只是GET方法获取资源内容，而HEAD方法不获取资源内容，仅获取响应报文的首部。</p>\n<h3 id=\"OPTIONS：询问支持的方法\"><a href=\"#OPTIONS：询问支持的方法\" class=\"headerlink\" title=\"OPTIONS：询问支持的方法\"></a>OPTIONS：询问支持的方法</h3><p>OPTIONS方法用来查询针对请求URI指定的资源支持的方法。</p>\n<p>请求：</p>\n<pre><code>OPTIONS * HTTP/1.1\nHost: www.example.com\n</code></pre><p>响应：</p>\n<pre><code>HTTP/1.1 200 OK\nAllow：Get,Post,Head,Options\n</code></pre><h3 id=\"TRACE：追踪路径\"><a href=\"#TRACE：追踪路径\" class=\"headerlink\" title=\"TRACE：追踪路径\"></a>TRACE：追踪路径</h3><p>TRACE方法是让Web服务器端将之前的请求通信环回给客户端的方法。客户端通过TRACE方法可以查询发送出去的请求是怎样被加工修改的。</p>\n<p>由于TRACE方法容易引发XST（Cross-Site Tracing 跨站追踪）攻击，且本身就不常用，这里不作展开。</p>\n<h3 id=\"CONNECT：要求用隧道协议连接代理\"><a href=\"#CONNECT：要求用隧道协议连接代理\" class=\"headerlink\" title=\"CONNECT：要求用隧道协议连接代理\"></a>CONNECT：要求用隧道协议连接代理</h3><p>CONNECT方法要求在与代理服务器通信时建立隧道，实现使用隧道协议进行TCP通信。主要使用SSL（Secure Sockets Layer，安全套接字）和TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。</p>\n<h2 id=\"建立持久连接以节省通信量\"><a href=\"#建立持久连接以节省通信量\" class=\"headerlink\" title=\"建立持久连接以节省通信量\"></a>建立持久连接以节省通信量</h2><p>在HTTP协议的初始版本中，每次发送HTTP协议都会经历一次TCP连接和关闭。随着Web的发展，一个网页会包含多个HTTP请求去加载JS文件、CSS文件、图片文件等等。如果每次HTTP请求都要断开TCP连接的话，就会带来额外的通信量。为此，HTTP/1.1新增了持久化连接（HTTP keep-alive）的方案。</p>\n<p>持久连接的特点是：只要任意一方没有明确需要断开TCP连接，那么客户端和服务器端将一直保持TCP连接，旨在一次TCP连接中进行多次HTTP请求和响应。</p>\n<p>HTTP/1.1中，所有的连接默认都是持久连接。当然这需要客户端和服务器端同时支持。</p>\n<p>持久连接使得多数请求能够以管线化的方式发送，可以让客户端并行发送多个HTTP请求，大大降低Web页面的显示速度。如果没有持久化连接，那么每次发起HTTP请求，下一个HTTP请求都得等待上一个HTTP请求得到响应后才能发送。</p>\n<h2 id=\"使用Cookie进行状态管理\"><a href=\"#使用Cookie进行状态管理\" class=\"headerlink\" title=\"使用Cookie进行状态管理\"></a>使用Cookie进行状态管理</h2><p>一方面，无状态协议能够节省服务器计算资源的开销，另一方面由于无状态的存在使得状态管理成为一个难题。</p>\n<p>为了保留无状态协议同时实现状态管理，引入了Cookie技术，通过在请求和响应的报文中写入Cookie信息来控制客户端的状态。</p>\n<p>第一次请求（没有Cookie信息）：</p>\n<pre><code>GET /reader HTTP/1.1\nHost: www.example.com\n</code></pre><p>响应（服务器生成Cookie信息）：</p>\n<pre><code>HTTP/1.1 200 OK\nDate: Mon, 10 Apr 2017 14:17:00 GMT\nServer: Apache\nSet-Cookie: sid=1342077140226724; path=/; expires=Wed, 10-OCT-12 07:12:20 GMT\nContent-Type: text/plain; charset=UTF-8\n</code></pre><p>之后再发起请求时，会自带Cookie信息：</p>\n<pre><code>GET /other HTTP/1.1\nHost: www.example.com\nCookie: sid=1342077140226724\n</code></pre><p>可见服务器通过Set-Cookie来通知客户端保存Cookie信息，客户端随后针对这个站点的HTTP请求都会在请求头部中加入Cookie字段。如此一来，服务器端在接收到请求时就能根据客户端传来的Cookie中的sid信息，来辨别客户端了，客户端的状态就能够得到保持。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>HTTP协议是通过请求和响应来进行通信的无状态协议。</p>\n<p>其中要注意HTTP请求的基本格式，其组成（请求方法，请求URI，版本协议，可选的首部字段，可选的传输实体）。HTTP响应的基本格式，以及其组成（版本协议，状态码，原因短语，可选的首部字段，资源实体的主体）。</p>\n<p>要熟悉常见的请求方法（GET、POST、PUT、DELETE、OPTIONS、TRACE、CONNECT）。能写出基本的请求报文。</p>\n<p>能说出持久化连接的实现方法及其优点，以及如何通过Cookie解决客户端状态保持的问题。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"HTTP协议\"><a href=\"#HTTP协议\" class=\"headerlink\" title=\"HTTP协议\"></a>HTTP协议</h2><p>HTTP，HyperText Tranfer Protocol，超文本传输协议（超文本转移协议）。</p>\n<p>HTTP协议用于客户端和服务器端之间的通信。访问文本或图像等资源的一端称为服务端（即浏览器），提供资源相应的一端称为服务端（即Web服务器）。</p>\n<p>客户端向服务器端发起一个HTTP请求，服务器端在收到HTTP请求后根据请求报文中的内容进行响应，随后返回一个HTTP响应报文。客户端得到响应后便获取到了想要获取的资源或者相关错误信息（如资源不存在）。</p>\n<h2 id=\"HTTP通过请求和响应的交换达成通信\"><a href=\"#HTTP通过请求和响应的交换达成通信\" class=\"headerlink\" title=\"HTTP通过请求和响应的交换达成通信\"></a>HTTP通过请求和响应的交换达成通信</h2><p>HTTP协议规定，请求从客户端发出，最后服务器端响应该请求并返回。</p>\n<h3 id=\"HTTP请求\"><a href=\"#HTTP请求\" class=\"headerlink\" title=\"HTTP请求\"></a>HTTP请求</h3><p>客户端发送请求：</p>\n<pre><code>GET /index.html HTTP/1.1\nHost: www.example.com\n</code></pre><p>GET表示访问服务器的类型，称为方法（method）。随后的字符串<code>/index.html</code>指明了请求访问的资源对象，叫做请求URI（request-URI）。然后是HTTP/1.1，即HTTP的版本号。</p>\n<p>综上，这段请求的意思：通过GET方法，访问<code>www.example.com</code>这台主机上的<code>/index.html</code>页面资源。</p>\n<p>请求报文由以下几部分组成：</p>\n<ul>\n<li>请求方法</li>\n<li>请求URI</li>\n<li>HTTP版本协议</li>\n<li>可选的请求首部字段</li>\n<li>可选的内容实体</li>\n</ul>\n<p>以下是一个用POST方法发起的HTTP请求：</p>\n<pre><code>POST /user/login HTTP/1.1\nHost: www.example.com\nConnect: keep-alive\nContent-Type: application/x-www-form-urlencode\nContent-Length: 16\n\nuser=dxy&amp;pwd=123\n</code></pre><p>第一部分分别是请求方法（POST)，请求URI（/user/login），版本协议（HTTP/1.1）。接下来是请求首部字段（Host：…）。最后是内容实体（user=dxy&amp;pwd=123）。</p>\n<p>这段请求的意思是：用POST方法，向<code>www.example.com/user/login</code>提交一个表单数据，表单数据为<code>user=dxy&amp;pwd=123</code>。</p>\n<h3 id=\"HTTP响应\"><a href=\"#HTTP响应\" class=\"headerlink\" title=\"HTTP响应\"></a>HTTP响应</h3><p>服务器端发送响应：</p>\n<pre><code>HTTP/1.1 200 OK\nDate: Mon, 10 Apr 2017 14:17:00 GMT\nContent-Length: 3987\nContent-Type: text/html\n\n&lt;html&gt;\n...\n</code></pre><p>第一部分分别是版本协议（HTTP/1.1），响应状态码（200，status code）和原因短语（reason-phrase）。接下来是创建响应的日期时间，和其他首部字段的内容。最后是一行隔开，为资源实体的主体（entity body）。</p>\n<p>响应报文由以下几部分组成：</p>\n<ul>\n<li>HTTP版本协议</li>\n<li>状态码和原因短语</li>\n<li>创建响应的日期和可选的首部字段</li>\n<li>资源实体的主体</li>\n</ul>\n<h2 id=\"HTTP是不保存状态的协议\"><a href=\"#HTTP是不保存状态的协议\" class=\"headerlink\" title=\"HTTP是不保存状态的协议\"></a>HTTP是不保存状态的协议</h2><p>HTTP是一种无状态的协议（stateless）,这意味着HTTP协议不会保存请求和响应时的通信状态，即对请求和响应都不会做持久化处理。</p>\n<p>这就会导致用户在访问一个网站时，其访问的状态无法得到保存，因为每次发起的HTTP请求都是“新”的请求，与之前是否发送过无关。</p>\n<p>为了解决这个问题，可以通过Cookie技术来实现用户状态的保存。</p>\n<h2 id=\"请求URI定位资源\"><a href=\"#请求URI定位资源\" class=\"headerlink\" title=\"请求URI定位资源\"></a>请求URI定位资源</h2><p>HTTP协议使用URI（统一资源标识符）来定位互联网上的资源。当客户端请求访问某个资源时，需要指定该资源的URI作为HTTP请求中的请求URI。指定的方式由以下两种：<br>第一种是在Host首部字段中写明访问的主机地址（域名或IP）</p>\n<pre><code>GET /index.html HTTP/1.1\nHost: www.example.com\n</code></pre><p>第二种是完整的URI地址：</p>\n<pre><code>GET http://www.example.com/index.html HTTP/1.1\n</code></pre><p>如果不是访问特定资源而是对服务器发起请求，可以用*来代替URI。下面这个例子是查询HTTP服务器端支持的HTTP方法种类。</p>\n<pre><code>OPTIONS * HTTP/1.1\n</code></pre><h2 id=\"基本的HTTP请求方法\"><a href=\"#基本的HTTP请求方法\" class=\"headerlink\" title=\"基本的HTTP请求方法\"></a>基本的HTTP请求方法</h2><h3 id=\"GET：获取资源\"><a href=\"#GET：获取资源\" class=\"headerlink\" title=\"GET：获取资源\"></a>GET：获取资源</h3><p>GET方法用来请求访问已被URI识别的资源。指定的资源经过服务器端解析后返回响应的内容。<br>请求：</p>\n<pre><code>GET /index.html HTTP/1.1\nHost: www.example.com\nIf-Modified-Since: Mon, 10 Apr 2017 14:17:00 GMT\n</code></pre><p>响应：<br>返回2017年4月10日14点17分00秒后更新过的index.html内容，若没有更新过，则返回304 Not Modified。</p>\n<h3 id=\"POST：传输实体主体\"><a href=\"#POST：传输实体主体\" class=\"headerlink\" title=\"POST：传输实体主体\"></a>POST：传输实体主体</h3><p>尽管GET也可以传输实体主体，但是一般来说GET用于获取资源，而POST则专门用于传输资源或更新数据。</p>\n<p>请求：</p>\n<pre><code>POST /submit HTTP/1.1\nHost: www.example.com\nConTent-Length: 16\n\nuser=dxy&amp;pwd=123\n</code></pre><p>响应：<br>返回submit响应后的处理结果</p>\n<h3 id=\"PUT：传输文件\"><a href=\"#PUT：传输文件\" class=\"headerlink\" title=\"PUT：传输文件\"></a>PUT：传输文件</h3><p>PUT方法用来传输文件，要求请求报文的主体中包含文件内容，然后保存到URI指定的位置。</p>\n<p>但是由于HTTP/1.1的PUT方法没有验证机制，任何人都可以上传文件，所以存在安全性问题。现在一般只用来配合RESTFul API。</p>\n<h3 id=\"DELETE：删除文件\"><a href=\"#DELETE：删除文件\" class=\"headerlink\" title=\"DELETE：删除文件\"></a>DELETE：删除文件</h3><p>DELETE方法与PUT方法正好相反，用于删除指定URI上的文件。现在一般也只用在RESTFul API上。</p>\n<h3 id=\"HEAD：获取报文首部\"><a href=\"#HEAD：获取报文首部\" class=\"headerlink\" title=\"HEAD：获取报文首部\"></a>HEAD：获取报文首部</h3><p>HEAD方法用来获取报文的首部，确认URI的有效性和资源的更新日期。HEAD方法基本和GET方法一样，只是GET方法获取资源内容，而HEAD方法不获取资源内容，仅获取响应报文的首部。</p>\n<h3 id=\"OPTIONS：询问支持的方法\"><a href=\"#OPTIONS：询问支持的方法\" class=\"headerlink\" title=\"OPTIONS：询问支持的方法\"></a>OPTIONS：询问支持的方法</h3><p>OPTIONS方法用来查询针对请求URI指定的资源支持的方法。</p>\n<p>请求：</p>\n<pre><code>OPTIONS * HTTP/1.1\nHost: www.example.com\n</code></pre><p>响应：</p>\n<pre><code>HTTP/1.1 200 OK\nAllow：Get,Post,Head,Options\n</code></pre><h3 id=\"TRACE：追踪路径\"><a href=\"#TRACE：追踪路径\" class=\"headerlink\" title=\"TRACE：追踪路径\"></a>TRACE：追踪路径</h3><p>TRACE方法是让Web服务器端将之前的请求通信环回给客户端的方法。客户端通过TRACE方法可以查询发送出去的请求是怎样被加工修改的。</p>\n<p>由于TRACE方法容易引发XST（Cross-Site Tracing 跨站追踪）攻击，且本身就不常用，这里不作展开。</p>\n<h3 id=\"CONNECT：要求用隧道协议连接代理\"><a href=\"#CONNECT：要求用隧道协议连接代理\" class=\"headerlink\" title=\"CONNECT：要求用隧道协议连接代理\"></a>CONNECT：要求用隧道协议连接代理</h3><p>CONNECT方法要求在与代理服务器通信时建立隧道，实现使用隧道协议进行TCP通信。主要使用SSL（Secure Sockets Layer，安全套接字）和TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。</p>\n<h2 id=\"建立持久连接以节省通信量\"><a href=\"#建立持久连接以节省通信量\" class=\"headerlink\" title=\"建立持久连接以节省通信量\"></a>建立持久连接以节省通信量</h2><p>在HTTP协议的初始版本中，每次发送HTTP协议都会经历一次TCP连接和关闭。随着Web的发展，一个网页会包含多个HTTP请求去加载JS文件、CSS文件、图片文件等等。如果每次HTTP请求都要断开TCP连接的话，就会带来额外的通信量。为此，HTTP/1.1新增了持久化连接（HTTP keep-alive）的方案。</p>\n<p>持久连接的特点是：只要任意一方没有明确需要断开TCP连接，那么客户端和服务器端将一直保持TCP连接，旨在一次TCP连接中进行多次HTTP请求和响应。</p>\n<p>HTTP/1.1中，所有的连接默认都是持久连接。当然这需要客户端和服务器端同时支持。</p>\n<p>持久连接使得多数请求能够以管线化的方式发送，可以让客户端并行发送多个HTTP请求，大大降低Web页面的显示速度。如果没有持久化连接，那么每次发起HTTP请求，下一个HTTP请求都得等待上一个HTTP请求得到响应后才能发送。</p>\n<h2 id=\"使用Cookie进行状态管理\"><a href=\"#使用Cookie进行状态管理\" class=\"headerlink\" title=\"使用Cookie进行状态管理\"></a>使用Cookie进行状态管理</h2><p>一方面，无状态协议能够节省服务器计算资源的开销，另一方面由于无状态的存在使得状态管理成为一个难题。</p>\n<p>为了保留无状态协议同时实现状态管理，引入了Cookie技术，通过在请求和响应的报文中写入Cookie信息来控制客户端的状态。</p>\n<p>第一次请求（没有Cookie信息）：</p>\n<pre><code>GET /reader HTTP/1.1\nHost: www.example.com\n</code></pre><p>响应（服务器生成Cookie信息）：</p>\n<pre><code>HTTP/1.1 200 OK\nDate: Mon, 10 Apr 2017 14:17:00 GMT\nServer: Apache\nSet-Cookie: sid=1342077140226724; path=/; expires=Wed, 10-OCT-12 07:12:20 GMT\nContent-Type: text/plain; charset=UTF-8\n</code></pre><p>之后再发起请求时，会自带Cookie信息：</p>\n<pre><code>GET /other HTTP/1.1\nHost: www.example.com\nCookie: sid=1342077140226724\n</code></pre><p>可见服务器通过Set-Cookie来通知客户端保存Cookie信息，客户端随后针对这个站点的HTTP请求都会在请求头部中加入Cookie字段。如此一来，服务器端在接收到请求时就能根据客户端传来的Cookie中的sid信息，来辨别客户端了，客户端的状态就能够得到保持。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>HTTP协议是通过请求和响应来进行通信的无状态协议。</p>\n<p>其中要注意HTTP请求的基本格式，其组成（请求方法，请求URI，版本协议，可选的首部字段，可选的传输实体）。HTTP响应的基本格式，以及其组成（版本协议，状态码，原因短语，可选的首部字段，资源实体的主体）。</p>\n<p>要熟悉常见的请求方法（GET、POST、PUT、DELETE、OPTIONS、TRACE、CONNECT）。能写出基本的请求报文。</p>\n<p>能说出持久化连接的实现方法及其优点，以及如何通过Cookie解决客户端状态保持的问题。</p>\n"},{"layout":"post","title":"JavaScript：基本数据类型整理","date":"2017-04-11T08:21:00.000Z","_content":"- Undefined\n- Null\n- Boolean\n- String\n- Number\n\n## Undefined\n\nUndefined类型只有一个undefined值。\n\n用var声明但未赋值的变量，其值为undefined。\n\n    var a;\n    alert(a); //undefined\n\n使用一个未经声明的变量，typeof检测为undefined，但使用时会报错。\n\n    alert(a); //Error\n\n访问一个对象中不存在的属性时，其值为undefined，不会报错。\n\n    var o = {a:1};\n    alert(o.b); //undefined\n\n故undefined不能与typeof结合使用来判断一个变量是否被声明。\n\n    var a;\n    alert(typeof a); //undefined\n    alert(typeof b); //undefined ，变量b并没有被声明\n\n## Null\n\nNull表示一个空对象指针，typeof null会返回object。\n\n    var o = null;\n    alert(typeof o); //object\n\nnull可以作为空对象的占位符，故如果定义的变量将来用于存放对象，那么最好将该变量初始化为null，这样通过typeof可以判断相应的变量是否保存了一个对象的引用。\n\n    var o = null;\n    //...\n    if(o == null){\n        //do something\n    }\n\nundefined是派生自null的，故下面相等性测试返回的是true\n\n    alert(undefined == null); //true\n\n注意：undefined与null很大的一个区别在于，无论什么情况下，undefined一般都不会被用作显式地初始化变量，而null则推荐用来作为空对象指针。\n\n## Boolean\n\nECMAScript中，所有类型的值都有与Boolean类型对应的值，我们可以通过转型函数Boolean()来进行转换。\n\n- String类型，非空字符串均返回true，空字符串返回false\n- Number类型，非零数字值均返回true，0和NaN返回false\n- Object类型，任何非空对象均返回true，null返回false\n- Undefined类型，恒为false\n\n这个转换在流控制语句中如if语句中，会将if()中的变量自动转换成对应的Boolean值，以下代码是相等的：\n\n    var foo = \"bar\";\n    \n    if(foo){\n        //do something\n    }\n    \n    //上下两段代码是相同的\n    \n    if(Boolean(foo)){\n        //do something\n    }\n\n## Number\n\nNumber类型使用IEEE754格式来表示整数和浮点数，浮点数值的最高精度是17位小数，故在计算时会产生舍入误差的问题。所以永远不要测试某个特定的浮点数值。\n\n    var a = 0.1;\n    var b = 0.2;\n    alert(a+b == 0.3) //false，0.1+0.2会变成0.30000000000000004\n\n### 数值范围\n\n- 正无穷：+Infinity\n- 能够表示的最大正数：Number.MAX_VALUE\n- 能够表示的最小正数：Number.MIN_VALUE\n- 0\n- 能够表示的最大负数：-Number.MIN_VALUE\n- 能够表示的最小负数：-Number.MAX_VALUE\n- 负无穷：-Infinity\n\n### NaN\n\nNaN，Not a Number，用于表示一个本来要返回数值的操作数未返回数值的情况，此时不抛出错误，也不会影响其他代码的执行。\n\n除了类型转换时会出现NaN之外，0/0也会返回NaN。\n\n特点：\n\n- NaN与任何数值操作均为NaN\n- NaN与任何值都不相等，包括NaN自身\n\n可以用isNaN()函数来判断一个值是否“不是数值”，isNaN()在接收到一个参数后，会尝试将这个值转换为数值。\n\n    isNaN(NaN); //true\n    isNaN(10); //false\n    isNaN(\"10\"); //false，字符串\"10\"可以转换成数字10\n    isNaN(\"blue\"); //true，字符串\"blue\"不能被转换成数字\n    isNaN(true); //false，布尔值true可以被转换成数字1\n    isNaN(false); //false，布尔值false可以被转换成数字0\n\n### 数值转换\n\n- Number()，转型函数\n- parseInt()，全局函数\n- parseFloat()，全局函数\n\n#### Number()\n\n- Boolean，true 1，false 0\n- Null，null 0\n- Undefined，undefined NaN\n- String，字符串只包含数字时（包括+/-，整数/浮点数） 对应数字，空字符串\"\" 0\n- Object，先valueOf()若NaN则toString()，转换规则跟上述一致\n\n\n#### parseInt()\n\nparseInt接收两个参数，第一个是待转换的值，第二个是基数（二进制、八进制、十进制、十六进制），其他进制不常用，以下仅讨论十进制。\n\n与Number()的几个区别是，\n\n 1. Number()接收任意类型的参数，而parseInt()只接收String，非String一律为NaN。\n 2. parseInt()会对传入的字符串从左到右进行遍历，从第一个数字或正负号开始，到第一个非数字结束，字符串中不存在数字就一定会是NaN，忽略其他非数字的字符；Number()中如果字符串存在非数字字符就会是NaN。\n 3. 空字符串Number()转换成0，parseInt()转换成NaN。\n 4. parseInt()只会转换成整数\n\n示例：\n\n    var n0 = true;\n    alert(Number(n0)); //1\n    alert(parseInt(n0,10)); //NaN\n    \n    var n1 = \"1234blue\";\n    alert(Number(n1)); //NaN\n    alert(parseInt(n1,10)); //1234\n\n    var n2 = \"\";\n    alert(Number(n2)); //0\n    alert(parseInt(n2,10)); //NaN\n    \n    var n3 = \"22.5\";\n    alert(Number(n3)); //22.5\n    alert(parseInt(n3,10)); //22\n\n#### parseFloat()\n\nparseFloat()与parseInt()的解析机制基本相同，以下为两个比较主要的区别：\n\n 1. parseFloat()没有第二个参数，只解析十进制\n 2. parseFloat()识别小数点，遇到第二个小数点停止解析\n\n## String\n\nString类型用于表示由零或多个16位Unicode字符组成的字符序列，即字符串。\n\n用双引号表示的字符串与用单引号表示的字符串完全相同。\n\n### 字符字面量\n\n即转义序列，用于表示非打印字符或其他用途的字符。常见的有：\n\n- \\n 换行\n- \\t 制表\n- \\r 回车\n- \\b 退格\n- \\xnn 以十六进制代码nn表示一个字符（n为0~F）\n- \\unnnn 以十六进制代码nnnn表示的一个Unicode字符（其中n为0~f)\n\n注意：\\unnnn类型的字符虽然在代码中占6个字符，但是在length属性中只占1个字符。\n\n但是如果字符串中包含双字节字符，那么length属性可能不会精确地返回字符串中的字符数目。\n\n### 字符串的特点\n\n字符串是不可变的，一旦创建，它们的值就不能改变。要改变的话，则会先销毁原来的字符串，再用一个包含新值的字符串填充该变量。\n\n    var lang = \"Java\";\n    lang = lang + \"Script\";\n\n 1. 首先创建一个10字符的新字符串\n 2. 接着填充\"Java\"和\"Script\"\n 3. 将新字符串赋值给lang\n 4. 删除\"Java\"和\"Script\"\n\n### 转换为字符串\n\n转换为字符串有两种方法，分别是toString()和String()。\n\n还有一种是用加号操作符，这里先不作讨论。\n\n#### toString()\n\n几乎每个值都有toString()方法，返回响应值的字符串表现。\n\n- Number，即数字本身，还可以传递一个参数以指定基数\n- Boolean，即\"true\"或\"false\"\n- String，即字符串本身\n\n示例：\n\n    var num = 10;\n    alert(num.toString()); //10，默认十进制\n    alert(num.toString(2)); //1010，二进制\n    alert(num.toString(16)); //a,十六进制\n\nNull和Undefined没有toString方法。\n\n#### String()\n\n就像Number()和parseInt()的关系一样，String()转型函数能够接收任意类型的值作为参数，但是区别在于Number()和parseInt()之间相对平等，而String()更像是toString()的超集。\n\n- 如果传入的值有toString()方法，则调用该方法\n- Null类型，返回\"null\"\n- Undefined类型，返回\"undefined\"\n\n不过String()在转换数值时就不能指定基数了。\n\n## 小结\n\nJavaScript基本数据类型有5种，分别是Null，Undefined，Boolean，Number和String。其中，Undefined派生自Null，故null==undefined返回true。\n\nBoolean只有true和false两个值，注意Boolean()转型函数的转换规则，以及与if()等流程控制语句的关系。\n\nNumber类型不区分整数和浮点数，要注意其数值范围以及精度的问题，要当心0.1+0.2不等于0.3的判断问题。还有对NaN的理解，注意NaN与任何值都不相等的特性。此外，Number()转型函数，parseInt()和parseFloat()各有机制上的共通点和不同处，要做好区别。\n\nString类型，包含字符字面量，转义字符，字符串的特点以及字符串的转换，重点理解如何使用toString()和String()来进行字符串转换。\n\n\n","source":"_posts/2017-04-11-JavaScript：基本数据类型整理.markdown","raw":"---\nlayout: post\ntitle:  \"JavaScript：基本数据类型整理\"\ndate:   2017-04-11 16:21:00 +0800\ncategories: JavaScript\n---\n- Undefined\n- Null\n- Boolean\n- String\n- Number\n\n## Undefined\n\nUndefined类型只有一个undefined值。\n\n用var声明但未赋值的变量，其值为undefined。\n\n    var a;\n    alert(a); //undefined\n\n使用一个未经声明的变量，typeof检测为undefined，但使用时会报错。\n\n    alert(a); //Error\n\n访问一个对象中不存在的属性时，其值为undefined，不会报错。\n\n    var o = {a:1};\n    alert(o.b); //undefined\n\n故undefined不能与typeof结合使用来判断一个变量是否被声明。\n\n    var a;\n    alert(typeof a); //undefined\n    alert(typeof b); //undefined ，变量b并没有被声明\n\n## Null\n\nNull表示一个空对象指针，typeof null会返回object。\n\n    var o = null;\n    alert(typeof o); //object\n\nnull可以作为空对象的占位符，故如果定义的变量将来用于存放对象，那么最好将该变量初始化为null，这样通过typeof可以判断相应的变量是否保存了一个对象的引用。\n\n    var o = null;\n    //...\n    if(o == null){\n        //do something\n    }\n\nundefined是派生自null的，故下面相等性测试返回的是true\n\n    alert(undefined == null); //true\n\n注意：undefined与null很大的一个区别在于，无论什么情况下，undefined一般都不会被用作显式地初始化变量，而null则推荐用来作为空对象指针。\n\n## Boolean\n\nECMAScript中，所有类型的值都有与Boolean类型对应的值，我们可以通过转型函数Boolean()来进行转换。\n\n- String类型，非空字符串均返回true，空字符串返回false\n- Number类型，非零数字值均返回true，0和NaN返回false\n- Object类型，任何非空对象均返回true，null返回false\n- Undefined类型，恒为false\n\n这个转换在流控制语句中如if语句中，会将if()中的变量自动转换成对应的Boolean值，以下代码是相等的：\n\n    var foo = \"bar\";\n    \n    if(foo){\n        //do something\n    }\n    \n    //上下两段代码是相同的\n    \n    if(Boolean(foo)){\n        //do something\n    }\n\n## Number\n\nNumber类型使用IEEE754格式来表示整数和浮点数，浮点数值的最高精度是17位小数，故在计算时会产生舍入误差的问题。所以永远不要测试某个特定的浮点数值。\n\n    var a = 0.1;\n    var b = 0.2;\n    alert(a+b == 0.3) //false，0.1+0.2会变成0.30000000000000004\n\n### 数值范围\n\n- 正无穷：+Infinity\n- 能够表示的最大正数：Number.MAX_VALUE\n- 能够表示的最小正数：Number.MIN_VALUE\n- 0\n- 能够表示的最大负数：-Number.MIN_VALUE\n- 能够表示的最小负数：-Number.MAX_VALUE\n- 负无穷：-Infinity\n\n### NaN\n\nNaN，Not a Number，用于表示一个本来要返回数值的操作数未返回数值的情况，此时不抛出错误，也不会影响其他代码的执行。\n\n除了类型转换时会出现NaN之外，0/0也会返回NaN。\n\n特点：\n\n- NaN与任何数值操作均为NaN\n- NaN与任何值都不相等，包括NaN自身\n\n可以用isNaN()函数来判断一个值是否“不是数值”，isNaN()在接收到一个参数后，会尝试将这个值转换为数值。\n\n    isNaN(NaN); //true\n    isNaN(10); //false\n    isNaN(\"10\"); //false，字符串\"10\"可以转换成数字10\n    isNaN(\"blue\"); //true，字符串\"blue\"不能被转换成数字\n    isNaN(true); //false，布尔值true可以被转换成数字1\n    isNaN(false); //false，布尔值false可以被转换成数字0\n\n### 数值转换\n\n- Number()，转型函数\n- parseInt()，全局函数\n- parseFloat()，全局函数\n\n#### Number()\n\n- Boolean，true 1，false 0\n- Null，null 0\n- Undefined，undefined NaN\n- String，字符串只包含数字时（包括+/-，整数/浮点数） 对应数字，空字符串\"\" 0\n- Object，先valueOf()若NaN则toString()，转换规则跟上述一致\n\n\n#### parseInt()\n\nparseInt接收两个参数，第一个是待转换的值，第二个是基数（二进制、八进制、十进制、十六进制），其他进制不常用，以下仅讨论十进制。\n\n与Number()的几个区别是，\n\n 1. Number()接收任意类型的参数，而parseInt()只接收String，非String一律为NaN。\n 2. parseInt()会对传入的字符串从左到右进行遍历，从第一个数字或正负号开始，到第一个非数字结束，字符串中不存在数字就一定会是NaN，忽略其他非数字的字符；Number()中如果字符串存在非数字字符就会是NaN。\n 3. 空字符串Number()转换成0，parseInt()转换成NaN。\n 4. parseInt()只会转换成整数\n\n示例：\n\n    var n0 = true;\n    alert(Number(n0)); //1\n    alert(parseInt(n0,10)); //NaN\n    \n    var n1 = \"1234blue\";\n    alert(Number(n1)); //NaN\n    alert(parseInt(n1,10)); //1234\n\n    var n2 = \"\";\n    alert(Number(n2)); //0\n    alert(parseInt(n2,10)); //NaN\n    \n    var n3 = \"22.5\";\n    alert(Number(n3)); //22.5\n    alert(parseInt(n3,10)); //22\n\n#### parseFloat()\n\nparseFloat()与parseInt()的解析机制基本相同，以下为两个比较主要的区别：\n\n 1. parseFloat()没有第二个参数，只解析十进制\n 2. parseFloat()识别小数点，遇到第二个小数点停止解析\n\n## String\n\nString类型用于表示由零或多个16位Unicode字符组成的字符序列，即字符串。\n\n用双引号表示的字符串与用单引号表示的字符串完全相同。\n\n### 字符字面量\n\n即转义序列，用于表示非打印字符或其他用途的字符。常见的有：\n\n- \\n 换行\n- \\t 制表\n- \\r 回车\n- \\b 退格\n- \\xnn 以十六进制代码nn表示一个字符（n为0~F）\n- \\unnnn 以十六进制代码nnnn表示的一个Unicode字符（其中n为0~f)\n\n注意：\\unnnn类型的字符虽然在代码中占6个字符，但是在length属性中只占1个字符。\n\n但是如果字符串中包含双字节字符，那么length属性可能不会精确地返回字符串中的字符数目。\n\n### 字符串的特点\n\n字符串是不可变的，一旦创建，它们的值就不能改变。要改变的话，则会先销毁原来的字符串，再用一个包含新值的字符串填充该变量。\n\n    var lang = \"Java\";\n    lang = lang + \"Script\";\n\n 1. 首先创建一个10字符的新字符串\n 2. 接着填充\"Java\"和\"Script\"\n 3. 将新字符串赋值给lang\n 4. 删除\"Java\"和\"Script\"\n\n### 转换为字符串\n\n转换为字符串有两种方法，分别是toString()和String()。\n\n还有一种是用加号操作符，这里先不作讨论。\n\n#### toString()\n\n几乎每个值都有toString()方法，返回响应值的字符串表现。\n\n- Number，即数字本身，还可以传递一个参数以指定基数\n- Boolean，即\"true\"或\"false\"\n- String，即字符串本身\n\n示例：\n\n    var num = 10;\n    alert(num.toString()); //10，默认十进制\n    alert(num.toString(2)); //1010，二进制\n    alert(num.toString(16)); //a,十六进制\n\nNull和Undefined没有toString方法。\n\n#### String()\n\n就像Number()和parseInt()的关系一样，String()转型函数能够接收任意类型的值作为参数，但是区别在于Number()和parseInt()之间相对平等，而String()更像是toString()的超集。\n\n- 如果传入的值有toString()方法，则调用该方法\n- Null类型，返回\"null\"\n- Undefined类型，返回\"undefined\"\n\n不过String()在转换数值时就不能指定基数了。\n\n## 小结\n\nJavaScript基本数据类型有5种，分别是Null，Undefined，Boolean，Number和String。其中，Undefined派生自Null，故null==undefined返回true。\n\nBoolean只有true和false两个值，注意Boolean()转型函数的转换规则，以及与if()等流程控制语句的关系。\n\nNumber类型不区分整数和浮点数，要注意其数值范围以及精度的问题，要当心0.1+0.2不等于0.3的判断问题。还有对NaN的理解，注意NaN与任何值都不相等的特性。此外，Number()转型函数，parseInt()和parseFloat()各有机制上的共通点和不同处，要做好区别。\n\nString类型，包含字符字面量，转义字符，字符串的特点以及字符串的转换，重点理解如何使用toString()和String()来进行字符串转换。\n\n\n","slug":"2017-04-11-JavaScript：基本数据类型整理","published":1,"updated":"2017-07-30T15:22:03.000Z","comments":1,"photos":[],"link":"","_id":"cj5qx2mlm000bb4orip0ur65y","content":"<ul>\n<li>Undefined</li>\n<li>Null</li>\n<li>Boolean</li>\n<li>String</li>\n<li>Number</li>\n</ul>\n<h2 id=\"Undefined\"><a href=\"#Undefined\" class=\"headerlink\" title=\"Undefined\"></a>Undefined</h2><p>Undefined类型只有一个undefined值。</p>\n<p>用var声明但未赋值的变量，其值为undefined。</p>\n<pre><code>var a;\nalert(a); //undefined\n</code></pre><p>使用一个未经声明的变量，typeof检测为undefined，但使用时会报错。</p>\n<pre><code>alert(a); //Error\n</code></pre><p>访问一个对象中不存在的属性时，其值为undefined，不会报错。</p>\n<pre><code>var o = {a:1};\nalert(o.b); //undefined\n</code></pre><p>故undefined不能与typeof结合使用来判断一个变量是否被声明。</p>\n<pre><code>var a;\nalert(typeof a); //undefined\nalert(typeof b); //undefined ，变量b并没有被声明\n</code></pre><h2 id=\"Null\"><a href=\"#Null\" class=\"headerlink\" title=\"Null\"></a>Null</h2><p>Null表示一个空对象指针，typeof null会返回object。</p>\n<pre><code>var o = null;\nalert(typeof o); //object\n</code></pre><p>null可以作为空对象的占位符，故如果定义的变量将来用于存放对象，那么最好将该变量初始化为null，这样通过typeof可以判断相应的变量是否保存了一个对象的引用。</p>\n<pre><code>var o = null;\n//...\nif(o == null){\n    //do something\n}\n</code></pre><p>undefined是派生自null的，故下面相等性测试返回的是true</p>\n<pre><code>alert(undefined == null); //true\n</code></pre><p>注意：undefined与null很大的一个区别在于，无论什么情况下，undefined一般都不会被用作显式地初始化变量，而null则推荐用来作为空对象指针。</p>\n<h2 id=\"Boolean\"><a href=\"#Boolean\" class=\"headerlink\" title=\"Boolean\"></a>Boolean</h2><p>ECMAScript中，所有类型的值都有与Boolean类型对应的值，我们可以通过转型函数Boolean()来进行转换。</p>\n<ul>\n<li>String类型，非空字符串均返回true，空字符串返回false</li>\n<li>Number类型，非零数字值均返回true，0和NaN返回false</li>\n<li>Object类型，任何非空对象均返回true，null返回false</li>\n<li>Undefined类型，恒为false</li>\n</ul>\n<p>这个转换在流控制语句中如if语句中，会将if()中的变量自动转换成对应的Boolean值，以下代码是相等的：</p>\n<pre><code>var foo = &quot;bar&quot;;\n\nif(foo){\n    //do something\n}\n\n//上下两段代码是相同的\n\nif(Boolean(foo)){\n    //do something\n}\n</code></pre><h2 id=\"Number\"><a href=\"#Number\" class=\"headerlink\" title=\"Number\"></a>Number</h2><p>Number类型使用IEEE754格式来表示整数和浮点数，浮点数值的最高精度是17位小数，故在计算时会产生舍入误差的问题。所以永远不要测试某个特定的浮点数值。</p>\n<pre><code>var a = 0.1;\nvar b = 0.2;\nalert(a+b == 0.3) //false，0.1+0.2会变成0.30000000000000004\n</code></pre><h3 id=\"数值范围\"><a href=\"#数值范围\" class=\"headerlink\" title=\"数值范围\"></a>数值范围</h3><ul>\n<li>正无穷：+Infinity</li>\n<li>能够表示的最大正数：Number.MAX_VALUE</li>\n<li>能够表示的最小正数：Number.MIN_VALUE</li>\n<li>0</li>\n<li>能够表示的最大负数：-Number.MIN_VALUE</li>\n<li>能够表示的最小负数：-Number.MAX_VALUE</li>\n<li>负无穷：-Infinity</li>\n</ul>\n<h3 id=\"NaN\"><a href=\"#NaN\" class=\"headerlink\" title=\"NaN\"></a>NaN</h3><p>NaN，Not a Number，用于表示一个本来要返回数值的操作数未返回数值的情况，此时不抛出错误，也不会影响其他代码的执行。</p>\n<p>除了类型转换时会出现NaN之外，0/0也会返回NaN。</p>\n<p>特点：</p>\n<ul>\n<li>NaN与任何数值操作均为NaN</li>\n<li>NaN与任何值都不相等，包括NaN自身</li>\n</ul>\n<p>可以用isNaN()函数来判断一个值是否“不是数值”，isNaN()在接收到一个参数后，会尝试将这个值转换为数值。</p>\n<pre><code>isNaN(NaN); //true\nisNaN(10); //false\nisNaN(&quot;10&quot;); //false，字符串&quot;10&quot;可以转换成数字10\nisNaN(&quot;blue&quot;); //true，字符串&quot;blue&quot;不能被转换成数字\nisNaN(true); //false，布尔值true可以被转换成数字1\nisNaN(false); //false，布尔值false可以被转换成数字0\n</code></pre><h3 id=\"数值转换\"><a href=\"#数值转换\" class=\"headerlink\" title=\"数值转换\"></a>数值转换</h3><ul>\n<li>Number()，转型函数</li>\n<li>parseInt()，全局函数</li>\n<li>parseFloat()，全局函数</li>\n</ul>\n<h4 id=\"Number-1\"><a href=\"#Number-1\" class=\"headerlink\" title=\"Number()\"></a>Number()</h4><ul>\n<li>Boolean，true 1，false 0</li>\n<li>Null，null 0</li>\n<li>Undefined，undefined NaN</li>\n<li>String，字符串只包含数字时（包括+/-，整数/浮点数） 对应数字，空字符串”” 0</li>\n<li>Object，先valueOf()若NaN则toString()，转换规则跟上述一致</li>\n</ul>\n<h4 id=\"parseInt\"><a href=\"#parseInt\" class=\"headerlink\" title=\"parseInt()\"></a>parseInt()</h4><p>parseInt接收两个参数，第一个是待转换的值，第二个是基数（二进制、八进制、十进制、十六进制），其他进制不常用，以下仅讨论十进制。</p>\n<p>与Number()的几个区别是，</p>\n<ol>\n<li>Number()接收任意类型的参数，而parseInt()只接收String，非String一律为NaN。</li>\n<li>parseInt()会对传入的字符串从左到右进行遍历，从第一个数字或正负号开始，到第一个非数字结束，字符串中不存在数字就一定会是NaN，忽略其他非数字的字符；Number()中如果字符串存在非数字字符就会是NaN。</li>\n<li>空字符串Number()转换成0，parseInt()转换成NaN。</li>\n<li>parseInt()只会转换成整数</li>\n</ol>\n<p>示例：</p>\n<pre><code>var n0 = true;\nalert(Number(n0)); //1\nalert(parseInt(n0,10)); //NaN\n\nvar n1 = &quot;1234blue&quot;;\nalert(Number(n1)); //NaN\nalert(parseInt(n1,10)); //1234\n\nvar n2 = &quot;&quot;;\nalert(Number(n2)); //0\nalert(parseInt(n2,10)); //NaN\n\nvar n3 = &quot;22.5&quot;;\nalert(Number(n3)); //22.5\nalert(parseInt(n3,10)); //22\n</code></pre><h4 id=\"parseFloat\"><a href=\"#parseFloat\" class=\"headerlink\" title=\"parseFloat()\"></a>parseFloat()</h4><p>parseFloat()与parseInt()的解析机制基本相同，以下为两个比较主要的区别：</p>\n<ol>\n<li>parseFloat()没有第二个参数，只解析十进制</li>\n<li>parseFloat()识别小数点，遇到第二个小数点停止解析</li>\n</ol>\n<h2 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h2><p>String类型用于表示由零或多个16位Unicode字符组成的字符序列，即字符串。</p>\n<p>用双引号表示的字符串与用单引号表示的字符串完全相同。</p>\n<h3 id=\"字符字面量\"><a href=\"#字符字面量\" class=\"headerlink\" title=\"字符字面量\"></a>字符字面量</h3><p>即转义序列，用于表示非打印字符或其他用途的字符。常见的有：</p>\n<ul>\n<li>\\n 换行</li>\n<li>\\t 制表</li>\n<li>\\r 回车</li>\n<li>\\b 退格</li>\n<li>\\xnn 以十六进制代码nn表示一个字符（n为0~F）</li>\n<li>\\unnnn 以十六进制代码nnnn表示的一个Unicode字符（其中n为0~f)</li>\n</ul>\n<p>注意：\\unnnn类型的字符虽然在代码中占6个字符，但是在length属性中只占1个字符。</p>\n<p>但是如果字符串中包含双字节字符，那么length属性可能不会精确地返回字符串中的字符数目。</p>\n<h3 id=\"字符串的特点\"><a href=\"#字符串的特点\" class=\"headerlink\" title=\"字符串的特点\"></a>字符串的特点</h3><p>字符串是不可变的，一旦创建，它们的值就不能改变。要改变的话，则会先销毁原来的字符串，再用一个包含新值的字符串填充该变量。</p>\n<pre><code>var lang = &quot;Java&quot;;\nlang = lang + &quot;Script&quot;;\n</code></pre><ol>\n<li>首先创建一个10字符的新字符串</li>\n<li>接着填充”Java”和”Script”</li>\n<li>将新字符串赋值给lang</li>\n<li>删除”Java”和”Script”</li>\n</ol>\n<h3 id=\"转换为字符串\"><a href=\"#转换为字符串\" class=\"headerlink\" title=\"转换为字符串\"></a>转换为字符串</h3><p>转换为字符串有两种方法，分别是toString()和String()。</p>\n<p>还有一种是用加号操作符，这里先不作讨论。</p>\n<h4 id=\"toString-NaN\"><a href=\"#toString-NaN\" class=\"headerlink\" title=\"toString()\"></a>toString()</h4><p>几乎每个值都有toString()方法，返回响应值的字符串表现。</p>\n<ul>\n<li>Number，即数字本身，还可以传递一个参数以指定基数</li>\n<li>Boolean，即”true”或”false”</li>\n<li>String，即字符串本身</li>\n</ul>\n<p>示例：</p>\n<pre><code>var num = 10;\nalert(num.toString()); //10，默认十进制\nalert(num.toString(2)); //1010，二进制\nalert(num.toString(16)); //a,十六进制\n</code></pre><p>Null和Undefined没有toString方法。</p>\n<h4 id=\"String-1\"><a href=\"#String-1\" class=\"headerlink\" title=\"String()\"></a>String()</h4><p>就像Number()和parseInt()的关系一样，String()转型函数能够接收任意类型的值作为参数，但是区别在于Number()和parseInt()之间相对平等，而String()更像是toString()的超集。</p>\n<ul>\n<li>如果传入的值有toString()方法，则调用该方法</li>\n<li>Null类型，返回”null”</li>\n<li>Undefined类型，返回”undefined”</li>\n</ul>\n<p>不过String()在转换数值时就不能指定基数了。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>JavaScript基本数据类型有5种，分别是Null，Undefined，Boolean，Number和String。其中，Undefined派生自Null，故null==undefined返回true。</p>\n<p>Boolean只有true和false两个值，注意Boolean()转型函数的转换规则，以及与if()等流程控制语句的关系。</p>\n<p>Number类型不区分整数和浮点数，要注意其数值范围以及精度的问题，要当心0.1+0.2不等于0.3的判断问题。还有对NaN的理解，注意NaN与任何值都不相等的特性。此外，Number()转型函数，parseInt()和parseFloat()各有机制上的共通点和不同处，要做好区别。</p>\n<p>String类型，包含字符字面量，转义字符，字符串的特点以及字符串的转换，重点理解如何使用toString()和String()来进行字符串转换。</p>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>Undefined</li>\n<li>Null</li>\n<li>Boolean</li>\n<li>String</li>\n<li>Number</li>\n</ul>\n<h2 id=\"Undefined\"><a href=\"#Undefined\" class=\"headerlink\" title=\"Undefined\"></a>Undefined</h2><p>Undefined类型只有一个undefined值。</p>\n<p>用var声明但未赋值的变量，其值为undefined。</p>\n<pre><code>var a;\nalert(a); //undefined\n</code></pre><p>使用一个未经声明的变量，typeof检测为undefined，但使用时会报错。</p>\n<pre><code>alert(a); //Error\n</code></pre><p>访问一个对象中不存在的属性时，其值为undefined，不会报错。</p>\n<pre><code>var o = {a:1};\nalert(o.b); //undefined\n</code></pre><p>故undefined不能与typeof结合使用来判断一个变量是否被声明。</p>\n<pre><code>var a;\nalert(typeof a); //undefined\nalert(typeof b); //undefined ，变量b并没有被声明\n</code></pre><h2 id=\"Null\"><a href=\"#Null\" class=\"headerlink\" title=\"Null\"></a>Null</h2><p>Null表示一个空对象指针，typeof null会返回object。</p>\n<pre><code>var o = null;\nalert(typeof o); //object\n</code></pre><p>null可以作为空对象的占位符，故如果定义的变量将来用于存放对象，那么最好将该变量初始化为null，这样通过typeof可以判断相应的变量是否保存了一个对象的引用。</p>\n<pre><code>var o = null;\n//...\nif(o == null){\n    //do something\n}\n</code></pre><p>undefined是派生自null的，故下面相等性测试返回的是true</p>\n<pre><code>alert(undefined == null); //true\n</code></pre><p>注意：undefined与null很大的一个区别在于，无论什么情况下，undefined一般都不会被用作显式地初始化变量，而null则推荐用来作为空对象指针。</p>\n<h2 id=\"Boolean\"><a href=\"#Boolean\" class=\"headerlink\" title=\"Boolean\"></a>Boolean</h2><p>ECMAScript中，所有类型的值都有与Boolean类型对应的值，我们可以通过转型函数Boolean()来进行转换。</p>\n<ul>\n<li>String类型，非空字符串均返回true，空字符串返回false</li>\n<li>Number类型，非零数字值均返回true，0和NaN返回false</li>\n<li>Object类型，任何非空对象均返回true，null返回false</li>\n<li>Undefined类型，恒为false</li>\n</ul>\n<p>这个转换在流控制语句中如if语句中，会将if()中的变量自动转换成对应的Boolean值，以下代码是相等的：</p>\n<pre><code>var foo = &quot;bar&quot;;\n\nif(foo){\n    //do something\n}\n\n//上下两段代码是相同的\n\nif(Boolean(foo)){\n    //do something\n}\n</code></pre><h2 id=\"Number\"><a href=\"#Number\" class=\"headerlink\" title=\"Number\"></a>Number</h2><p>Number类型使用IEEE754格式来表示整数和浮点数，浮点数值的最高精度是17位小数，故在计算时会产生舍入误差的问题。所以永远不要测试某个特定的浮点数值。</p>\n<pre><code>var a = 0.1;\nvar b = 0.2;\nalert(a+b == 0.3) //false，0.1+0.2会变成0.30000000000000004\n</code></pre><h3 id=\"数值范围\"><a href=\"#数值范围\" class=\"headerlink\" title=\"数值范围\"></a>数值范围</h3><ul>\n<li>正无穷：+Infinity</li>\n<li>能够表示的最大正数：Number.MAX_VALUE</li>\n<li>能够表示的最小正数：Number.MIN_VALUE</li>\n<li>0</li>\n<li>能够表示的最大负数：-Number.MIN_VALUE</li>\n<li>能够表示的最小负数：-Number.MAX_VALUE</li>\n<li>负无穷：-Infinity</li>\n</ul>\n<h3 id=\"NaN\"><a href=\"#NaN\" class=\"headerlink\" title=\"NaN\"></a>NaN</h3><p>NaN，Not a Number，用于表示一个本来要返回数值的操作数未返回数值的情况，此时不抛出错误，也不会影响其他代码的执行。</p>\n<p>除了类型转换时会出现NaN之外，0/0也会返回NaN。</p>\n<p>特点：</p>\n<ul>\n<li>NaN与任何数值操作均为NaN</li>\n<li>NaN与任何值都不相等，包括NaN自身</li>\n</ul>\n<p>可以用isNaN()函数来判断一个值是否“不是数值”，isNaN()在接收到一个参数后，会尝试将这个值转换为数值。</p>\n<pre><code>isNaN(NaN); //true\nisNaN(10); //false\nisNaN(&quot;10&quot;); //false，字符串&quot;10&quot;可以转换成数字10\nisNaN(&quot;blue&quot;); //true，字符串&quot;blue&quot;不能被转换成数字\nisNaN(true); //false，布尔值true可以被转换成数字1\nisNaN(false); //false，布尔值false可以被转换成数字0\n</code></pre><h3 id=\"数值转换\"><a href=\"#数值转换\" class=\"headerlink\" title=\"数值转换\"></a>数值转换</h3><ul>\n<li>Number()，转型函数</li>\n<li>parseInt()，全局函数</li>\n<li>parseFloat()，全局函数</li>\n</ul>\n<h4 id=\"Number-1\"><a href=\"#Number-1\" class=\"headerlink\" title=\"Number()\"></a>Number()</h4><ul>\n<li>Boolean，true 1，false 0</li>\n<li>Null，null 0</li>\n<li>Undefined，undefined NaN</li>\n<li>String，字符串只包含数字时（包括+/-，整数/浮点数） 对应数字，空字符串”” 0</li>\n<li>Object，先valueOf()若NaN则toString()，转换规则跟上述一致</li>\n</ul>\n<h4 id=\"parseInt\"><a href=\"#parseInt\" class=\"headerlink\" title=\"parseInt()\"></a>parseInt()</h4><p>parseInt接收两个参数，第一个是待转换的值，第二个是基数（二进制、八进制、十进制、十六进制），其他进制不常用，以下仅讨论十进制。</p>\n<p>与Number()的几个区别是，</p>\n<ol>\n<li>Number()接收任意类型的参数，而parseInt()只接收String，非String一律为NaN。</li>\n<li>parseInt()会对传入的字符串从左到右进行遍历，从第一个数字或正负号开始，到第一个非数字结束，字符串中不存在数字就一定会是NaN，忽略其他非数字的字符；Number()中如果字符串存在非数字字符就会是NaN。</li>\n<li>空字符串Number()转换成0，parseInt()转换成NaN。</li>\n<li>parseInt()只会转换成整数</li>\n</ol>\n<p>示例：</p>\n<pre><code>var n0 = true;\nalert(Number(n0)); //1\nalert(parseInt(n0,10)); //NaN\n\nvar n1 = &quot;1234blue&quot;;\nalert(Number(n1)); //NaN\nalert(parseInt(n1,10)); //1234\n\nvar n2 = &quot;&quot;;\nalert(Number(n2)); //0\nalert(parseInt(n2,10)); //NaN\n\nvar n3 = &quot;22.5&quot;;\nalert(Number(n3)); //22.5\nalert(parseInt(n3,10)); //22\n</code></pre><h4 id=\"parseFloat\"><a href=\"#parseFloat\" class=\"headerlink\" title=\"parseFloat()\"></a>parseFloat()</h4><p>parseFloat()与parseInt()的解析机制基本相同，以下为两个比较主要的区别：</p>\n<ol>\n<li>parseFloat()没有第二个参数，只解析十进制</li>\n<li>parseFloat()识别小数点，遇到第二个小数点停止解析</li>\n</ol>\n<h2 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h2><p>String类型用于表示由零或多个16位Unicode字符组成的字符序列，即字符串。</p>\n<p>用双引号表示的字符串与用单引号表示的字符串完全相同。</p>\n<h3 id=\"字符字面量\"><a href=\"#字符字面量\" class=\"headerlink\" title=\"字符字面量\"></a>字符字面量</h3><p>即转义序列，用于表示非打印字符或其他用途的字符。常见的有：</p>\n<ul>\n<li>\\n 换行</li>\n<li>\\t 制表</li>\n<li>\\r 回车</li>\n<li>\\b 退格</li>\n<li>\\xnn 以十六进制代码nn表示一个字符（n为0~F）</li>\n<li>\\unnnn 以十六进制代码nnnn表示的一个Unicode字符（其中n为0~f)</li>\n</ul>\n<p>注意：\\unnnn类型的字符虽然在代码中占6个字符，但是在length属性中只占1个字符。</p>\n<p>但是如果字符串中包含双字节字符，那么length属性可能不会精确地返回字符串中的字符数目。</p>\n<h3 id=\"字符串的特点\"><a href=\"#字符串的特点\" class=\"headerlink\" title=\"字符串的特点\"></a>字符串的特点</h3><p>字符串是不可变的，一旦创建，它们的值就不能改变。要改变的话，则会先销毁原来的字符串，再用一个包含新值的字符串填充该变量。</p>\n<pre><code>var lang = &quot;Java&quot;;\nlang = lang + &quot;Script&quot;;\n</code></pre><ol>\n<li>首先创建一个10字符的新字符串</li>\n<li>接着填充”Java”和”Script”</li>\n<li>将新字符串赋值给lang</li>\n<li>删除”Java”和”Script”</li>\n</ol>\n<h3 id=\"转换为字符串\"><a href=\"#转换为字符串\" class=\"headerlink\" title=\"转换为字符串\"></a>转换为字符串</h3><p>转换为字符串有两种方法，分别是toString()和String()。</p>\n<p>还有一种是用加号操作符，这里先不作讨论。</p>\n<h4 id=\"toString-NaN\"><a href=\"#toString-NaN\" class=\"headerlink\" title=\"toString()\"></a>toString()</h4><p>几乎每个值都有toString()方法，返回响应值的字符串表现。</p>\n<ul>\n<li>Number，即数字本身，还可以传递一个参数以指定基数</li>\n<li>Boolean，即”true”或”false”</li>\n<li>String，即字符串本身</li>\n</ul>\n<p>示例：</p>\n<pre><code>var num = 10;\nalert(num.toString()); //10，默认十进制\nalert(num.toString(2)); //1010，二进制\nalert(num.toString(16)); //a,十六进制\n</code></pre><p>Null和Undefined没有toString方法。</p>\n<h4 id=\"String-1\"><a href=\"#String-1\" class=\"headerlink\" title=\"String()\"></a>String()</h4><p>就像Number()和parseInt()的关系一样，String()转型函数能够接收任意类型的值作为参数，但是区别在于Number()和parseInt()之间相对平等，而String()更像是toString()的超集。</p>\n<ul>\n<li>如果传入的值有toString()方法，则调用该方法</li>\n<li>Null类型，返回”null”</li>\n<li>Undefined类型，返回”undefined”</li>\n</ul>\n<p>不过String()在转换数值时就不能指定基数了。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>JavaScript基本数据类型有5种，分别是Null，Undefined，Boolean，Number和String。其中，Undefined派生自Null，故null==undefined返回true。</p>\n<p>Boolean只有true和false两个值，注意Boolean()转型函数的转换规则，以及与if()等流程控制语句的关系。</p>\n<p>Number类型不区分整数和浮点数，要注意其数值范围以及精度的问题，要当心0.1+0.2不等于0.3的判断问题。还有对NaN的理解，注意NaN与任何值都不相等的特性。此外，Number()转型函数，parseInt()和parseFloat()各有机制上的共通点和不同处，要做好区别。</p>\n<p>String类型，包含字符字面量，转义字符，字符串的特点以及字符串的转换，重点理解如何使用toString()和String()来进行字符串转换。</p>\n"},{"layout":"post","title":"HTTP基础（2）：常见的状态码","date":"2017-04-12T05:00:00.000Z","_content":"HTTP状态码用于描述客户端向服务器端发送请求后的请求结果。通过状态码，客户端可以知道发出的HTTP是是否被正确处理。\n\n状态码由**三位数字**和**原因短语**组成，第一位指定了**响应类别**。\n\n状态码的类别：\n\n- 1XX：Informational 信息性状态码，表示服务器接收的请求正在被处理\n- 2XX：Success 成功状态码，表示请求被正常处理完毕\n- 3XX：Redirection 重定向状态码，表示客户端需要进行附加操作以完成请求\n- 4XX：Client Error 客户端错误状态码，表示因某种原因服务器无法处理请求\n- 5XX：Server Error 服务器错误状态码，表示服务器处理请求时出错\n\n## 2XX 成功\n\n### 200 OK\n\n表示客户端的请求被服务器端正常处理了。\n\n在这个状态码下，服务器的响应内容则依据请求方法决定。如果请求方法为GET，那么，对应请求资源的实体会一并返回；如果请求方法是HEAD，那么仅返回首部，而对应资源的实体不会被返回。\n\n### 204 No Content\n\n表示客户端的请求被服务器端正常处理，但是响应报文中不含有实体的主体部分。实际上204状态码下也不允许响应报文中有实体的主体部分。\n\n该响应码一般用于客户端向服务器端发送信息，而服务器端不必返回新信息的情况下使用。\n\n### 206 Parical Content\n\n该状态码表示客户端进行了范围请求（请求资源的一部分内容），而服务器成功执行了这部分的GET请求。响应报文中包含由Content-Range指定的实体内容。\n\n## 3XX 重定向\n\n### 301 Moved Permanently\n\n永久性重定向。该状态码表示请求的资源已经分配了新的URI，新的URI在Location首部字段中。\n\n### 302 Found\n\n临时性重定向。该状态码表示请求的资源已经分配了新的URI，希望客户端此次能以新的URI进行访问。\n\n注意302是临时性的重定向，请求的资源在将来还有可能换成别的URI。所以与永久性重定向的区别是，301是让客户端之后都用新的URI访问（相当于搬家，其住址URI不会轻易变更），而302时客户端之后仍然应该访问返回302的页面，以获得请求的资源最新的URI（相当于租房，其住址URI随时会变）。\n\n### 303 See Other\n\n该状态码表示由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源。\n\n303与302基本相似，唯一不同处是明确规定需要用GET方法去访问新的URI。例如当使用POST方法访问CGI（公共网关接口，Common Gateway Interface）程序，随后服务器端希望客户端以GET方法重定向到另一个URI上去时，返回303状态码。\n\n### 304 Not Modified\n\n该状态表示客户端发送附带条件的请求时（在请求头部中包含If-Match、If-Modified-Since、If-None-Match、If-Range、If-Unmodified-Since），服务器端允许请求访问资源，但因发生请求未满足条件，直接返回304。\n\n即表示服务器端的资源没有发生改变，客户端可以继续使用未过期的缓存资源。\n\n注意：304虽然在3XX 重定向类别中，但跟重定向实际上没有太大的关系。\n\n### 307 TEmporary Redirect\n\n临时重定向。该状态码与302基本相同，不同的是307会遵照浏览器标准，不会从POST变成GET。\n\n而301、302响应状态码返回时，浏览器一般都会把POST改成GET（尽管301和302标准是禁止这样做的）并删除请求报文的主体，再发起请求。\n\n## 4XX 客户端错误\n\n### 400 Bad Request\n\n该状态码表示请求报文中存在语法错误，需要客户端修改请求内容后再次发送请求。\n\n注意：浏览器会像对待200 OK 一样对待该状态码（即不会像3XX那样子有别的行为）\n\n### 401 Unauthorized\n\n该状态码表示发送的请求需要有通过HTTP认证的认证信息。\n\n第一次返回401时，浏览器会弹出认证用的对话框。\n\n第二次返回401时，即表示用户认证失败。\n\n### 403 Forbidden\n\n该状态码表示对该资源的请求被服务器拒绝了。服务器没有义务给出拒绝的详细理由，但如果想作说明的话可以在实体的主体部分对原因进行描述。\n\n### 404 Not Found\n\n该状态码表示服务器无法找到请求的资源，是最常见的状态码。\n\n## 5XX 服务器端错误\n\n### 500 Internal Server Error\n\n该状态码表示服务器端在处理请求时发生了错误，例如无法连接数据库，或者服务端语言中有语法错误等等。\n\n### 503 Service Unavailable\n\n该状态码表示服务器端暂时处理超负载或正在进行停机维护，现在无法处理请求。\n\n如果事先知道服务器将在何时恢复，则最好写入Retry-After首部字段再返回给客户端。\n\n\n## 小结\n\n### 注意：\n\n状态码只在服务器端正确按照规范处理请求的前提下才有意义，不少服务器端会出现状态码与状态不一致的问题，需要在实际开发中注意。\n\n### 本文提及的常见的状态码\n\n- 200 OK\n- 202 No Content\n- 204 Partical Content\n- 301 Permanently Redirect\n- 302 Found\n- 303 See Other\n- 304 Not Modified\n- 307 Temporary Redirect\n- 400 Bad Request\n- 401 Unauthorized\n- 403 Forbbiden\n- 404 Not Found\n- 500 Interval Server Error\n- 503 Service Unavailable\n\n### 总结：\n\n本文整理了14种常见的状态码，其中包含4个状态类别，2XX，3XX，4XX，5XX，分别代表了成功，重定向，客户端错误和服务器端错误。\n\n2XX中，要注意202与200的区别，前者不含资源实体的主体。\n\n3XX中，要注意304与重定向无关，301和302一个是永久重定向，一个是临时重定向，且在标准中是不能把POST请求改成GET请求的（但是实际浏览器都会这么做）。303是302的相反版本，303要求POST改成GET请求。307是302的严格版，不允许把POST改成GET请求。\n\n4XX中，400和401都是与浏览器有关的，前者是请求有错误后者是没有HTTP认证信息；403和404与服务器端有关，403禁止浏览器访问特定资源，404则是服务器上没有特定的资源。\n\n5XX中，500是服务器端处理请求时出错，一般是数据库连接、代码有语法问题等等。503则是服务器负载过大或在维护，暂时无法提供服务。\n\n","source":"_posts/2017-04-12-HTTP：常见的状态码.markdown","raw":"---\nlayout: post\ntitle:  \"HTTP基础（2）：常见的状态码\"\ndate:   2017-04-12 13:00:00 +0800\ncategories: HTTP\n---\nHTTP状态码用于描述客户端向服务器端发送请求后的请求结果。通过状态码，客户端可以知道发出的HTTP是是否被正确处理。\n\n状态码由**三位数字**和**原因短语**组成，第一位指定了**响应类别**。\n\n状态码的类别：\n\n- 1XX：Informational 信息性状态码，表示服务器接收的请求正在被处理\n- 2XX：Success 成功状态码，表示请求被正常处理完毕\n- 3XX：Redirection 重定向状态码，表示客户端需要进行附加操作以完成请求\n- 4XX：Client Error 客户端错误状态码，表示因某种原因服务器无法处理请求\n- 5XX：Server Error 服务器错误状态码，表示服务器处理请求时出错\n\n## 2XX 成功\n\n### 200 OK\n\n表示客户端的请求被服务器端正常处理了。\n\n在这个状态码下，服务器的响应内容则依据请求方法决定。如果请求方法为GET，那么，对应请求资源的实体会一并返回；如果请求方法是HEAD，那么仅返回首部，而对应资源的实体不会被返回。\n\n### 204 No Content\n\n表示客户端的请求被服务器端正常处理，但是响应报文中不含有实体的主体部分。实际上204状态码下也不允许响应报文中有实体的主体部分。\n\n该响应码一般用于客户端向服务器端发送信息，而服务器端不必返回新信息的情况下使用。\n\n### 206 Parical Content\n\n该状态码表示客户端进行了范围请求（请求资源的一部分内容），而服务器成功执行了这部分的GET请求。响应报文中包含由Content-Range指定的实体内容。\n\n## 3XX 重定向\n\n### 301 Moved Permanently\n\n永久性重定向。该状态码表示请求的资源已经分配了新的URI，新的URI在Location首部字段中。\n\n### 302 Found\n\n临时性重定向。该状态码表示请求的资源已经分配了新的URI，希望客户端此次能以新的URI进行访问。\n\n注意302是临时性的重定向，请求的资源在将来还有可能换成别的URI。所以与永久性重定向的区别是，301是让客户端之后都用新的URI访问（相当于搬家，其住址URI不会轻易变更），而302时客户端之后仍然应该访问返回302的页面，以获得请求的资源最新的URI（相当于租房，其住址URI随时会变）。\n\n### 303 See Other\n\n该状态码表示由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源。\n\n303与302基本相似，唯一不同处是明确规定需要用GET方法去访问新的URI。例如当使用POST方法访问CGI（公共网关接口，Common Gateway Interface）程序，随后服务器端希望客户端以GET方法重定向到另一个URI上去时，返回303状态码。\n\n### 304 Not Modified\n\n该状态表示客户端发送附带条件的请求时（在请求头部中包含If-Match、If-Modified-Since、If-None-Match、If-Range、If-Unmodified-Since），服务器端允许请求访问资源，但因发生请求未满足条件，直接返回304。\n\n即表示服务器端的资源没有发生改变，客户端可以继续使用未过期的缓存资源。\n\n注意：304虽然在3XX 重定向类别中，但跟重定向实际上没有太大的关系。\n\n### 307 TEmporary Redirect\n\n临时重定向。该状态码与302基本相同，不同的是307会遵照浏览器标准，不会从POST变成GET。\n\n而301、302响应状态码返回时，浏览器一般都会把POST改成GET（尽管301和302标准是禁止这样做的）并删除请求报文的主体，再发起请求。\n\n## 4XX 客户端错误\n\n### 400 Bad Request\n\n该状态码表示请求报文中存在语法错误，需要客户端修改请求内容后再次发送请求。\n\n注意：浏览器会像对待200 OK 一样对待该状态码（即不会像3XX那样子有别的行为）\n\n### 401 Unauthorized\n\n该状态码表示发送的请求需要有通过HTTP认证的认证信息。\n\n第一次返回401时，浏览器会弹出认证用的对话框。\n\n第二次返回401时，即表示用户认证失败。\n\n### 403 Forbidden\n\n该状态码表示对该资源的请求被服务器拒绝了。服务器没有义务给出拒绝的详细理由，但如果想作说明的话可以在实体的主体部分对原因进行描述。\n\n### 404 Not Found\n\n该状态码表示服务器无法找到请求的资源，是最常见的状态码。\n\n## 5XX 服务器端错误\n\n### 500 Internal Server Error\n\n该状态码表示服务器端在处理请求时发生了错误，例如无法连接数据库，或者服务端语言中有语法错误等等。\n\n### 503 Service Unavailable\n\n该状态码表示服务器端暂时处理超负载或正在进行停机维护，现在无法处理请求。\n\n如果事先知道服务器将在何时恢复，则最好写入Retry-After首部字段再返回给客户端。\n\n\n## 小结\n\n### 注意：\n\n状态码只在服务器端正确按照规范处理请求的前提下才有意义，不少服务器端会出现状态码与状态不一致的问题，需要在实际开发中注意。\n\n### 本文提及的常见的状态码\n\n- 200 OK\n- 202 No Content\n- 204 Partical Content\n- 301 Permanently Redirect\n- 302 Found\n- 303 See Other\n- 304 Not Modified\n- 307 Temporary Redirect\n- 400 Bad Request\n- 401 Unauthorized\n- 403 Forbbiden\n- 404 Not Found\n- 500 Interval Server Error\n- 503 Service Unavailable\n\n### 总结：\n\n本文整理了14种常见的状态码，其中包含4个状态类别，2XX，3XX，4XX，5XX，分别代表了成功，重定向，客户端错误和服务器端错误。\n\n2XX中，要注意202与200的区别，前者不含资源实体的主体。\n\n3XX中，要注意304与重定向无关，301和302一个是永久重定向，一个是临时重定向，且在标准中是不能把POST请求改成GET请求的（但是实际浏览器都会这么做）。303是302的相反版本，303要求POST改成GET请求。307是302的严格版，不允许把POST改成GET请求。\n\n4XX中，400和401都是与浏览器有关的，前者是请求有错误后者是没有HTTP认证信息；403和404与服务器端有关，403禁止浏览器访问特定资源，404则是服务器上没有特定的资源。\n\n5XX中，500是服务器端处理请求时出错，一般是数据库连接、代码有语法问题等等。503则是服务器负载过大或在维护，暂时无法提供服务。\n\n","slug":"2017-04-12-HTTP：常见的状态码","published":1,"updated":"2017-07-30T15:35:31.000Z","comments":1,"photos":[],"link":"","_id":"cj5qx2mln000db4orbpia9npv","content":"<p>HTTP状态码用于描述客户端向服务器端发送请求后的请求结果。通过状态码，客户端可以知道发出的HTTP是是否被正确处理。</p>\n<p>状态码由<strong>三位数字</strong>和<strong>原因短语</strong>组成，第一位指定了<strong>响应类别</strong>。</p>\n<p>状态码的类别：</p>\n<ul>\n<li>1XX：Informational 信息性状态码，表示服务器接收的请求正在被处理</li>\n<li>2XX：Success 成功状态码，表示请求被正常处理完毕</li>\n<li>3XX：Redirection 重定向状态码，表示客户端需要进行附加操作以完成请求</li>\n<li>4XX：Client Error 客户端错误状态码，表示因某种原因服务器无法处理请求</li>\n<li>5XX：Server Error 服务器错误状态码，表示服务器处理请求时出错</li>\n</ul>\n<h2 id=\"2XX-成功\"><a href=\"#2XX-成功\" class=\"headerlink\" title=\"2XX 成功\"></a>2XX 成功</h2><h3 id=\"200-OK\"><a href=\"#200-OK\" class=\"headerlink\" title=\"200 OK\"></a>200 OK</h3><p>表示客户端的请求被服务器端正常处理了。</p>\n<p>在这个状态码下，服务器的响应内容则依据请求方法决定。如果请求方法为GET，那么，对应请求资源的实体会一并返回；如果请求方法是HEAD，那么仅返回首部，而对应资源的实体不会被返回。</p>\n<h3 id=\"204-No-Content\"><a href=\"#204-No-Content\" class=\"headerlink\" title=\"204 No Content\"></a>204 No Content</h3><p>表示客户端的请求被服务器端正常处理，但是响应报文中不含有实体的主体部分。实际上204状态码下也不允许响应报文中有实体的主体部分。</p>\n<p>该响应码一般用于客户端向服务器端发送信息，而服务器端不必返回新信息的情况下使用。</p>\n<h3 id=\"206-Parical-Content\"><a href=\"#206-Parical-Content\" class=\"headerlink\" title=\"206 Parical Content\"></a>206 Parical Content</h3><p>该状态码表示客户端进行了范围请求（请求资源的一部分内容），而服务器成功执行了这部分的GET请求。响应报文中包含由Content-Range指定的实体内容。</p>\n<h2 id=\"3XX-重定向\"><a href=\"#3XX-重定向\" class=\"headerlink\" title=\"3XX 重定向\"></a>3XX 重定向</h2><h3 id=\"301-Moved-Permanently\"><a href=\"#301-Moved-Permanently\" class=\"headerlink\" title=\"301 Moved Permanently\"></a>301 Moved Permanently</h3><p>永久性重定向。该状态码表示请求的资源已经分配了新的URI，新的URI在Location首部字段中。</p>\n<h3 id=\"302-Found\"><a href=\"#302-Found\" class=\"headerlink\" title=\"302 Found\"></a>302 Found</h3><p>临时性重定向。该状态码表示请求的资源已经分配了新的URI，希望客户端此次能以新的URI进行访问。</p>\n<p>注意302是临时性的重定向，请求的资源在将来还有可能换成别的URI。所以与永久性重定向的区别是，301是让客户端之后都用新的URI访问（相当于搬家，其住址URI不会轻易变更），而302时客户端之后仍然应该访问返回302的页面，以获得请求的资源最新的URI（相当于租房，其住址URI随时会变）。</p>\n<h3 id=\"303-See-Other\"><a href=\"#303-See-Other\" class=\"headerlink\" title=\"303 See Other\"></a>303 See Other</h3><p>该状态码表示由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源。</p>\n<p>303与302基本相似，唯一不同处是明确规定需要用GET方法去访问新的URI。例如当使用POST方法访问CGI（公共网关接口，Common Gateway Interface）程序，随后服务器端希望客户端以GET方法重定向到另一个URI上去时，返回303状态码。</p>\n<h3 id=\"304-Not-Modified\"><a href=\"#304-Not-Modified\" class=\"headerlink\" title=\"304 Not Modified\"></a>304 Not Modified</h3><p>该状态表示客户端发送附带条件的请求时（在请求头部中包含If-Match、If-Modified-Since、If-None-Match、If-Range、If-Unmodified-Since），服务器端允许请求访问资源，但因发生请求未满足条件，直接返回304。</p>\n<p>即表示服务器端的资源没有发生改变，客户端可以继续使用未过期的缓存资源。</p>\n<p>注意：304虽然在3XX 重定向类别中，但跟重定向实际上没有太大的关系。</p>\n<h3 id=\"307-TEmporary-Redirect\"><a href=\"#307-TEmporary-Redirect\" class=\"headerlink\" title=\"307 TEmporary Redirect\"></a>307 TEmporary Redirect</h3><p>临时重定向。该状态码与302基本相同，不同的是307会遵照浏览器标准，不会从POST变成GET。</p>\n<p>而301、302响应状态码返回时，浏览器一般都会把POST改成GET（尽管301和302标准是禁止这样做的）并删除请求报文的主体，再发起请求。</p>\n<h2 id=\"4XX-客户端错误\"><a href=\"#4XX-客户端错误\" class=\"headerlink\" title=\"4XX 客户端错误\"></a>4XX 客户端错误</h2><h3 id=\"400-Bad-Request\"><a href=\"#400-Bad-Request\" class=\"headerlink\" title=\"400 Bad Request\"></a>400 Bad Request</h3><p>该状态码表示请求报文中存在语法错误，需要客户端修改请求内容后再次发送请求。</p>\n<p>注意：浏览器会像对待200 OK 一样对待该状态码（即不会像3XX那样子有别的行为）</p>\n<h3 id=\"401-Unauthorized\"><a href=\"#401-Unauthorized\" class=\"headerlink\" title=\"401 Unauthorized\"></a>401 Unauthorized</h3><p>该状态码表示发送的请求需要有通过HTTP认证的认证信息。</p>\n<p>第一次返回401时，浏览器会弹出认证用的对话框。</p>\n<p>第二次返回401时，即表示用户认证失败。</p>\n<h3 id=\"403-Forbidden\"><a href=\"#403-Forbidden\" class=\"headerlink\" title=\"403 Forbidden\"></a>403 Forbidden</h3><p>该状态码表示对该资源的请求被服务器拒绝了。服务器没有义务给出拒绝的详细理由，但如果想作说明的话可以在实体的主体部分对原因进行描述。</p>\n<h3 id=\"404-Not-Found\"><a href=\"#404-Not-Found\" class=\"headerlink\" title=\"404 Not Found\"></a>404 Not Found</h3><p>该状态码表示服务器无法找到请求的资源，是最常见的状态码。</p>\n<h2 id=\"5XX-服务器端错误\"><a href=\"#5XX-服务器端错误\" class=\"headerlink\" title=\"5XX 服务器端错误\"></a>5XX 服务器端错误</h2><h3 id=\"500-Internal-Server-Error\"><a href=\"#500-Internal-Server-Error\" class=\"headerlink\" title=\"500 Internal Server Error\"></a>500 Internal Server Error</h3><p>该状态码表示服务器端在处理请求时发生了错误，例如无法连接数据库，或者服务端语言中有语法错误等等。</p>\n<h3 id=\"503-Service-Unavailable\"><a href=\"#503-Service-Unavailable\" class=\"headerlink\" title=\"503 Service Unavailable\"></a>503 Service Unavailable</h3><p>该状态码表示服务器端暂时处理超负载或正在进行停机维护，现在无法处理请求。</p>\n<p>如果事先知道服务器将在何时恢复，则最好写入Retry-After首部字段再返回给客户端。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><h3 id=\"注意：\"><a href=\"#注意：\" class=\"headerlink\" title=\"注意：\"></a>注意：</h3><p>状态码只在服务器端正确按照规范处理请求的前提下才有意义，不少服务器端会出现状态码与状态不一致的问题，需要在实际开发中注意。</p>\n<h3 id=\"本文提及的常见的状态码\"><a href=\"#本文提及的常见的状态码\" class=\"headerlink\" title=\"本文提及的常见的状态码\"></a>本文提及的常见的状态码</h3><ul>\n<li>200 OK</li>\n<li>202 No Content</li>\n<li>204 Partical Content</li>\n<li>301 Permanently Redirect</li>\n<li>302 Found</li>\n<li>303 See Other</li>\n<li>304 Not Modified</li>\n<li>307 Temporary Redirect</li>\n<li>400 Bad Request</li>\n<li>401 Unauthorized</li>\n<li>403 Forbbiden</li>\n<li>404 Not Found</li>\n<li>500 Interval Server Error</li>\n<li>503 Service Unavailable</li>\n</ul>\n<h3 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h3><p>本文整理了14种常见的状态码，其中包含4个状态类别，2XX，3XX，4XX，5XX，分别代表了成功，重定向，客户端错误和服务器端错误。</p>\n<p>2XX中，要注意202与200的区别，前者不含资源实体的主体。</p>\n<p>3XX中，要注意304与重定向无关，301和302一个是永久重定向，一个是临时重定向，且在标准中是不能把POST请求改成GET请求的（但是实际浏览器都会这么做）。303是302的相反版本，303要求POST改成GET请求。307是302的严格版，不允许把POST改成GET请求。</p>\n<p>4XX中，400和401都是与浏览器有关的，前者是请求有错误后者是没有HTTP认证信息；403和404与服务器端有关，403禁止浏览器访问特定资源，404则是服务器上没有特定的资源。</p>\n<p>5XX中，500是服务器端处理请求时出错，一般是数据库连接、代码有语法问题等等。503则是服务器负载过大或在维护，暂时无法提供服务。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>HTTP状态码用于描述客户端向服务器端发送请求后的请求结果。通过状态码，客户端可以知道发出的HTTP是是否被正确处理。</p>\n<p>状态码由<strong>三位数字</strong>和<strong>原因短语</strong>组成，第一位指定了<strong>响应类别</strong>。</p>\n<p>状态码的类别：</p>\n<ul>\n<li>1XX：Informational 信息性状态码，表示服务器接收的请求正在被处理</li>\n<li>2XX：Success 成功状态码，表示请求被正常处理完毕</li>\n<li>3XX：Redirection 重定向状态码，表示客户端需要进行附加操作以完成请求</li>\n<li>4XX：Client Error 客户端错误状态码，表示因某种原因服务器无法处理请求</li>\n<li>5XX：Server Error 服务器错误状态码，表示服务器处理请求时出错</li>\n</ul>\n<h2 id=\"2XX-成功\"><a href=\"#2XX-成功\" class=\"headerlink\" title=\"2XX 成功\"></a>2XX 成功</h2><h3 id=\"200-OK\"><a href=\"#200-OK\" class=\"headerlink\" title=\"200 OK\"></a>200 OK</h3><p>表示客户端的请求被服务器端正常处理了。</p>\n<p>在这个状态码下，服务器的响应内容则依据请求方法决定。如果请求方法为GET，那么，对应请求资源的实体会一并返回；如果请求方法是HEAD，那么仅返回首部，而对应资源的实体不会被返回。</p>\n<h3 id=\"204-No-Content\"><a href=\"#204-No-Content\" class=\"headerlink\" title=\"204 No Content\"></a>204 No Content</h3><p>表示客户端的请求被服务器端正常处理，但是响应报文中不含有实体的主体部分。实际上204状态码下也不允许响应报文中有实体的主体部分。</p>\n<p>该响应码一般用于客户端向服务器端发送信息，而服务器端不必返回新信息的情况下使用。</p>\n<h3 id=\"206-Parical-Content\"><a href=\"#206-Parical-Content\" class=\"headerlink\" title=\"206 Parical Content\"></a>206 Parical Content</h3><p>该状态码表示客户端进行了范围请求（请求资源的一部分内容），而服务器成功执行了这部分的GET请求。响应报文中包含由Content-Range指定的实体内容。</p>\n<h2 id=\"3XX-重定向\"><a href=\"#3XX-重定向\" class=\"headerlink\" title=\"3XX 重定向\"></a>3XX 重定向</h2><h3 id=\"301-Moved-Permanently\"><a href=\"#301-Moved-Permanently\" class=\"headerlink\" title=\"301 Moved Permanently\"></a>301 Moved Permanently</h3><p>永久性重定向。该状态码表示请求的资源已经分配了新的URI，新的URI在Location首部字段中。</p>\n<h3 id=\"302-Found\"><a href=\"#302-Found\" class=\"headerlink\" title=\"302 Found\"></a>302 Found</h3><p>临时性重定向。该状态码表示请求的资源已经分配了新的URI，希望客户端此次能以新的URI进行访问。</p>\n<p>注意302是临时性的重定向，请求的资源在将来还有可能换成别的URI。所以与永久性重定向的区别是，301是让客户端之后都用新的URI访问（相当于搬家，其住址URI不会轻易变更），而302时客户端之后仍然应该访问返回302的页面，以获得请求的资源最新的URI（相当于租房，其住址URI随时会变）。</p>\n<h3 id=\"303-See-Other\"><a href=\"#303-See-Other\" class=\"headerlink\" title=\"303 See Other\"></a>303 See Other</h3><p>该状态码表示由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源。</p>\n<p>303与302基本相似，唯一不同处是明确规定需要用GET方法去访问新的URI。例如当使用POST方法访问CGI（公共网关接口，Common Gateway Interface）程序，随后服务器端希望客户端以GET方法重定向到另一个URI上去时，返回303状态码。</p>\n<h3 id=\"304-Not-Modified\"><a href=\"#304-Not-Modified\" class=\"headerlink\" title=\"304 Not Modified\"></a>304 Not Modified</h3><p>该状态表示客户端发送附带条件的请求时（在请求头部中包含If-Match、If-Modified-Since、If-None-Match、If-Range、If-Unmodified-Since），服务器端允许请求访问资源，但因发生请求未满足条件，直接返回304。</p>\n<p>即表示服务器端的资源没有发生改变，客户端可以继续使用未过期的缓存资源。</p>\n<p>注意：304虽然在3XX 重定向类别中，但跟重定向实际上没有太大的关系。</p>\n<h3 id=\"307-TEmporary-Redirect\"><a href=\"#307-TEmporary-Redirect\" class=\"headerlink\" title=\"307 TEmporary Redirect\"></a>307 TEmporary Redirect</h3><p>临时重定向。该状态码与302基本相同，不同的是307会遵照浏览器标准，不会从POST变成GET。</p>\n<p>而301、302响应状态码返回时，浏览器一般都会把POST改成GET（尽管301和302标准是禁止这样做的）并删除请求报文的主体，再发起请求。</p>\n<h2 id=\"4XX-客户端错误\"><a href=\"#4XX-客户端错误\" class=\"headerlink\" title=\"4XX 客户端错误\"></a>4XX 客户端错误</h2><h3 id=\"400-Bad-Request\"><a href=\"#400-Bad-Request\" class=\"headerlink\" title=\"400 Bad Request\"></a>400 Bad Request</h3><p>该状态码表示请求报文中存在语法错误，需要客户端修改请求内容后再次发送请求。</p>\n<p>注意：浏览器会像对待200 OK 一样对待该状态码（即不会像3XX那样子有别的行为）</p>\n<h3 id=\"401-Unauthorized\"><a href=\"#401-Unauthorized\" class=\"headerlink\" title=\"401 Unauthorized\"></a>401 Unauthorized</h3><p>该状态码表示发送的请求需要有通过HTTP认证的认证信息。</p>\n<p>第一次返回401时，浏览器会弹出认证用的对话框。</p>\n<p>第二次返回401时，即表示用户认证失败。</p>\n<h3 id=\"403-Forbidden\"><a href=\"#403-Forbidden\" class=\"headerlink\" title=\"403 Forbidden\"></a>403 Forbidden</h3><p>该状态码表示对该资源的请求被服务器拒绝了。服务器没有义务给出拒绝的详细理由，但如果想作说明的话可以在实体的主体部分对原因进行描述。</p>\n<h3 id=\"404-Not-Found\"><a href=\"#404-Not-Found\" class=\"headerlink\" title=\"404 Not Found\"></a>404 Not Found</h3><p>该状态码表示服务器无法找到请求的资源，是最常见的状态码。</p>\n<h2 id=\"5XX-服务器端错误\"><a href=\"#5XX-服务器端错误\" class=\"headerlink\" title=\"5XX 服务器端错误\"></a>5XX 服务器端错误</h2><h3 id=\"500-Internal-Server-Error\"><a href=\"#500-Internal-Server-Error\" class=\"headerlink\" title=\"500 Internal Server Error\"></a>500 Internal Server Error</h3><p>该状态码表示服务器端在处理请求时发生了错误，例如无法连接数据库，或者服务端语言中有语法错误等等。</p>\n<h3 id=\"503-Service-Unavailable\"><a href=\"#503-Service-Unavailable\" class=\"headerlink\" title=\"503 Service Unavailable\"></a>503 Service Unavailable</h3><p>该状态码表示服务器端暂时处理超负载或正在进行停机维护，现在无法处理请求。</p>\n<p>如果事先知道服务器将在何时恢复，则最好写入Retry-After首部字段再返回给客户端。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><h3 id=\"注意：\"><a href=\"#注意：\" class=\"headerlink\" title=\"注意：\"></a>注意：</h3><p>状态码只在服务器端正确按照规范处理请求的前提下才有意义，不少服务器端会出现状态码与状态不一致的问题，需要在实际开发中注意。</p>\n<h3 id=\"本文提及的常见的状态码\"><a href=\"#本文提及的常见的状态码\" class=\"headerlink\" title=\"本文提及的常见的状态码\"></a>本文提及的常见的状态码</h3><ul>\n<li>200 OK</li>\n<li>202 No Content</li>\n<li>204 Partical Content</li>\n<li>301 Permanently Redirect</li>\n<li>302 Found</li>\n<li>303 See Other</li>\n<li>304 Not Modified</li>\n<li>307 Temporary Redirect</li>\n<li>400 Bad Request</li>\n<li>401 Unauthorized</li>\n<li>403 Forbbiden</li>\n<li>404 Not Found</li>\n<li>500 Interval Server Error</li>\n<li>503 Service Unavailable</li>\n</ul>\n<h3 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h3><p>本文整理了14种常见的状态码，其中包含4个状态类别，2XX，3XX，4XX，5XX，分别代表了成功，重定向，客户端错误和服务器端错误。</p>\n<p>2XX中，要注意202与200的区别，前者不含资源实体的主体。</p>\n<p>3XX中，要注意304与重定向无关，301和302一个是永久重定向，一个是临时重定向，且在标准中是不能把POST请求改成GET请求的（但是实际浏览器都会这么做）。303是302的相反版本，303要求POST改成GET请求。307是302的严格版，不允许把POST改成GET请求。</p>\n<p>4XX中，400和401都是与浏览器有关的，前者是请求有错误后者是没有HTTP认证信息；403和404与服务器端有关，403禁止浏览器访问特定资源，404则是服务器上没有特定的资源。</p>\n<p>5XX中，500是服务器端处理请求时出错，一般是数据库连接、代码有语法问题等等。503则是服务器负载过大或在维护，暂时无法提供服务。</p>\n"},{"layout":"post","title":"React：基本环境搭建简明步骤","date":"2017-04-14T14:34:00.000Z","_content":"超简的步骤整理。待完善。\n\n- Babel\n- ESLint\n- webpack\n\n## Babel\n\n`babel`是一个多用途的JavaScript编译器，用它的目的有二：一是支持ES6语法，二是支持`React`的一些特性（JSX）语法等。\n\n### 安装\n\n在这里我们是跟`webpack`一起用的，所以需要的是`babel-core`核心模块和`babel-lodaer`，如果需要单独使用`babel`则安装`babel-cli`。\n\n    $ npm i babel-core babel-loader --save-dev\n\n接下来安装babel presets\n\n    $ npm i babel-preset-es2015 babel-preset-react --save-dev\n    \n### 配置\n\n在根目录下新建一个`.babelrc`文件，并加入以下配置\n\n    {\n        \"presets\": [\"es2015\", \"react\"]\n    }\n\n## ESLint\n\nESLint是一个代码检查工具，用于检查和统一代码规范。\n\n### 安装\n\n    $ npm i eslint eslint-loader --save-dev\n\n### 配置\n\n    $ eslint --init\n\n接下来根据你的需求进行选择即可，非常方便。最终可选择生成一个`.eslint.json`文件。我的配置如下：\n\n    {\n        \"env\": {\n            \"browser\": true,\n            \"commonjs\": true,\n            \"es6\": true,\n            \"node\": true\n        },\n        \"extends\": \"eslint:recommended\",\n        \"parserOptions\": {\n            \"ecmaFeatures\": {\n                \"experimentalObjectRestSpread\": true,\n                \"jsx\": true\n            },\n            \"sourceType\": \"module\"\n        },\n        \"plugins\": [\n            \"react\"\n        ],\n        \"rules\": {\n            \"linebreak-style\": [\n                \"error\",\n                \"unix\"\n            ],\n            \"quotes\": [\n                \"error\",\n                \"single\"\n            ],\n            \"semi\": [\n                \"error\",\n                \"always\"\n            ]\n        }\n    }\n\n更多的配置可参照[ESLint](http://eslint.org)\n\n## webpack\n\n`webpack`是当前非常流行的模块打包工具，上述的`Babel`和`ESLint`都可以作为`loader`在`webpack`中被使用。\n\n注意：本文使用的是`webpack 2`，`webpack 1`和`webpack 2`在配置上有诸多不同之处，请务必留心。\n\n[链接：webpack 1和2的区别](https://webpack.js.org/guides/migrating/)\n\n### 安装\n\n    $ npm i webpack webpack-dev-server --save-dev\n    \n### 插件\n\n用于自动生成HTML页面，并引入正确的JavaScript文件依赖。\n\n    $ npm i html-webpack-plugin --save-dev\n\n### loader\n\n处理CSS文件需要用到的两个loader。\n\n    $ npm i css-loader style-loader\n\n### 配置\n\n在根目录下新建一个`app`目录，同时再创建一个`webpack.config.js`文件。\n\n    var path = require('path');\n    var HtmlWebpackPlugin = require('html-webpack-plugin');\n    \n    var ROOT_PATH = path.resolve(__dirname);\n    var APP_PATH = path.resolve(ROOT_PATH, 'app');\n    var BUILD_PATH = path.resolve(ROOT_PATH, 'build');\n    \n    module.exports = {\n        entry: {\n            app: path.resolve(APP_PATH, 'app.jsx')\n        },\n        output: {\n            path: BUILD_PATH,\n            filename: 'bundle.js'\n        },\n        devtool: 'eval-source-map',\n        devServer: {\n            historyApiFallback: true,\n            hot: true,\n            inline: true,\n        },\n        module: {\n            rules: [{\n                test: /\\.jsx?$/,\n                enforce: 'pre',\n                loaders: ['eslint-loader'],\n                include: APP_PATH\n            }, {\n                test: /\\.css$/,\n                loaders: ['style-loader', 'css-loader']\n            }, {\n                test: /\\.jsx?$/,\n                loader: ['babel-loader'],\n                include: APP_PATH\n            }],\n        },\n        plugins: [\n            new HtmlWebpackPlugin({\n                title: 'react-dev'\n            })\n        ],\n        resolve: {\n            extensions: ['.js', '.jsx']\n        }\n    };\n\n## 最后\n\n添加两条命令到`package.json`里。\n\n    \"scripts\": {\n        \"build\":\"webpack\",\n        \"dev\":\"webpack-dev-server --hot\"\n    }\n\n通过在Terminal中输入 `npm run build` 或 `npm run dev` 执行。","source":"_posts/2017-04-14-React：基本环境搭建简明步骤.markdown","raw":"---\nlayout: post\ntitle:  \"React：基本环境搭建简明步骤\"\ndate:   2017-04-14 22:34:00 +0800\ncategories: React\n---\n超简的步骤整理。待完善。\n\n- Babel\n- ESLint\n- webpack\n\n## Babel\n\n`babel`是一个多用途的JavaScript编译器，用它的目的有二：一是支持ES6语法，二是支持`React`的一些特性（JSX）语法等。\n\n### 安装\n\n在这里我们是跟`webpack`一起用的，所以需要的是`babel-core`核心模块和`babel-lodaer`，如果需要单独使用`babel`则安装`babel-cli`。\n\n    $ npm i babel-core babel-loader --save-dev\n\n接下来安装babel presets\n\n    $ npm i babel-preset-es2015 babel-preset-react --save-dev\n    \n### 配置\n\n在根目录下新建一个`.babelrc`文件，并加入以下配置\n\n    {\n        \"presets\": [\"es2015\", \"react\"]\n    }\n\n## ESLint\n\nESLint是一个代码检查工具，用于检查和统一代码规范。\n\n### 安装\n\n    $ npm i eslint eslint-loader --save-dev\n\n### 配置\n\n    $ eslint --init\n\n接下来根据你的需求进行选择即可，非常方便。最终可选择生成一个`.eslint.json`文件。我的配置如下：\n\n    {\n        \"env\": {\n            \"browser\": true,\n            \"commonjs\": true,\n            \"es6\": true,\n            \"node\": true\n        },\n        \"extends\": \"eslint:recommended\",\n        \"parserOptions\": {\n            \"ecmaFeatures\": {\n                \"experimentalObjectRestSpread\": true,\n                \"jsx\": true\n            },\n            \"sourceType\": \"module\"\n        },\n        \"plugins\": [\n            \"react\"\n        ],\n        \"rules\": {\n            \"linebreak-style\": [\n                \"error\",\n                \"unix\"\n            ],\n            \"quotes\": [\n                \"error\",\n                \"single\"\n            ],\n            \"semi\": [\n                \"error\",\n                \"always\"\n            ]\n        }\n    }\n\n更多的配置可参照[ESLint](http://eslint.org)\n\n## webpack\n\n`webpack`是当前非常流行的模块打包工具，上述的`Babel`和`ESLint`都可以作为`loader`在`webpack`中被使用。\n\n注意：本文使用的是`webpack 2`，`webpack 1`和`webpack 2`在配置上有诸多不同之处，请务必留心。\n\n[链接：webpack 1和2的区别](https://webpack.js.org/guides/migrating/)\n\n### 安装\n\n    $ npm i webpack webpack-dev-server --save-dev\n    \n### 插件\n\n用于自动生成HTML页面，并引入正确的JavaScript文件依赖。\n\n    $ npm i html-webpack-plugin --save-dev\n\n### loader\n\n处理CSS文件需要用到的两个loader。\n\n    $ npm i css-loader style-loader\n\n### 配置\n\n在根目录下新建一个`app`目录，同时再创建一个`webpack.config.js`文件。\n\n    var path = require('path');\n    var HtmlWebpackPlugin = require('html-webpack-plugin');\n    \n    var ROOT_PATH = path.resolve(__dirname);\n    var APP_PATH = path.resolve(ROOT_PATH, 'app');\n    var BUILD_PATH = path.resolve(ROOT_PATH, 'build');\n    \n    module.exports = {\n        entry: {\n            app: path.resolve(APP_PATH, 'app.jsx')\n        },\n        output: {\n            path: BUILD_PATH,\n            filename: 'bundle.js'\n        },\n        devtool: 'eval-source-map',\n        devServer: {\n            historyApiFallback: true,\n            hot: true,\n            inline: true,\n        },\n        module: {\n            rules: [{\n                test: /\\.jsx?$/,\n                enforce: 'pre',\n                loaders: ['eslint-loader'],\n                include: APP_PATH\n            }, {\n                test: /\\.css$/,\n                loaders: ['style-loader', 'css-loader']\n            }, {\n                test: /\\.jsx?$/,\n                loader: ['babel-loader'],\n                include: APP_PATH\n            }],\n        },\n        plugins: [\n            new HtmlWebpackPlugin({\n                title: 'react-dev'\n            })\n        ],\n        resolve: {\n            extensions: ['.js', '.jsx']\n        }\n    };\n\n## 最后\n\n添加两条命令到`package.json`里。\n\n    \"scripts\": {\n        \"build\":\"webpack\",\n        \"dev\":\"webpack-dev-server --hot\"\n    }\n\n通过在Terminal中输入 `npm run build` 或 `npm run dev` 执行。","slug":"2017-04-14-React：基本环境搭建简明步骤","published":1,"updated":"2017-07-30T15:22:10.000Z","comments":1,"photos":[],"link":"","_id":"cj5qx2mlp000fb4ordkl1aotm","content":"<p>超简的步骤整理。待完善。</p>\n<ul>\n<li>Babel</li>\n<li>ESLint</li>\n<li>webpack</li>\n</ul>\n<h2 id=\"Babel\"><a href=\"#Babel\" class=\"headerlink\" title=\"Babel\"></a>Babel</h2><p><code>babel</code>是一个多用途的JavaScript编译器，用它的目的有二：一是支持ES6语法，二是支持<code>React</code>的一些特性（JSX）语法等。</p>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>在这里我们是跟<code>webpack</code>一起用的，所以需要的是<code>babel-core</code>核心模块和<code>babel-lodaer</code>，如果需要单独使用<code>babel</code>则安装<code>babel-cli</code>。</p>\n<pre><code>$ npm i babel-core babel-loader --save-dev\n</code></pre><p>接下来安装babel presets</p>\n<pre><code>$ npm i babel-preset-es2015 babel-preset-react --save-dev\n</code></pre><h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><p>在根目录下新建一个<code>.babelrc</code>文件，并加入以下配置</p>\n<pre><code>{\n    &quot;presets&quot;: [&quot;es2015&quot;, &quot;react&quot;]\n}\n</code></pre><h2 id=\"ESLint\"><a href=\"#ESLint\" class=\"headerlink\" title=\"ESLint\"></a>ESLint</h2><p>ESLint是一个代码检查工具，用于检查和统一代码规范。</p>\n<h3 id=\"安装-1\"><a href=\"#安装-1\" class=\"headerlink\" title=\"安装\"></a>安装</h3><pre><code>$ npm i eslint eslint-loader --save-dev\n</code></pre><h3 id=\"配置-1\"><a href=\"#配置-1\" class=\"headerlink\" title=\"配置\"></a>配置</h3><pre><code>$ eslint --init\n</code></pre><p>接下来根据你的需求进行选择即可，非常方便。最终可选择生成一个<code>.eslint.json</code>文件。我的配置如下：</p>\n<pre><code>{\n    &quot;env&quot;: {\n        &quot;browser&quot;: true,\n        &quot;commonjs&quot;: true,\n        &quot;es6&quot;: true,\n        &quot;node&quot;: true\n    },\n    &quot;extends&quot;: &quot;eslint:recommended&quot;,\n    &quot;parserOptions&quot;: {\n        &quot;ecmaFeatures&quot;: {\n            &quot;experimentalObjectRestSpread&quot;: true,\n            &quot;jsx&quot;: true\n        },\n        &quot;sourceType&quot;: &quot;module&quot;\n    },\n    &quot;plugins&quot;: [\n        &quot;react&quot;\n    ],\n    &quot;rules&quot;: {\n        &quot;linebreak-style&quot;: [\n            &quot;error&quot;,\n            &quot;unix&quot;\n        ],\n        &quot;quotes&quot;: [\n            &quot;error&quot;,\n            &quot;single&quot;\n        ],\n        &quot;semi&quot;: [\n            &quot;error&quot;,\n            &quot;always&quot;\n        ]\n    }\n}\n</code></pre><p>更多的配置可参照<a href=\"http://eslint.org\" target=\"_blank\" rel=\"external\">ESLint</a></p>\n<h2 id=\"webpack\"><a href=\"#webpack\" class=\"headerlink\" title=\"webpack\"></a>webpack</h2><p><code>webpack</code>是当前非常流行的模块打包工具，上述的<code>Babel</code>和<code>ESLint</code>都可以作为<code>loader</code>在<code>webpack</code>中被使用。</p>\n<p>注意：本文使用的是<code>webpack 2</code>，<code>webpack 1</code>和<code>webpack 2</code>在配置上有诸多不同之处，请务必留心。</p>\n<p><a href=\"https://webpack.js.org/guides/migrating/\" target=\"_blank\" rel=\"external\">链接：webpack 1和2的区别</a></p>\n<h3 id=\"安装-2\"><a href=\"#安装-2\" class=\"headerlink\" title=\"安装\"></a>安装</h3><pre><code>$ npm i webpack webpack-dev-server --save-dev\n</code></pre><h3 id=\"插件\"><a href=\"#插件\" class=\"headerlink\" title=\"插件\"></a>插件</h3><p>用于自动生成HTML页面，并引入正确的JavaScript文件依赖。</p>\n<pre><code>$ npm i html-webpack-plugin --save-dev\n</code></pre><h3 id=\"loader\"><a href=\"#loader\" class=\"headerlink\" title=\"loader\"></a>loader</h3><p>处理CSS文件需要用到的两个loader。</p>\n<pre><code>$ npm i css-loader style-loader\n</code></pre><h3 id=\"配置-2\"><a href=\"#配置-2\" class=\"headerlink\" title=\"配置\"></a>配置</h3><p>在根目录下新建一个<code>app</code>目录，同时再创建一个<code>webpack.config.js</code>文件。</p>\n<pre><code>var path = require(&apos;path&apos;);\nvar HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);\n\nvar ROOT_PATH = path.resolve(__dirname);\nvar APP_PATH = path.resolve(ROOT_PATH, &apos;app&apos;);\nvar BUILD_PATH = path.resolve(ROOT_PATH, &apos;build&apos;);\n\nmodule.exports = {\n    entry: {\n        app: path.resolve(APP_PATH, &apos;app.jsx&apos;)\n    },\n    output: {\n        path: BUILD_PATH,\n        filename: &apos;bundle.js&apos;\n    },\n    devtool: &apos;eval-source-map&apos;,\n    devServer: {\n        historyApiFallback: true,\n        hot: true,\n        inline: true,\n    },\n    module: {\n        rules: [{\n            test: /\\.jsx?$/,\n            enforce: &apos;pre&apos;,\n            loaders: [&apos;eslint-loader&apos;],\n            include: APP_PATH\n        }, {\n            test: /\\.css$/,\n            loaders: [&apos;style-loader&apos;, &apos;css-loader&apos;]\n        }, {\n            test: /\\.jsx?$/,\n            loader: [&apos;babel-loader&apos;],\n            include: APP_PATH\n        }],\n    },\n    plugins: [\n        new HtmlWebpackPlugin({\n            title: &apos;react-dev&apos;\n        })\n    ],\n    resolve: {\n        extensions: [&apos;.js&apos;, &apos;.jsx&apos;]\n    }\n};\n</code></pre><h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>添加两条命令到<code>package.json</code>里。</p>\n<pre><code>&quot;scripts&quot;: {\n    &quot;build&quot;:&quot;webpack&quot;,\n    &quot;dev&quot;:&quot;webpack-dev-server --hot&quot;\n}\n</code></pre><p>通过在Terminal中输入 <code>npm run build</code> 或 <code>npm run dev</code> 执行。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>超简的步骤整理。待完善。</p>\n<ul>\n<li>Babel</li>\n<li>ESLint</li>\n<li>webpack</li>\n</ul>\n<h2 id=\"Babel\"><a href=\"#Babel\" class=\"headerlink\" title=\"Babel\"></a>Babel</h2><p><code>babel</code>是一个多用途的JavaScript编译器，用它的目的有二：一是支持ES6语法，二是支持<code>React</code>的一些特性（JSX）语法等。</p>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>在这里我们是跟<code>webpack</code>一起用的，所以需要的是<code>babel-core</code>核心模块和<code>babel-lodaer</code>，如果需要单独使用<code>babel</code>则安装<code>babel-cli</code>。</p>\n<pre><code>$ npm i babel-core babel-loader --save-dev\n</code></pre><p>接下来安装babel presets</p>\n<pre><code>$ npm i babel-preset-es2015 babel-preset-react --save-dev\n</code></pre><h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><p>在根目录下新建一个<code>.babelrc</code>文件，并加入以下配置</p>\n<pre><code>{\n    &quot;presets&quot;: [&quot;es2015&quot;, &quot;react&quot;]\n}\n</code></pre><h2 id=\"ESLint\"><a href=\"#ESLint\" class=\"headerlink\" title=\"ESLint\"></a>ESLint</h2><p>ESLint是一个代码检查工具，用于检查和统一代码规范。</p>\n<h3 id=\"安装-1\"><a href=\"#安装-1\" class=\"headerlink\" title=\"安装\"></a>安装</h3><pre><code>$ npm i eslint eslint-loader --save-dev\n</code></pre><h3 id=\"配置-1\"><a href=\"#配置-1\" class=\"headerlink\" title=\"配置\"></a>配置</h3><pre><code>$ eslint --init\n</code></pre><p>接下来根据你的需求进行选择即可，非常方便。最终可选择生成一个<code>.eslint.json</code>文件。我的配置如下：</p>\n<pre><code>{\n    &quot;env&quot;: {\n        &quot;browser&quot;: true,\n        &quot;commonjs&quot;: true,\n        &quot;es6&quot;: true,\n        &quot;node&quot;: true\n    },\n    &quot;extends&quot;: &quot;eslint:recommended&quot;,\n    &quot;parserOptions&quot;: {\n        &quot;ecmaFeatures&quot;: {\n            &quot;experimentalObjectRestSpread&quot;: true,\n            &quot;jsx&quot;: true\n        },\n        &quot;sourceType&quot;: &quot;module&quot;\n    },\n    &quot;plugins&quot;: [\n        &quot;react&quot;\n    ],\n    &quot;rules&quot;: {\n        &quot;linebreak-style&quot;: [\n            &quot;error&quot;,\n            &quot;unix&quot;\n        ],\n        &quot;quotes&quot;: [\n            &quot;error&quot;,\n            &quot;single&quot;\n        ],\n        &quot;semi&quot;: [\n            &quot;error&quot;,\n            &quot;always&quot;\n        ]\n    }\n}\n</code></pre><p>更多的配置可参照<a href=\"http://eslint.org\" target=\"_blank\" rel=\"external\">ESLint</a></p>\n<h2 id=\"webpack\"><a href=\"#webpack\" class=\"headerlink\" title=\"webpack\"></a>webpack</h2><p><code>webpack</code>是当前非常流行的模块打包工具，上述的<code>Babel</code>和<code>ESLint</code>都可以作为<code>loader</code>在<code>webpack</code>中被使用。</p>\n<p>注意：本文使用的是<code>webpack 2</code>，<code>webpack 1</code>和<code>webpack 2</code>在配置上有诸多不同之处，请务必留心。</p>\n<p><a href=\"https://webpack.js.org/guides/migrating/\" target=\"_blank\" rel=\"external\">链接：webpack 1和2的区别</a></p>\n<h3 id=\"安装-2\"><a href=\"#安装-2\" class=\"headerlink\" title=\"安装\"></a>安装</h3><pre><code>$ npm i webpack webpack-dev-server --save-dev\n</code></pre><h3 id=\"插件\"><a href=\"#插件\" class=\"headerlink\" title=\"插件\"></a>插件</h3><p>用于自动生成HTML页面，并引入正确的JavaScript文件依赖。</p>\n<pre><code>$ npm i html-webpack-plugin --save-dev\n</code></pre><h3 id=\"loader\"><a href=\"#loader\" class=\"headerlink\" title=\"loader\"></a>loader</h3><p>处理CSS文件需要用到的两个loader。</p>\n<pre><code>$ npm i css-loader style-loader\n</code></pre><h3 id=\"配置-2\"><a href=\"#配置-2\" class=\"headerlink\" title=\"配置\"></a>配置</h3><p>在根目录下新建一个<code>app</code>目录，同时再创建一个<code>webpack.config.js</code>文件。</p>\n<pre><code>var path = require(&apos;path&apos;);\nvar HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);\n\nvar ROOT_PATH = path.resolve(__dirname);\nvar APP_PATH = path.resolve(ROOT_PATH, &apos;app&apos;);\nvar BUILD_PATH = path.resolve(ROOT_PATH, &apos;build&apos;);\n\nmodule.exports = {\n    entry: {\n        app: path.resolve(APP_PATH, &apos;app.jsx&apos;)\n    },\n    output: {\n        path: BUILD_PATH,\n        filename: &apos;bundle.js&apos;\n    },\n    devtool: &apos;eval-source-map&apos;,\n    devServer: {\n        historyApiFallback: true,\n        hot: true,\n        inline: true,\n    },\n    module: {\n        rules: [{\n            test: /\\.jsx?$/,\n            enforce: &apos;pre&apos;,\n            loaders: [&apos;eslint-loader&apos;],\n            include: APP_PATH\n        }, {\n            test: /\\.css$/,\n            loaders: [&apos;style-loader&apos;, &apos;css-loader&apos;]\n        }, {\n            test: /\\.jsx?$/,\n            loader: [&apos;babel-loader&apos;],\n            include: APP_PATH\n        }],\n    },\n    plugins: [\n        new HtmlWebpackPlugin({\n            title: &apos;react-dev&apos;\n        })\n    ],\n    resolve: {\n        extensions: [&apos;.js&apos;, &apos;.jsx&apos;]\n    }\n};\n</code></pre><h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>添加两条命令到<code>package.json</code>里。</p>\n<pre><code>&quot;scripts&quot;: {\n    &quot;build&quot;:&quot;webpack&quot;,\n    &quot;dev&quot;:&quot;webpack-dev-server --hot&quot;\n}\n</code></pre><p>通过在Terminal中输入 <code>npm run build</code> 或 <code>npm run dev</code> 执行。</p>\n"},{"layout":"post","title":"什么是Hybrid App","date":"2017-05-23T07:30:00.000Z","_content":"## 什么是Hybrid\n\n### Hybrid 出现的历史原因\n\n* 2013年起移动互联网的兴起导致App开发的需求日益高涨。\n* 2014年 H5 的发布，使得 Web 能够实现更多功能。\n* 在产品需要快速迭代、抢占市场的大背景下，开发 iOS 和 Android 原生应用的时间成本和劳动成本都非常高。\n* 随着 iOS 和 Android 两大阵营对 H5 的支持日益完善，H5 足以实现大多数的需求。\n* 为了利用 Web 应用低成本、高效率、跨成本等诸多优点，出现了使用 Web 和 Native 混合进行开发的模式。\n\n### Hybrid 的分类\n\nApp 应用从实现机制上来区分，主要分为三类：\n\n1. Native 应用：使用原生语言的应用，能够调用所有底层接口，交互体验最好。\n2. Web App 应用：使用纯 Web 开发的应用，通过浏览器访问，交互体验最差。\n3. Hybrid 应用：\n   1. 以 WebView 作为用户界面层，以 JavaScript 为基本逻辑通过与中间件通讯、访问底层 API ，进行应用开发。\n   2. 使用非官方语言的工具，打包成原生应用的方式开发。\n   3. 基于原生应用的架构，在部分功能中嵌入 WebView 。WebView 负责对界面的渲染，同时也可以访问底层的 API 以实现特定的功能。\n   4. 通过 JavaScript 引擎管理和渲染 native 视图，将 JavaScript 代码渲染成原生组件，调用原生 API 与用户进行交互。（ReactNative、Weex）\n\n### Hybrid 的优势\n\n* 开发效率高\n* 开发成本低\n* 跨平台\n* 快速迭代，无需发布版本即可修复Bug\n\n总结来说，Hybrid 是既保持了对原生API的完整掌控，同时可以在特定功能下节省跨平台开发成本、提升效率。\n\n### Hybrid 的劣势\n\n* 容易造成性能问题，不适用于依赖原生 API 、动画较多和游戏开发的需求。\n* 永远保持最新（直接访问线上，而不是使用 App 本地的静态资源）带来的低版本机型的适配问题，包括调用底层 API 和对 H5 的支持方面。（即不太好做版本控制）\n* 需要实现 Native 与 H5 之间的通信机制\n* 交互体验不如原生页面，需要尽可能仿制原生应用的体验\n\n总结来说，Web 只能替代、辅助一部分功能，无法取代原生开发的主导地位。\n\n## Hybrid 实现\n\n### Native 与前端之间的关系\n\nHybrid App 底层依赖于 Native 提供的容器，上层使用 H5 做业务开发，底层透明化、上层多样化，适合前端介入进行快速迭代开发。\n\nNative 提供的实际上是类似于浏览器的宿主环境，H5 页面可以利用宿主环境提供的“能力”来进行开发。正如一般浏览器为 JavaScript 提供了 window 对象以控制浏览器一样，Native 也可以为 H5 页面提供特定的接口以调用底层的 API。\n\n### Hybrid 交互设计\n\nNative 可以调用前端页面的 JavaScript 方法对视图进行操作，前端页面也可以通过 JavaScript 方法调用 Native 提供的接口实现系统层面的功能。两者沟通的桥梁则是 WebView。\n\n### ![](/images/FE-Hybrid-interaction.png)Schema\n\nApp 自身可以自定义 URL Schema，并且把自定义的 URL 注册在调度中心。App 安装后会在手机上注册一个 Schema，例如淘宝是 taobao:// ，Native 会有一个进程监控 WebView 发出的所有 schema:// 请求，从而打开 Native 应用并传入参数执行特定的行为。\n\n通过 Schema ，H5 可以通过发起 schema 请求，来实现 H5 与 Native 页面之间的跳转。\n\n### 常用交互 API\n\n* 跳转\n  * 页面内部跳转\n  * H5 跳转 Native 界面，Native 通过截获 URL 参数跳转到响应页面。\n  * H5 新打开一个 WebView。\n* Header 组件\n  * 避免白屏陷入假死状态\n  * Header 左侧和右侧按钮可配置，中间 title 部分可配置\n* 请求类\n  * 通过 Native 代理发起 AJAX 请求，解决跨域问题\n* Native UI 组件\n  * Loading 组件\n  * Toast 组件\n\n## 参考\n\n[http://www.cnblogs.com/yexiaochai/p/4921635.html](http://www.cnblogs.com/yexiaochai/p/4921635.html)\n\n[http://ued.ctrip.com/blog/translation-hybrid-mobile-application-provide-native-web-technology-experience.html](http://ued.ctrip.com/blog/translation-hybrid-mobile-application-provide-native-web-technology-experience.html)\n\n[https://dailc.github.io/2016/10/04/hybridBase01HybridInfo.html](https://dailc.github.io/2016/10/04/hybridBase01HybridInfo.html)\n\n[https://dailc.github.io/2016/10/04/hybridBase02HybridCompareOthers.html](https://dailc.github.io/2016/10/04/hybridBase02HybridCompareOthers.html)\n\n[https://weex.apache.org/cn/](https://weex.apache.org/cn/)\n\n[http://www.infoq.com/cn/articles/hybrid-app-development-combat\\#note-bottom-anchor](http://www.infoq.com/cn/articles/hybrid-app-development-combat#note-bottom-anchor)\n\n[http://www.jianshu.com/p/e83aa2d1ade3](http://www.jianshu.com/p/e83aa2d1ade3)\n\n","source":"_posts/2017-05-23-什么是Hybrid App.markdown","raw":"---\nlayout: post\ntitle:  \"什么是Hybrid App\"\ndate:   2017-05-23 15:30:00 +0800\ncategories: FE\n---\n## 什么是Hybrid\n\n### Hybrid 出现的历史原因\n\n* 2013年起移动互联网的兴起导致App开发的需求日益高涨。\n* 2014年 H5 的发布，使得 Web 能够实现更多功能。\n* 在产品需要快速迭代、抢占市场的大背景下，开发 iOS 和 Android 原生应用的时间成本和劳动成本都非常高。\n* 随着 iOS 和 Android 两大阵营对 H5 的支持日益完善，H5 足以实现大多数的需求。\n* 为了利用 Web 应用低成本、高效率、跨成本等诸多优点，出现了使用 Web 和 Native 混合进行开发的模式。\n\n### Hybrid 的分类\n\nApp 应用从实现机制上来区分，主要分为三类：\n\n1. Native 应用：使用原生语言的应用，能够调用所有底层接口，交互体验最好。\n2. Web App 应用：使用纯 Web 开发的应用，通过浏览器访问，交互体验最差。\n3. Hybrid 应用：\n   1. 以 WebView 作为用户界面层，以 JavaScript 为基本逻辑通过与中间件通讯、访问底层 API ，进行应用开发。\n   2. 使用非官方语言的工具，打包成原生应用的方式开发。\n   3. 基于原生应用的架构，在部分功能中嵌入 WebView 。WebView 负责对界面的渲染，同时也可以访问底层的 API 以实现特定的功能。\n   4. 通过 JavaScript 引擎管理和渲染 native 视图，将 JavaScript 代码渲染成原生组件，调用原生 API 与用户进行交互。（ReactNative、Weex）\n\n### Hybrid 的优势\n\n* 开发效率高\n* 开发成本低\n* 跨平台\n* 快速迭代，无需发布版本即可修复Bug\n\n总结来说，Hybrid 是既保持了对原生API的完整掌控，同时可以在特定功能下节省跨平台开发成本、提升效率。\n\n### Hybrid 的劣势\n\n* 容易造成性能问题，不适用于依赖原生 API 、动画较多和游戏开发的需求。\n* 永远保持最新（直接访问线上，而不是使用 App 本地的静态资源）带来的低版本机型的适配问题，包括调用底层 API 和对 H5 的支持方面。（即不太好做版本控制）\n* 需要实现 Native 与 H5 之间的通信机制\n* 交互体验不如原生页面，需要尽可能仿制原生应用的体验\n\n总结来说，Web 只能替代、辅助一部分功能，无法取代原生开发的主导地位。\n\n## Hybrid 实现\n\n### Native 与前端之间的关系\n\nHybrid App 底层依赖于 Native 提供的容器，上层使用 H5 做业务开发，底层透明化、上层多样化，适合前端介入进行快速迭代开发。\n\nNative 提供的实际上是类似于浏览器的宿主环境，H5 页面可以利用宿主环境提供的“能力”来进行开发。正如一般浏览器为 JavaScript 提供了 window 对象以控制浏览器一样，Native 也可以为 H5 页面提供特定的接口以调用底层的 API。\n\n### Hybrid 交互设计\n\nNative 可以调用前端页面的 JavaScript 方法对视图进行操作，前端页面也可以通过 JavaScript 方法调用 Native 提供的接口实现系统层面的功能。两者沟通的桥梁则是 WebView。\n\n### ![](/images/FE-Hybrid-interaction.png)Schema\n\nApp 自身可以自定义 URL Schema，并且把自定义的 URL 注册在调度中心。App 安装后会在手机上注册一个 Schema，例如淘宝是 taobao:// ，Native 会有一个进程监控 WebView 发出的所有 schema:// 请求，从而打开 Native 应用并传入参数执行特定的行为。\n\n通过 Schema ，H5 可以通过发起 schema 请求，来实现 H5 与 Native 页面之间的跳转。\n\n### 常用交互 API\n\n* 跳转\n  * 页面内部跳转\n  * H5 跳转 Native 界面，Native 通过截获 URL 参数跳转到响应页面。\n  * H5 新打开一个 WebView。\n* Header 组件\n  * 避免白屏陷入假死状态\n  * Header 左侧和右侧按钮可配置，中间 title 部分可配置\n* 请求类\n  * 通过 Native 代理发起 AJAX 请求，解决跨域问题\n* Native UI 组件\n  * Loading 组件\n  * Toast 组件\n\n## 参考\n\n[http://www.cnblogs.com/yexiaochai/p/4921635.html](http://www.cnblogs.com/yexiaochai/p/4921635.html)\n\n[http://ued.ctrip.com/blog/translation-hybrid-mobile-application-provide-native-web-technology-experience.html](http://ued.ctrip.com/blog/translation-hybrid-mobile-application-provide-native-web-technology-experience.html)\n\n[https://dailc.github.io/2016/10/04/hybridBase01HybridInfo.html](https://dailc.github.io/2016/10/04/hybridBase01HybridInfo.html)\n\n[https://dailc.github.io/2016/10/04/hybridBase02HybridCompareOthers.html](https://dailc.github.io/2016/10/04/hybridBase02HybridCompareOthers.html)\n\n[https://weex.apache.org/cn/](https://weex.apache.org/cn/)\n\n[http://www.infoq.com/cn/articles/hybrid-app-development-combat\\#note-bottom-anchor](http://www.infoq.com/cn/articles/hybrid-app-development-combat#note-bottom-anchor)\n\n[http://www.jianshu.com/p/e83aa2d1ade3](http://www.jianshu.com/p/e83aa2d1ade3)\n\n","slug":"2017-05-23-什么是Hybrid App","published":1,"updated":"2017-07-30T15:38:51.000Z","comments":1,"photos":[],"link":"","_id":"cj5qx2mlq000gb4orm3r9e70b","content":"<h2 id=\"什么是Hybrid\"><a href=\"#什么是Hybrid\" class=\"headerlink\" title=\"什么是Hybrid\"></a>什么是Hybrid</h2><h3 id=\"Hybrid-出现的历史原因\"><a href=\"#Hybrid-出现的历史原因\" class=\"headerlink\" title=\"Hybrid 出现的历史原因\"></a>Hybrid 出现的历史原因</h3><ul>\n<li>2013年起移动互联网的兴起导致App开发的需求日益高涨。</li>\n<li>2014年 H5 的发布，使得 Web 能够实现更多功能。</li>\n<li>在产品需要快速迭代、抢占市场的大背景下，开发 iOS 和 Android 原生应用的时间成本和劳动成本都非常高。</li>\n<li>随着 iOS 和 Android 两大阵营对 H5 的支持日益完善，H5 足以实现大多数的需求。</li>\n<li>为了利用 Web 应用低成本、高效率、跨成本等诸多优点，出现了使用 Web 和 Native 混合进行开发的模式。</li>\n</ul>\n<h3 id=\"Hybrid-的分类\"><a href=\"#Hybrid-的分类\" class=\"headerlink\" title=\"Hybrid 的分类\"></a>Hybrid 的分类</h3><p>App 应用从实现机制上来区分，主要分为三类：</p>\n<ol>\n<li>Native 应用：使用原生语言的应用，能够调用所有底层接口，交互体验最好。</li>\n<li>Web App 应用：使用纯 Web 开发的应用，通过浏览器访问，交互体验最差。</li>\n<li>Hybrid 应用：<ol>\n<li>以 WebView 作为用户界面层，以 JavaScript 为基本逻辑通过与中间件通讯、访问底层 API ，进行应用开发。</li>\n<li>使用非官方语言的工具，打包成原生应用的方式开发。</li>\n<li>基于原生应用的架构，在部分功能中嵌入 WebView 。WebView 负责对界面的渲染，同时也可以访问底层的 API 以实现特定的功能。</li>\n<li>通过 JavaScript 引擎管理和渲染 native 视图，将 JavaScript 代码渲染成原生组件，调用原生 API 与用户进行交互。（ReactNative、Weex）</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"Hybrid-的优势\"><a href=\"#Hybrid-的优势\" class=\"headerlink\" title=\"Hybrid 的优势\"></a>Hybrid 的优势</h3><ul>\n<li>开发效率高</li>\n<li>开发成本低</li>\n<li>跨平台</li>\n<li>快速迭代，无需发布版本即可修复Bug</li>\n</ul>\n<p>总结来说，Hybrid 是既保持了对原生API的完整掌控，同时可以在特定功能下节省跨平台开发成本、提升效率。</p>\n<h3 id=\"Hybrid-的劣势\"><a href=\"#Hybrid-的劣势\" class=\"headerlink\" title=\"Hybrid 的劣势\"></a>Hybrid 的劣势</h3><ul>\n<li>容易造成性能问题，不适用于依赖原生 API 、动画较多和游戏开发的需求。</li>\n<li>永远保持最新（直接访问线上，而不是使用 App 本地的静态资源）带来的低版本机型的适配问题，包括调用底层 API 和对 H5 的支持方面。（即不太好做版本控制）</li>\n<li>需要实现 Native 与 H5 之间的通信机制</li>\n<li>交互体验不如原生页面，需要尽可能仿制原生应用的体验</li>\n</ul>\n<p>总结来说，Web 只能替代、辅助一部分功能，无法取代原生开发的主导地位。</p>\n<h2 id=\"Hybrid-实现\"><a href=\"#Hybrid-实现\" class=\"headerlink\" title=\"Hybrid 实现\"></a>Hybrid 实现</h2><h3 id=\"Native-与前端之间的关系\"><a href=\"#Native-与前端之间的关系\" class=\"headerlink\" title=\"Native 与前端之间的关系\"></a>Native 与前端之间的关系</h3><p>Hybrid App 底层依赖于 Native 提供的容器，上层使用 H5 做业务开发，底层透明化、上层多样化，适合前端介入进行快速迭代开发。</p>\n<p>Native 提供的实际上是类似于浏览器的宿主环境，H5 页面可以利用宿主环境提供的“能力”来进行开发。正如一般浏览器为 JavaScript 提供了 window 对象以控制浏览器一样，Native 也可以为 H5 页面提供特定的接口以调用底层的 API。</p>\n<h3 id=\"Hybrid-交互设计\"><a href=\"#Hybrid-交互设计\" class=\"headerlink\" title=\"Hybrid 交互设计\"></a>Hybrid 交互设计</h3><p>Native 可以调用前端页面的 JavaScript 方法对视图进行操作，前端页面也可以通过 JavaScript 方法调用 Native 提供的接口实现系统层面的功能。两者沟通的桥梁则是 WebView。</p>\n<h3 id=\"Schema\"><a href=\"#Schema\" class=\"headerlink\" title=\"Schema\"></a><img src=\"/images/FE-Hybrid-interaction.png\" alt=\"\">Schema</h3><p>App 自身可以自定义 URL Schema，并且把自定义的 URL 注册在调度中心。App 安装后会在手机上注册一个 Schema，例如淘宝是 taobao:// ，Native 会有一个进程监控 WebView 发出的所有 schema:// 请求，从而打开 Native 应用并传入参数执行特定的行为。</p>\n<p>通过 Schema ，H5 可以通过发起 schema 请求，来实现 H5 与 Native 页面之间的跳转。</p>\n<h3 id=\"常用交互-API\"><a href=\"#常用交互-API\" class=\"headerlink\" title=\"常用交互 API\"></a>常用交互 API</h3><ul>\n<li>跳转<ul>\n<li>页面内部跳转</li>\n<li>H5 跳转 Native 界面，Native 通过截获 URL 参数跳转到响应页面。</li>\n<li>H5 新打开一个 WebView。</li>\n</ul>\n</li>\n<li>Header 组件<ul>\n<li>避免白屏陷入假死状态</li>\n<li>Header 左侧和右侧按钮可配置，中间 title 部分可配置</li>\n</ul>\n</li>\n<li>请求类<ul>\n<li>通过 Native 代理发起 AJAX 请求，解决跨域问题</li>\n</ul>\n</li>\n<li>Native UI 组件<ul>\n<li>Loading 组件</li>\n<li>Toast 组件</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://www.cnblogs.com/yexiaochai/p/4921635.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/yexiaochai/p/4921635.html</a></p>\n<p><a href=\"http://ued.ctrip.com/blog/translation-hybrid-mobile-application-provide-native-web-technology-experience.html\" target=\"_blank\" rel=\"external\">http://ued.ctrip.com/blog/translation-hybrid-mobile-application-provide-native-web-technology-experience.html</a></p>\n<p><a href=\"https://dailc.github.io/2016/10/04/hybridBase01HybridInfo.html\" target=\"_blank\" rel=\"external\">https://dailc.github.io/2016/10/04/hybridBase01HybridInfo.html</a></p>\n<p><a href=\"https://dailc.github.io/2016/10/04/hybridBase02HybridCompareOthers.html\" target=\"_blank\" rel=\"external\">https://dailc.github.io/2016/10/04/hybridBase02HybridCompareOthers.html</a></p>\n<p><a href=\"https://weex.apache.org/cn/\" target=\"_blank\" rel=\"external\">https://weex.apache.org/cn/</a></p>\n<p><a href=\"http://www.infoq.com/cn/articles/hybrid-app-development-combat#note-bottom-anchor\" target=\"_blank\" rel=\"external\">http://www.infoq.com/cn/articles/hybrid-app-development-combat#note-bottom-anchor</a></p>\n<p><a href=\"http://www.jianshu.com/p/e83aa2d1ade3\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/e83aa2d1ade3</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"什么是Hybrid\"><a href=\"#什么是Hybrid\" class=\"headerlink\" title=\"什么是Hybrid\"></a>什么是Hybrid</h2><h3 id=\"Hybrid-出现的历史原因\"><a href=\"#Hybrid-出现的历史原因\" class=\"headerlink\" title=\"Hybrid 出现的历史原因\"></a>Hybrid 出现的历史原因</h3><ul>\n<li>2013年起移动互联网的兴起导致App开发的需求日益高涨。</li>\n<li>2014年 H5 的发布，使得 Web 能够实现更多功能。</li>\n<li>在产品需要快速迭代、抢占市场的大背景下，开发 iOS 和 Android 原生应用的时间成本和劳动成本都非常高。</li>\n<li>随着 iOS 和 Android 两大阵营对 H5 的支持日益完善，H5 足以实现大多数的需求。</li>\n<li>为了利用 Web 应用低成本、高效率、跨成本等诸多优点，出现了使用 Web 和 Native 混合进行开发的模式。</li>\n</ul>\n<h3 id=\"Hybrid-的分类\"><a href=\"#Hybrid-的分类\" class=\"headerlink\" title=\"Hybrid 的分类\"></a>Hybrid 的分类</h3><p>App 应用从实现机制上来区分，主要分为三类：</p>\n<ol>\n<li>Native 应用：使用原生语言的应用，能够调用所有底层接口，交互体验最好。</li>\n<li>Web App 应用：使用纯 Web 开发的应用，通过浏览器访问，交互体验最差。</li>\n<li>Hybrid 应用：<ol>\n<li>以 WebView 作为用户界面层，以 JavaScript 为基本逻辑通过与中间件通讯、访问底层 API ，进行应用开发。</li>\n<li>使用非官方语言的工具，打包成原生应用的方式开发。</li>\n<li>基于原生应用的架构，在部分功能中嵌入 WebView 。WebView 负责对界面的渲染，同时也可以访问底层的 API 以实现特定的功能。</li>\n<li>通过 JavaScript 引擎管理和渲染 native 视图，将 JavaScript 代码渲染成原生组件，调用原生 API 与用户进行交互。（ReactNative、Weex）</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"Hybrid-的优势\"><a href=\"#Hybrid-的优势\" class=\"headerlink\" title=\"Hybrid 的优势\"></a>Hybrid 的优势</h3><ul>\n<li>开发效率高</li>\n<li>开发成本低</li>\n<li>跨平台</li>\n<li>快速迭代，无需发布版本即可修复Bug</li>\n</ul>\n<p>总结来说，Hybrid 是既保持了对原生API的完整掌控，同时可以在特定功能下节省跨平台开发成本、提升效率。</p>\n<h3 id=\"Hybrid-的劣势\"><a href=\"#Hybrid-的劣势\" class=\"headerlink\" title=\"Hybrid 的劣势\"></a>Hybrid 的劣势</h3><ul>\n<li>容易造成性能问题，不适用于依赖原生 API 、动画较多和游戏开发的需求。</li>\n<li>永远保持最新（直接访问线上，而不是使用 App 本地的静态资源）带来的低版本机型的适配问题，包括调用底层 API 和对 H5 的支持方面。（即不太好做版本控制）</li>\n<li>需要实现 Native 与 H5 之间的通信机制</li>\n<li>交互体验不如原生页面，需要尽可能仿制原生应用的体验</li>\n</ul>\n<p>总结来说，Web 只能替代、辅助一部分功能，无法取代原生开发的主导地位。</p>\n<h2 id=\"Hybrid-实现\"><a href=\"#Hybrid-实现\" class=\"headerlink\" title=\"Hybrid 实现\"></a>Hybrid 实现</h2><h3 id=\"Native-与前端之间的关系\"><a href=\"#Native-与前端之间的关系\" class=\"headerlink\" title=\"Native 与前端之间的关系\"></a>Native 与前端之间的关系</h3><p>Hybrid App 底层依赖于 Native 提供的容器，上层使用 H5 做业务开发，底层透明化、上层多样化，适合前端介入进行快速迭代开发。</p>\n<p>Native 提供的实际上是类似于浏览器的宿主环境，H5 页面可以利用宿主环境提供的“能力”来进行开发。正如一般浏览器为 JavaScript 提供了 window 对象以控制浏览器一样，Native 也可以为 H5 页面提供特定的接口以调用底层的 API。</p>\n<h3 id=\"Hybrid-交互设计\"><a href=\"#Hybrid-交互设计\" class=\"headerlink\" title=\"Hybrid 交互设计\"></a>Hybrid 交互设计</h3><p>Native 可以调用前端页面的 JavaScript 方法对视图进行操作，前端页面也可以通过 JavaScript 方法调用 Native 提供的接口实现系统层面的功能。两者沟通的桥梁则是 WebView。</p>\n<h3 id=\"Schema\"><a href=\"#Schema\" class=\"headerlink\" title=\"Schema\"></a><img src=\"/images/FE-Hybrid-interaction.png\" alt=\"\">Schema</h3><p>App 自身可以自定义 URL Schema，并且把自定义的 URL 注册在调度中心。App 安装后会在手机上注册一个 Schema，例如淘宝是 taobao:// ，Native 会有一个进程监控 WebView 发出的所有 schema:// 请求，从而打开 Native 应用并传入参数执行特定的行为。</p>\n<p>通过 Schema ，H5 可以通过发起 schema 请求，来实现 H5 与 Native 页面之间的跳转。</p>\n<h3 id=\"常用交互-API\"><a href=\"#常用交互-API\" class=\"headerlink\" title=\"常用交互 API\"></a>常用交互 API</h3><ul>\n<li>跳转<ul>\n<li>页面内部跳转</li>\n<li>H5 跳转 Native 界面，Native 通过截获 URL 参数跳转到响应页面。</li>\n<li>H5 新打开一个 WebView。</li>\n</ul>\n</li>\n<li>Header 组件<ul>\n<li>避免白屏陷入假死状态</li>\n<li>Header 左侧和右侧按钮可配置，中间 title 部分可配置</li>\n</ul>\n</li>\n<li>请求类<ul>\n<li>通过 Native 代理发起 AJAX 请求，解决跨域问题</li>\n</ul>\n</li>\n<li>Native UI 组件<ul>\n<li>Loading 组件</li>\n<li>Toast 组件</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://www.cnblogs.com/yexiaochai/p/4921635.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/yexiaochai/p/4921635.html</a></p>\n<p><a href=\"http://ued.ctrip.com/blog/translation-hybrid-mobile-application-provide-native-web-technology-experience.html\" target=\"_blank\" rel=\"external\">http://ued.ctrip.com/blog/translation-hybrid-mobile-application-provide-native-web-technology-experience.html</a></p>\n<p><a href=\"https://dailc.github.io/2016/10/04/hybridBase01HybridInfo.html\" target=\"_blank\" rel=\"external\">https://dailc.github.io/2016/10/04/hybridBase01HybridInfo.html</a></p>\n<p><a href=\"https://dailc.github.io/2016/10/04/hybridBase02HybridCompareOthers.html\" target=\"_blank\" rel=\"external\">https://dailc.github.io/2016/10/04/hybridBase02HybridCompareOthers.html</a></p>\n<p><a href=\"https://weex.apache.org/cn/\" target=\"_blank\" rel=\"external\">https://weex.apache.org/cn/</a></p>\n<p><a href=\"http://www.infoq.com/cn/articles/hybrid-app-development-combat#note-bottom-anchor\" target=\"_blank\" rel=\"external\">http://www.infoq.com/cn/articles/hybrid-app-development-combat#note-bottom-anchor</a></p>\n<p><a href=\"http://www.jianshu.com/p/e83aa2d1ade3\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/e83aa2d1ade3</a></p>\n"},{"layout":"post","title":"Shell 脚本入门","date":"2017-07-06T12:00:00.000Z","_content":"\n在本文开始之前，我想先阐述一下本文的基本内容。\n\n本文的标题是《Shell 脚本入门》，内容将涵盖 如何写一个基本的 Shell 脚本、如何运行它、一些基本的流程控制和判断，以及更多可供参考学习的站点。\n\n那话不多说，让我们从一个最简单的 Shell 脚本开始吧~\n\n## 一、Hello World\n\n打开一个文本编辑器，输入以下脚本代码，保存为 helloworld.sh：\n\n```\n#!/bin/sh\n\n# it's just a demo\n\necho \"Hello World\"\n```\n\n接着，打开 命令行 ，切换至 helloworld.sh 所在目录，并输入以下命令：\n\n```\n$ /bin/sh helloworld.sh\n```\n\n可以看到，命令行中输出了 “哈喽沃德”：\n\n```\nHello World\n```\n\n好了，这就是我们使用一个 Shell 脚本的基本流程：编写脚本 =&gt; 运行脚本 =&gt; 运行结果。\n\n## 二、编写的三个要素\n\n观察一下我们的 helloworld.sh，我们可以把它分为三部分：指定程序、注释说明 以及 脚本命令。\n\n### 1、指定程序：`#!/bin/sh`\n\n符号 `#!` 用于指定运行该脚本使用的程序。\n\n在 helloworld.sh 中，我们用 `/bin/sh`来执行这个脚本。\n\n### 2、注释说明：`# it's just a demo`\n\n注释，以 `#` 开头的一行表示注释。\n\n```\n#!/bin/sh\n\n# 这里是注释 \n# 可以用来解释这个脚本是用来做什么的 \n\n######### 分割线 #############\n# 你也可以用多个#来做注释之间的分割\n#############################\n\necho \"Hello World\"\n```\n\n### 3、脚本命令： `echo \"Hello World\"`\n\n`echo`用于在命令行中打印指定的字符串。\n\n你可以用单引号、双引号将要打印的字符串包裹起来，也可以选择不用引号。\n\n## 三、运行的两个方式\n\n运行一个脚本，有两种方法：作为参数 或者是 作为可执行文件。\n\n### 1、作为参数\n\n```\n$ /bin/bash ./helloworld.sh\n```\n\n可以看到，我们通过给 `/bin/bash` 这个程序指定要运行的脚本，来运行 helloworld.sh 的。\n\n### 2、作为可执行文件\n\n首先，我们让这个脚本变成**可执行**的程序：\n\n```\n$ chmod +x helloworld.sh\n```\n\n接下来，就可以直接运行这个脚本：\n\n```\n$ ./helloworld.sh\n```\n\n## 四、小进阶\n\n在了解了基本的 Shell 编程之后，我们来让 Shell 脚本做更多的事情。\n\n### 1、读取输入\n\n```\n#!/bin/sh\n\n# read.sh\n\necho \"你的名字？\"\nread name\n\necho \"你好 $name，很高兴认识你。\"\n```\n\n运行一下：\n\n```\n$ /bin/sh read.sh \n你的名字？\n```\n\n输入 `daixinye`，回车：\n\n```\n你好daixinye，很高兴认识你。\n```\n\n### 2、条件判断\n\n```\n#!/bin/sh\n\n# if.sh\n\necho \"你的年龄？\"\nread age\n\n# 注意 等号左右两边 不能有空格\nmyAge=18\n\n# 注意 方括号内部前后 需要有空格\nif [ $age == $myAge ]\n    then \n        echo \"我们岁数一样哦\"\n    else \n        echo \"我们岁数不一样哦\" \nfi\n```\n\n运行一下：\n\n```\n$ /bin/sh if.sh \n你的年龄？\n```\n\n输入 `18`，回车：\n\n```\n我们岁数一样哦\n```\n\n### 3、条件循环\n\n```\n#!/bin/sh\n\n# while.sh\n\necho \"我有一个数字，你要来猜一下吗？1~1000哦\"\n\nanswer=666\nbingo=0\n\nwhile [ $bingo == 0 ]; do \n    read guess\n    if [ $guess == $answer ]\n        then\n            echo \"猜对啦\"\n            bingo=1\n        else\n            echo \"猜错啦，再猜一次吧？\"\n    fi\ndone\n```\n\n运行一下：\n\n```\n$ /bin/sh while.sh \n我有一个数字，你要来猜一下吗？1~1000哦\n```\n\n依次输入1、5、10、100、600、666 ：\n\n```\n1\n猜错啦，再猜一次吧？\n5\n猜错啦，再猜一次吧？\n10\n猜错啦，再猜一次吧？\n100\n猜错啦，再猜一次吧？\n600\n猜错啦，再猜一次吧？\n666\n猜对啦\n```\n\n## 五、小结\n\n好啦，通过本文你应该已经了解了以下几个知识点：\n\n1. 如何写一个基本 Shell脚本\n2. 如何打印内容（echo）\n3. 如何运行脚本（作为参数和作为可执行程序）\n4. 如何读取输入（read）\n5. 如何进行条件判断（if...else 语句）\n6. 如何进行条件循环（while... do 语句）\n\n## 本文参考\n\n[https://my.oschina.net/maczhao/blog/349452](https://my.oschina.net/maczhao/blog/349452)\n\n## 测试代码\n\n[https://github.com/daixinye/practice/tree/master/shell](https://github.com/daixinye/practice/tree/master/shell)\n\n\n\n\n\n","source":"_posts/2017-07-06-Shell 脚本入门.md","raw":"---\nlayout: post\ntitle:  \"Shell 脚本入门\"\ndate:   2017-07-06 20:00:00 +0800\ncategories: shell\n---\n\n在本文开始之前，我想先阐述一下本文的基本内容。\n\n本文的标题是《Shell 脚本入门》，内容将涵盖 如何写一个基本的 Shell 脚本、如何运行它、一些基本的流程控制和判断，以及更多可供参考学习的站点。\n\n那话不多说，让我们从一个最简单的 Shell 脚本开始吧~\n\n## 一、Hello World\n\n打开一个文本编辑器，输入以下脚本代码，保存为 helloworld.sh：\n\n```\n#!/bin/sh\n\n# it's just a demo\n\necho \"Hello World\"\n```\n\n接着，打开 命令行 ，切换至 helloworld.sh 所在目录，并输入以下命令：\n\n```\n$ /bin/sh helloworld.sh\n```\n\n可以看到，命令行中输出了 “哈喽沃德”：\n\n```\nHello World\n```\n\n好了，这就是我们使用一个 Shell 脚本的基本流程：编写脚本 =&gt; 运行脚本 =&gt; 运行结果。\n\n## 二、编写的三个要素\n\n观察一下我们的 helloworld.sh，我们可以把它分为三部分：指定程序、注释说明 以及 脚本命令。\n\n### 1、指定程序：`#!/bin/sh`\n\n符号 `#!` 用于指定运行该脚本使用的程序。\n\n在 helloworld.sh 中，我们用 `/bin/sh`来执行这个脚本。\n\n### 2、注释说明：`# it's just a demo`\n\n注释，以 `#` 开头的一行表示注释。\n\n```\n#!/bin/sh\n\n# 这里是注释 \n# 可以用来解释这个脚本是用来做什么的 \n\n######### 分割线 #############\n# 你也可以用多个#来做注释之间的分割\n#############################\n\necho \"Hello World\"\n```\n\n### 3、脚本命令： `echo \"Hello World\"`\n\n`echo`用于在命令行中打印指定的字符串。\n\n你可以用单引号、双引号将要打印的字符串包裹起来，也可以选择不用引号。\n\n## 三、运行的两个方式\n\n运行一个脚本，有两种方法：作为参数 或者是 作为可执行文件。\n\n### 1、作为参数\n\n```\n$ /bin/bash ./helloworld.sh\n```\n\n可以看到，我们通过给 `/bin/bash` 这个程序指定要运行的脚本，来运行 helloworld.sh 的。\n\n### 2、作为可执行文件\n\n首先，我们让这个脚本变成**可执行**的程序：\n\n```\n$ chmod +x helloworld.sh\n```\n\n接下来，就可以直接运行这个脚本：\n\n```\n$ ./helloworld.sh\n```\n\n## 四、小进阶\n\n在了解了基本的 Shell 编程之后，我们来让 Shell 脚本做更多的事情。\n\n### 1、读取输入\n\n```\n#!/bin/sh\n\n# read.sh\n\necho \"你的名字？\"\nread name\n\necho \"你好 $name，很高兴认识你。\"\n```\n\n运行一下：\n\n```\n$ /bin/sh read.sh \n你的名字？\n```\n\n输入 `daixinye`，回车：\n\n```\n你好daixinye，很高兴认识你。\n```\n\n### 2、条件判断\n\n```\n#!/bin/sh\n\n# if.sh\n\necho \"你的年龄？\"\nread age\n\n# 注意 等号左右两边 不能有空格\nmyAge=18\n\n# 注意 方括号内部前后 需要有空格\nif [ $age == $myAge ]\n    then \n        echo \"我们岁数一样哦\"\n    else \n        echo \"我们岁数不一样哦\" \nfi\n```\n\n运行一下：\n\n```\n$ /bin/sh if.sh \n你的年龄？\n```\n\n输入 `18`，回车：\n\n```\n我们岁数一样哦\n```\n\n### 3、条件循环\n\n```\n#!/bin/sh\n\n# while.sh\n\necho \"我有一个数字，你要来猜一下吗？1~1000哦\"\n\nanswer=666\nbingo=0\n\nwhile [ $bingo == 0 ]; do \n    read guess\n    if [ $guess == $answer ]\n        then\n            echo \"猜对啦\"\n            bingo=1\n        else\n            echo \"猜错啦，再猜一次吧？\"\n    fi\ndone\n```\n\n运行一下：\n\n```\n$ /bin/sh while.sh \n我有一个数字，你要来猜一下吗？1~1000哦\n```\n\n依次输入1、5、10、100、600、666 ：\n\n```\n1\n猜错啦，再猜一次吧？\n5\n猜错啦，再猜一次吧？\n10\n猜错啦，再猜一次吧？\n100\n猜错啦，再猜一次吧？\n600\n猜错啦，再猜一次吧？\n666\n猜对啦\n```\n\n## 五、小结\n\n好啦，通过本文你应该已经了解了以下几个知识点：\n\n1. 如何写一个基本 Shell脚本\n2. 如何打印内容（echo）\n3. 如何运行脚本（作为参数和作为可执行程序）\n4. 如何读取输入（read）\n5. 如何进行条件判断（if...else 语句）\n6. 如何进行条件循环（while... do 语句）\n\n## 本文参考\n\n[https://my.oschina.net/maczhao/blog/349452](https://my.oschina.net/maczhao/blog/349452)\n\n## 测试代码\n\n[https://github.com/daixinye/practice/tree/master/shell](https://github.com/daixinye/practice/tree/master/shell)\n\n\n\n\n\n","slug":"2017-07-06-Shell 脚本入门","published":1,"updated":"2017-07-30T15:33:48.000Z","comments":1,"photos":[],"link":"","_id":"cj5qx2mlr000jb4or8ayvyy53","content":"<p>在本文开始之前，我想先阐述一下本文的基本内容。</p>\n<p>本文的标题是《Shell 脚本入门》，内容将涵盖 如何写一个基本的 Shell 脚本、如何运行它、一些基本的流程控制和判断，以及更多可供参考学习的站点。</p>\n<p>那话不多说，让我们从一个最简单的 Shell 脚本开始吧~</p>\n<h2 id=\"一、Hello-World\"><a href=\"#一、Hello-World\" class=\"headerlink\" title=\"一、Hello World\"></a>一、Hello World</h2><p>打开一个文本编辑器，输入以下脚本代码，保存为 helloworld.sh：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">#!/bin/sh</div><div class=\"line\"></div><div class=\"line\"># it&apos;s just a demo</div><div class=\"line\"></div><div class=\"line\">echo &quot;Hello World&quot;</div></pre></td></tr></table></figure>\n<p>接着，打开 命令行 ，切换至 helloworld.sh 所在目录，并输入以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ /bin/sh helloworld.sh</div></pre></td></tr></table></figure>\n<p>可以看到，命令行中输出了 “哈喽沃德”：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Hello World</div></pre></td></tr></table></figure>\n<p>好了，这就是我们使用一个 Shell 脚本的基本流程：编写脚本 =&gt; 运行脚本 =&gt; 运行结果。</p>\n<h2 id=\"二、编写的三个要素\"><a href=\"#二、编写的三个要素\" class=\"headerlink\" title=\"二、编写的三个要素\"></a>二、编写的三个要素</h2><p>观察一下我们的 helloworld.sh，我们可以把它分为三部分：指定程序、注释说明 以及 脚本命令。</p>\n<h3 id=\"1、指定程序：-bin-sh\"><a href=\"#1、指定程序：-bin-sh\" class=\"headerlink\" title=\"1、指定程序：#!/bin/sh\"></a>1、指定程序：<code>#!/bin/sh</code></h3><p>符号 <code>#!</code> 用于指定运行该脚本使用的程序。</p>\n<p>在 helloworld.sh 中，我们用 <code>/bin/sh</code>来执行这个脚本。</p>\n<h3 id=\"2、注释说明：-it-39-s-just-a-demo\"><a href=\"#2、注释说明：-it-39-s-just-a-demo\" class=\"headerlink\" title=\"2、注释说明：# it&#39;s just a demo\"></a>2、注释说明：<code># it&#39;s just a demo</code></h3><p>注释，以 <code>#</code> 开头的一行表示注释。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">#!/bin/sh</div><div class=\"line\"></div><div class=\"line\"># 这里是注释 </div><div class=\"line\"># 可以用来解释这个脚本是用来做什么的 </div><div class=\"line\"></div><div class=\"line\">######### 分割线 #############</div><div class=\"line\"># 你也可以用多个#来做注释之间的分割</div><div class=\"line\">#############################</div><div class=\"line\"></div><div class=\"line\">echo &quot;Hello World&quot;</div></pre></td></tr></table></figure>\n<h3 id=\"3、脚本命令：-echo-quot-Hello-World-quot\"><a href=\"#3、脚本命令：-echo-quot-Hello-World-quot\" class=\"headerlink\" title=\"3、脚本命令： echo &quot;Hello World&quot;\"></a>3、脚本命令： <code>echo &quot;Hello World&quot;</code></h3><p><code>echo</code>用于在命令行中打印指定的字符串。</p>\n<p>你可以用单引号、双引号将要打印的字符串包裹起来，也可以选择不用引号。</p>\n<h2 id=\"三、运行的两个方式\"><a href=\"#三、运行的两个方式\" class=\"headerlink\" title=\"三、运行的两个方式\"></a>三、运行的两个方式</h2><p>运行一个脚本，有两种方法：作为参数 或者是 作为可执行文件。</p>\n<h3 id=\"1、作为参数\"><a href=\"#1、作为参数\" class=\"headerlink\" title=\"1、作为参数\"></a>1、作为参数</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ /bin/bash ./helloworld.sh</div></pre></td></tr></table></figure>\n<p>可以看到，我们通过给 <code>/bin/bash</code> 这个程序指定要运行的脚本，来运行 helloworld.sh 的。</p>\n<h3 id=\"2、作为可执行文件\"><a href=\"#2、作为可执行文件\" class=\"headerlink\" title=\"2、作为可执行文件\"></a>2、作为可执行文件</h3><p>首先，我们让这个脚本变成<strong>可执行</strong>的程序：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ chmod +x helloworld.sh</div></pre></td></tr></table></figure>\n<p>接下来，就可以直接运行这个脚本：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ ./helloworld.sh</div></pre></td></tr></table></figure>\n<h2 id=\"四、小进阶\"><a href=\"#四、小进阶\" class=\"headerlink\" title=\"四、小进阶\"></a>四、小进阶</h2><p>在了解了基本的 Shell 编程之后，我们来让 Shell 脚本做更多的事情。</p>\n<h3 id=\"1、读取输入\"><a href=\"#1、读取输入\" class=\"headerlink\" title=\"1、读取输入\"></a>1、读取输入</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">#!/bin/sh</div><div class=\"line\"></div><div class=\"line\"># read.sh</div><div class=\"line\"></div><div class=\"line\">echo &quot;你的名字？&quot;</div><div class=\"line\">read name</div><div class=\"line\"></div><div class=\"line\">echo &quot;你好 $name，很高兴认识你。&quot;</div></pre></td></tr></table></figure>\n<p>运行一下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ /bin/sh read.sh </div><div class=\"line\">你的名字？</div></pre></td></tr></table></figure>\n<p>输入 <code>daixinye</code>，回车：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">你好daixinye，很高兴认识你。</div></pre></td></tr></table></figure>\n<h3 id=\"2、条件判断\"><a href=\"#2、条件判断\" class=\"headerlink\" title=\"2、条件判断\"></a>2、条件判断</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">#!/bin/sh</div><div class=\"line\"></div><div class=\"line\"># if.sh</div><div class=\"line\"></div><div class=\"line\">echo &quot;你的年龄？&quot;</div><div class=\"line\">read age</div><div class=\"line\"></div><div class=\"line\"># 注意 等号左右两边 不能有空格</div><div class=\"line\">myAge=18</div><div class=\"line\"></div><div class=\"line\"># 注意 方括号内部前后 需要有空格</div><div class=\"line\">if [ $age == $myAge ]</div><div class=\"line\">    then </div><div class=\"line\">        echo &quot;我们岁数一样哦&quot;</div><div class=\"line\">    else </div><div class=\"line\">        echo &quot;我们岁数不一样哦&quot; </div><div class=\"line\">fi</div></pre></td></tr></table></figure>\n<p>运行一下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ /bin/sh if.sh </div><div class=\"line\">你的年龄？</div></pre></td></tr></table></figure>\n<p>输入 <code>18</code>，回车：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">我们岁数一样哦</div></pre></td></tr></table></figure>\n<h3 id=\"3、条件循环\"><a href=\"#3、条件循环\" class=\"headerlink\" title=\"3、条件循环\"></a>3、条件循环</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">#!/bin/sh</div><div class=\"line\"></div><div class=\"line\"># while.sh</div><div class=\"line\"></div><div class=\"line\">echo &quot;我有一个数字，你要来猜一下吗？1~1000哦&quot;</div><div class=\"line\"></div><div class=\"line\">answer=666</div><div class=\"line\">bingo=0</div><div class=\"line\"></div><div class=\"line\">while [ $bingo == 0 ]; do </div><div class=\"line\">    read guess</div><div class=\"line\">    if [ $guess == $answer ]</div><div class=\"line\">        then</div><div class=\"line\">            echo &quot;猜对啦&quot;</div><div class=\"line\">            bingo=1</div><div class=\"line\">        else</div><div class=\"line\">            echo &quot;猜错啦，再猜一次吧？&quot;</div><div class=\"line\">    fi</div><div class=\"line\">done</div></pre></td></tr></table></figure>\n<p>运行一下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ /bin/sh while.sh </div><div class=\"line\">我有一个数字，你要来猜一下吗？1~1000哦</div></pre></td></tr></table></figure>\n<p>依次输入1、5、10、100、600、666 ：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">1</div><div class=\"line\">猜错啦，再猜一次吧？</div><div class=\"line\">5</div><div class=\"line\">猜错啦，再猜一次吧？</div><div class=\"line\">10</div><div class=\"line\">猜错啦，再猜一次吧？</div><div class=\"line\">100</div><div class=\"line\">猜错啦，再猜一次吧？</div><div class=\"line\">600</div><div class=\"line\">猜错啦，再猜一次吧？</div><div class=\"line\">666</div><div class=\"line\">猜对啦</div></pre></td></tr></table></figure>\n<h2 id=\"五、小结\"><a href=\"#五、小结\" class=\"headerlink\" title=\"五、小结\"></a>五、小结</h2><p>好啦，通过本文你应该已经了解了以下几个知识点：</p>\n<ol>\n<li>如何写一个基本 Shell脚本</li>\n<li>如何打印内容（echo）</li>\n<li>如何运行脚本（作为参数和作为可执行程序）</li>\n<li>如何读取输入（read）</li>\n<li>如何进行条件判断（if…else 语句）</li>\n<li>如何进行条件循环（while… do 语句）</li>\n</ol>\n<h2 id=\"本文参考\"><a href=\"#本文参考\" class=\"headerlink\" title=\"本文参考\"></a>本文参考</h2><p><a href=\"https://my.oschina.net/maczhao/blog/349452\" target=\"_blank\" rel=\"external\">https://my.oschina.net/maczhao/blog/349452</a></p>\n<h2 id=\"测试代码\"><a href=\"#测试代码\" class=\"headerlink\" title=\"测试代码\"></a>测试代码</h2><p><a href=\"https://github.com/daixinye/practice/tree/master/shell\" target=\"_blank\" rel=\"external\">https://github.com/daixinye/practice/tree/master/shell</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>在本文开始之前，我想先阐述一下本文的基本内容。</p>\n<p>本文的标题是《Shell 脚本入门》，内容将涵盖 如何写一个基本的 Shell 脚本、如何运行它、一些基本的流程控制和判断，以及更多可供参考学习的站点。</p>\n<p>那话不多说，让我们从一个最简单的 Shell 脚本开始吧~</p>\n<h2 id=\"一、Hello-World\"><a href=\"#一、Hello-World\" class=\"headerlink\" title=\"一、Hello World\"></a>一、Hello World</h2><p>打开一个文本编辑器，输入以下脚本代码，保存为 helloworld.sh：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">#!/bin/sh</div><div class=\"line\"></div><div class=\"line\"># it&apos;s just a demo</div><div class=\"line\"></div><div class=\"line\">echo &quot;Hello World&quot;</div></pre></td></tr></table></figure>\n<p>接着，打开 命令行 ，切换至 helloworld.sh 所在目录，并输入以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ /bin/sh helloworld.sh</div></pre></td></tr></table></figure>\n<p>可以看到，命令行中输出了 “哈喽沃德”：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Hello World</div></pre></td></tr></table></figure>\n<p>好了，这就是我们使用一个 Shell 脚本的基本流程：编写脚本 =&gt; 运行脚本 =&gt; 运行结果。</p>\n<h2 id=\"二、编写的三个要素\"><a href=\"#二、编写的三个要素\" class=\"headerlink\" title=\"二、编写的三个要素\"></a>二、编写的三个要素</h2><p>观察一下我们的 helloworld.sh，我们可以把它分为三部分：指定程序、注释说明 以及 脚本命令。</p>\n<h3 id=\"1、指定程序：-bin-sh\"><a href=\"#1、指定程序：-bin-sh\" class=\"headerlink\" title=\"1、指定程序：#!/bin/sh\"></a>1、指定程序：<code>#!/bin/sh</code></h3><p>符号 <code>#!</code> 用于指定运行该脚本使用的程序。</p>\n<p>在 helloworld.sh 中，我们用 <code>/bin/sh</code>来执行这个脚本。</p>\n<h3 id=\"2、注释说明：-it-39-s-just-a-demo\"><a href=\"#2、注释说明：-it-39-s-just-a-demo\" class=\"headerlink\" title=\"2、注释说明：# it&#39;s just a demo\"></a>2、注释说明：<code># it&#39;s just a demo</code></h3><p>注释，以 <code>#</code> 开头的一行表示注释。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">#!/bin/sh</div><div class=\"line\"></div><div class=\"line\"># 这里是注释 </div><div class=\"line\"># 可以用来解释这个脚本是用来做什么的 </div><div class=\"line\"></div><div class=\"line\">######### 分割线 #############</div><div class=\"line\"># 你也可以用多个#来做注释之间的分割</div><div class=\"line\">#############################</div><div class=\"line\"></div><div class=\"line\">echo &quot;Hello World&quot;</div></pre></td></tr></table></figure>\n<h3 id=\"3、脚本命令：-echo-quot-Hello-World-quot\"><a href=\"#3、脚本命令：-echo-quot-Hello-World-quot\" class=\"headerlink\" title=\"3、脚本命令： echo &quot;Hello World&quot;\"></a>3、脚本命令： <code>echo &quot;Hello World&quot;</code></h3><p><code>echo</code>用于在命令行中打印指定的字符串。</p>\n<p>你可以用单引号、双引号将要打印的字符串包裹起来，也可以选择不用引号。</p>\n<h2 id=\"三、运行的两个方式\"><a href=\"#三、运行的两个方式\" class=\"headerlink\" title=\"三、运行的两个方式\"></a>三、运行的两个方式</h2><p>运行一个脚本，有两种方法：作为参数 或者是 作为可执行文件。</p>\n<h3 id=\"1、作为参数\"><a href=\"#1、作为参数\" class=\"headerlink\" title=\"1、作为参数\"></a>1、作为参数</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ /bin/bash ./helloworld.sh</div></pre></td></tr></table></figure>\n<p>可以看到，我们通过给 <code>/bin/bash</code> 这个程序指定要运行的脚本，来运行 helloworld.sh 的。</p>\n<h3 id=\"2、作为可执行文件\"><a href=\"#2、作为可执行文件\" class=\"headerlink\" title=\"2、作为可执行文件\"></a>2、作为可执行文件</h3><p>首先，我们让这个脚本变成<strong>可执行</strong>的程序：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ chmod +x helloworld.sh</div></pre></td></tr></table></figure>\n<p>接下来，就可以直接运行这个脚本：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ ./helloworld.sh</div></pre></td></tr></table></figure>\n<h2 id=\"四、小进阶\"><a href=\"#四、小进阶\" class=\"headerlink\" title=\"四、小进阶\"></a>四、小进阶</h2><p>在了解了基本的 Shell 编程之后，我们来让 Shell 脚本做更多的事情。</p>\n<h3 id=\"1、读取输入\"><a href=\"#1、读取输入\" class=\"headerlink\" title=\"1、读取输入\"></a>1、读取输入</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">#!/bin/sh</div><div class=\"line\"></div><div class=\"line\"># read.sh</div><div class=\"line\"></div><div class=\"line\">echo &quot;你的名字？&quot;</div><div class=\"line\">read name</div><div class=\"line\"></div><div class=\"line\">echo &quot;你好 $name，很高兴认识你。&quot;</div></pre></td></tr></table></figure>\n<p>运行一下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ /bin/sh read.sh </div><div class=\"line\">你的名字？</div></pre></td></tr></table></figure>\n<p>输入 <code>daixinye</code>，回车：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">你好daixinye，很高兴认识你。</div></pre></td></tr></table></figure>\n<h3 id=\"2、条件判断\"><a href=\"#2、条件判断\" class=\"headerlink\" title=\"2、条件判断\"></a>2、条件判断</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">#!/bin/sh</div><div class=\"line\"></div><div class=\"line\"># if.sh</div><div class=\"line\"></div><div class=\"line\">echo &quot;你的年龄？&quot;</div><div class=\"line\">read age</div><div class=\"line\"></div><div class=\"line\"># 注意 等号左右两边 不能有空格</div><div class=\"line\">myAge=18</div><div class=\"line\"></div><div class=\"line\"># 注意 方括号内部前后 需要有空格</div><div class=\"line\">if [ $age == $myAge ]</div><div class=\"line\">    then </div><div class=\"line\">        echo &quot;我们岁数一样哦&quot;</div><div class=\"line\">    else </div><div class=\"line\">        echo &quot;我们岁数不一样哦&quot; </div><div class=\"line\">fi</div></pre></td></tr></table></figure>\n<p>运行一下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ /bin/sh if.sh </div><div class=\"line\">你的年龄？</div></pre></td></tr></table></figure>\n<p>输入 <code>18</code>，回车：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">我们岁数一样哦</div></pre></td></tr></table></figure>\n<h3 id=\"3、条件循环\"><a href=\"#3、条件循环\" class=\"headerlink\" title=\"3、条件循环\"></a>3、条件循环</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">#!/bin/sh</div><div class=\"line\"></div><div class=\"line\"># while.sh</div><div class=\"line\"></div><div class=\"line\">echo &quot;我有一个数字，你要来猜一下吗？1~1000哦&quot;</div><div class=\"line\"></div><div class=\"line\">answer=666</div><div class=\"line\">bingo=0</div><div class=\"line\"></div><div class=\"line\">while [ $bingo == 0 ]; do </div><div class=\"line\">    read guess</div><div class=\"line\">    if [ $guess == $answer ]</div><div class=\"line\">        then</div><div class=\"line\">            echo &quot;猜对啦&quot;</div><div class=\"line\">            bingo=1</div><div class=\"line\">        else</div><div class=\"line\">            echo &quot;猜错啦，再猜一次吧？&quot;</div><div class=\"line\">    fi</div><div class=\"line\">done</div></pre></td></tr></table></figure>\n<p>运行一下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ /bin/sh while.sh </div><div class=\"line\">我有一个数字，你要来猜一下吗？1~1000哦</div></pre></td></tr></table></figure>\n<p>依次输入1、5、10、100、600、666 ：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">1</div><div class=\"line\">猜错啦，再猜一次吧？</div><div class=\"line\">5</div><div class=\"line\">猜错啦，再猜一次吧？</div><div class=\"line\">10</div><div class=\"line\">猜错啦，再猜一次吧？</div><div class=\"line\">100</div><div class=\"line\">猜错啦，再猜一次吧？</div><div class=\"line\">600</div><div class=\"line\">猜错啦，再猜一次吧？</div><div class=\"line\">666</div><div class=\"line\">猜对啦</div></pre></td></tr></table></figure>\n<h2 id=\"五、小结\"><a href=\"#五、小结\" class=\"headerlink\" title=\"五、小结\"></a>五、小结</h2><p>好啦，通过本文你应该已经了解了以下几个知识点：</p>\n<ol>\n<li>如何写一个基本 Shell脚本</li>\n<li>如何打印内容（echo）</li>\n<li>如何运行脚本（作为参数和作为可执行程序）</li>\n<li>如何读取输入（read）</li>\n<li>如何进行条件判断（if…else 语句）</li>\n<li>如何进行条件循环（while… do 语句）</li>\n</ol>\n<h2 id=\"本文参考\"><a href=\"#本文参考\" class=\"headerlink\" title=\"本文参考\"></a>本文参考</h2><p><a href=\"https://my.oschina.net/maczhao/blog/349452\" target=\"_blank\" rel=\"external\">https://my.oschina.net/maczhao/blog/349452</a></p>\n<h2 id=\"测试代码\"><a href=\"#测试代码\" class=\"headerlink\" title=\"测试代码\"></a>测试代码</h2><p><a href=\"https://github.com/daixinye/practice/tree/master/shell\" target=\"_blank\" rel=\"external\">https://github.com/daixinye/practice/tree/master/shell</a></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cj5qx2ml10000b4or613n6816","category_id":"cj5qx2ml80002b4orio7jb1ah","_id":"cj5qx2mlh0008b4or2ar1xo5g"},{"post_id":"cj5qx2ml60001b4or3dnd471m","category_id":"cj5qx2ml80002b4orio7jb1ah","_id":"cj5qx2mln000cb4or56d97pfg"},{"post_id":"cj5qx2mla0003b4orkvmaedpm","category_id":"cj5qx2mll000ab4or5que9f9e","_id":"cj5qx2mlq000hb4ordwl049m1"},{"post_id":"cj5qx2mlp000fb4ordkl1aotm","category_id":"cj5qx2mll000ab4or5que9f9e","_id":"cj5qx2mls000kb4oro2zgit5u"},{"post_id":"cj5qx2mla0004b4or8g5m76qf","category_id":"cj5qx2mlo000eb4orch16muu9","_id":"cj5qx2mls000lb4orug5xcpr0"},{"post_id":"cj5qx2mld0005b4orb6zyex4h","category_id":"cj5qx2mlr000ib4orxjq63fl3","_id":"cj5qx2mlt000nb4or0ktpwukt"},{"post_id":"cj5qx2mlg0007b4orsfj4r09m","category_id":"cj5qx2mls000mb4orq39zwefg","_id":"cj5qx2mlu000pb4orzw6e20dg"},{"post_id":"cj5qx2mlj0009b4or99wocqa9","category_id":"cj5qx2mlu000ob4orbqani19k","_id":"cj5qx2mlw000rb4or0toxfknu"},{"post_id":"cj5qx2mlm000bb4orip0ur65y","category_id":"cj5qx2mlv000qb4orz4mstigi","_id":"cj5qx2mlx000tb4ork26ph57b"},{"post_id":"cj5qx2mln000db4orbpia9npv","category_id":"cj5qx2mlu000ob4orbqani19k","_id":"cj5qx2mly000vb4or2pzwavih"},{"post_id":"cj5qx2mlq000gb4orm3r9e70b","category_id":"cj5qx2mlx000ub4or3dgjzshk","_id":"cj5qx2mly000xb4ord94sjan7"},{"post_id":"cj5qx2mlr000jb4or8ayvyy53","category_id":"cj5qx2mly000wb4orr9ed1hl0","_id":"cj5qx2mly000yb4or8k7yhwey"}],"PostTag":[],"Tag":[]}}