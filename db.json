{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/FE-Hybrid-interaction.png","path":"images/FE-Hybrid-interaction.png","modified":0,"renderable":0},{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"38a0225af20d669d3403aa4815f881f861b9cb99","modified":1501593872000},{"_id":"themes/landscape/.DS_Store","hash":"ce67fc1fdf1c12286606ff4a98ede190da7ba5db","modified":1501593872000},{"_id":"themes/landscape/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1501430926000},{"_id":"themes/landscape/_config.yml","hash":"fb8c98a0f6ff9f962637f329c22699721854cd73","modified":1501174069000},{"_id":"themes/landscape/package.json","hash":"85358dc34311c6662e841584e206a4679183943f","modified":1501174069000},{"_id":"source/_posts/.DS_Store","hash":"451d9c042cd7f8e957e7219a3fa0d895fb1708e7","modified":1501593849000},{"_id":"source/_posts/2016-03-04-SVN：LNMP下搭建SVN服务器简明步骤.markdown","hash":"0b8ec4372a92aca89b0ad85132e10c5b10855f97","modified":1502021664000},{"_id":"source/_posts/2016-03-04-SVN：同步版本库与网站目录.markdown","hash":"9c920a020b663b09e5aca9c993ed17a3ad20646f","modified":1502021658000},{"_id":"source/_posts/2016-04-24-深入浅出React读后笔记.markdown","hash":"bbc03091a3dd62c79d652501e306eab29611c2d8","modified":1502021667000},{"_id":"source/_posts/2017-01-03-Git：常用命令整理.markdown","hash":"66a213f7c2a297d9620ba9b90c9c06d87c876570","modified":1502021670000},{"_id":"source/_posts/2017-04-01-CSS：如何去除 inline-block 带来的空白间距.md","hash":"35970f079713371c4f17a6031d7ef16286321f44","modified":1502021677000},{"_id":"source/_posts/2017-04-01-CSS：那些居中的方法们.md","hash":"bc6eae3e71188f48e701a4394b555f371398216f","modified":1502021673000},{"_id":"source/_posts/2017-04-02-CSS：line-height 不同取值的差异.md","hash":"98d92df71b11159aca12d68c3227c4c3eaa447dd","modified":1502021680000},{"_id":"source/_posts/2017-04-02-Sublime-Text-3的基本安装与配置.markdown","hash":"3bf6cdfc29af7c193344d074309a5c803b4786c1","modified":1502021682000},{"_id":"source/_posts/2017-04-07-Mac在Terminal打开Finder.markdown","hash":"77efbdd0e6f12a79fe8e316b6967a38138232b87","modified":1502021685000},{"_id":"source/_posts/2017-04-11-HTTP：协议基础.markdown","hash":"cbb4483005a1cfb1abd529a1af47f5121a5604fb","modified":1502021688000},{"_id":"source/_posts/2017-04-11-JavaScript：基本数据类型整理.markdown","hash":"6e0e7b0c0668246354e1537e90229e07c3f0fc7e","modified":1502021691000},{"_id":"source/_posts/2017-04-12-HTTP：常见的状态码.markdown","hash":"c827a807108b8647d642d55ddb3119d969b17011","modified":1502021695000},{"_id":"source/_posts/2017-04-14-React：基本环境搭建简明步骤.markdown","hash":"7e72cebae6d4b94a7703a34595bb5f145ba31843","modified":1502021699000},{"_id":"source/_posts/2017-04-24-前端：跨域方法小记.md","hash":"95995da93a8a95f1938831db3c3fceafd8ca18a2","modified":1502021702000},{"_id":"source/_posts/2017-04-26-jQuery：事件监听用法.md","hash":"75dadc013b32d7fa6045c673f01bba8230c8ca84","modified":1502021708000},{"_id":"source/_posts/2017-04-26-jQuery：基础 DOM 操作方法.md","hash":"85be2fcb5540f600135dd7d2c47f6a2e6b26f5df","modified":1502021705000},{"_id":"source/_posts/2017-04-27-JavaScript：作用域、闭包 和 this.md","hash":"795e61424806ce5f67c734943be15d9b35e7ed8a","modified":1502021712000},{"_id":"source/_posts/2017-05-03-JavaScript：从代码复用到面向对象.md","hash":"d6cdcde5bd3cca344a96fca2e5ed6df00f20c178","modified":1502021715000},{"_id":"source/_posts/2017-05-08-JavaScript：逻辑与 与 逻辑或.md","hash":"c72c037b0e06192646105db7fd578b5f189e84e9","modified":1502021718000},{"_id":"source/_posts/2017-05-19-JSON：JSON 方法小记.md","hash":"e0d17ae6d24be4fec713fc0bcdbedb384bfff814","modified":1501519334000},{"_id":"source/_posts/2017-05-23-什么是Hybrid App.markdown","hash":"31fa9db1999c644373a7d5bc6581d90e1eb9ac7e","modified":1502021731000},{"_id":"source/_posts/2017-05-28-JavaScript：Promise 小记.md","hash":"aafffe4278ac3117fc57abf7775ca4625c3ebb64","modified":1502021735000},{"_id":"source/_posts/2017-06-01-CSS：table-cell 用法小.md","hash":"9d368011b33479ce7d997dcacc7b26b74a44b570","modified":1502021740000},{"_id":"source/_posts/2017-06-21-CSS：Animation 动画.md","hash":"3edd0920946466f8c1c40d19d2faa0040b4909c3","modified":1502021743000},{"_id":"source/_posts/2017-06-21-Vue：基础用法与指令.md","hash":"78413ea17bab5880a30f34062eb87e6c6df00b31","modified":1502021747000},{"_id":"source/_posts/2017-07-05-CSS：什么是 BFC.md","hash":"dda6b3b52ce3be1ab4de734a810732581ae4f31f","modified":1502021750000},{"_id":"source/_posts/2017-07-06-Shell 脚本入门.md","hash":"8ad9ce949220a8080104130ef5bcabdec95a519a","modified":1502021753000},{"_id":"source/_posts/JavaScript：Array类型小结（1）.md","hash":"f52814eaa6d53a248b581c0b3501a2a9059c1948","modified":1502021519000},{"_id":"source/_posts/JavaScript：Array类型小结（2）.md","hash":"6e0006acce8c7ef4812be48d330e515c2027fbc6","modified":1502021450000},{"_id":"source/_posts/奇怪的JavaScript（1）.md","hash":"f923bcfd04bc4c4ed61e07d02929a18262984376","modified":1502021759000},{"_id":"themes/landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1501174069000},{"_id":"themes/landscape/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1501174069000},{"_id":"themes/landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1501174069000},{"_id":"themes/landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1501174069000},{"_id":"themes/landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1501174069000},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1501174069000},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1501174069000},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1501174069000},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1501174069000},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1501174069000},{"_id":"themes/landscape/layout/layout.ejs","hash":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1501174069000},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1501174069000},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1501174069000},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1501174069000},{"_id":"themes/landscape/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1501174069000},{"_id":"themes/landscape/source/.DS_Store","hash":"a3dadf56b39eafe453d7d70289747fcaceaef67e","modified":1501593844000},{"_id":"source/images/FE-Hybrid-interaction.png","hash":"3cb09a129f16a5f53cb5194c155f8895336eee7c","modified":1495556132000},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"82a30f81c0e8ba4a8af17acd6cc99e93834e4d5e","modified":1501174069000},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1501174069000},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"f7e102eebf4f6ec8da829dce16b33a0f1789fe12","modified":1501427869000},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"c99d362dcc5f367a0b21291a7714d2528edb9a21","modified":1501427998000},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"93518893cf91287e797ebac543c560e2a63b8d0e","modified":1501174069000},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1501174069000},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"4fe8853e864d192701c03e5cd3a5390287b90612","modified":1501174069000},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"ded70f83c4aca62c321a3a0cde9f6f3020083d7e","modified":1501427634000},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1501174069000},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1501174069000},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1501174069000},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1501174069000},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1501174069000},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1501174069000},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1501174069000},{"_id":"themes/landscape/source/css/.DS_Store","hash":"4a717856e2237c5aae4d703815f8bbb8ac04bf2f","modified":1501593974000},{"_id":"themes/landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1501174069000},{"_id":"themes/landscape/source/css/_variables.styl","hash":"66ee1496c7db3da54c1daa7da288c54f65ed664e","modified":1501594278000},{"_id":"themes/landscape/source/css/style.styl","hash":"a70d9c44dac348d742702f6ba87e5bb3084d65db","modified":1501174069000},{"_id":"themes/landscape/source/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1501174069000},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1501174069000},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1501174069000},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1501174069000},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1501174069000},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1501174069000},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1501174069000},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1501174069000},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1501174069000},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1501174069000},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1501174069000},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1501174069000},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1501174069000},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1501174069000},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1501174069000},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1501174069000},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1501174069000},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"10685f8787a79f79c9a26c2f943253450c498e3e","modified":1501174069000},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1501174069000},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1501174069000},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"32a5d50a0f55fa62460c365c7b17a63ee03e039b","modified":1501424309000},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1501174069000},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1501174069000},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1501174069000},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1501174069000},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1501174069000},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1501174069000},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1501174069000},{"_id":"themes/landscape/source/css/images/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1501420653000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1501174069000},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1501174069000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1501174069000},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1501174069000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1501174069000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1501174069000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1501174069000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1501174069000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1501174069000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1501174069000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1501174069000},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"0da5aa5c379ae626c7ad34b0b20e7d7822e5494a","modified":1501419839000},{"_id":"public/2017/08/04/奇怪的JavaScript（1）/index.html","hash":"9e70ba9aa52e21e5d33b58be28f81467049ed660","modified":1502021818351},{"_id":"public/2017/07/05/2017-07-05-CSS：什么是 BFC/index.html","hash":"1f12762883f063f90a69526b0e6f36641f624b88","modified":1502021818366},{"_id":"public/2017/06/21/2017-06-21-CSS：Animation 动画/index.html","hash":"067a26fb732c444ea6e825d3d08252e82cd38a63","modified":1502021818368},{"_id":"public/2017/06/01/2017-06-01-CSS：table-cell 用法小/index.html","hash":"5c4aa3585c36a88d2f4f34c848b595edff430191","modified":1502021818368},{"_id":"public/2017/05/28/2017-05-28-JavaScript：Promise 小记/index.html","hash":"ffcff15ee9303409bbc68b8a79610f572d8c868d","modified":1502021818369},{"_id":"public/2017/05/23/2017-05-23-什么是Hybrid App/index.html","hash":"d98773f498b86d06eb2d518648313e5cd0b062bf","modified":1502021818372},{"_id":"public/2017/05/19/2017-05-19-JSON：JSON 方法小记/index.html","hash":"456979ff28a3c4ddb49e66838bdb4dd39951941e","modified":1502021818372},{"_id":"public/2017/05/08/2017-05-08-JavaScript：逻辑与 与 逻辑或/index.html","hash":"21cd919635855bf94c0efa7dbdc2d951602b181c","modified":1502021818369},{"_id":"public/2017/04/26/2017-04-26-jQuery：事件监听用法/index.html","hash":"5ad15ba72c4c73dd939093ce6f9140851f919e8d","modified":1502021818369},{"_id":"public/2017/04/26/2017-04-26-jQuery：基础 DOM 操作方法/index.html","hash":"d83b49fea0add7ae02d4ee070c7c9f864979c631","modified":1502021818372},{"_id":"public/2017/04/24/2017-04-24-前端：跨域方法小记/index.html","hash":"f579cf944c048817a3bc188b9435fbc8b003248a","modified":1502021818369},{"_id":"public/2017/04/14/2017-04-14-React：基本环境搭建简明步骤/index.html","hash":"066d0afa9222bcaf7d7cde1de3d86bd43324be4c","modified":1502021818369},{"_id":"public/2017/04/07/2017-04-07-Mac在Terminal打开Finder/index.html","hash":"4777abd1fe20f90d9053fe8e8c3da85a5491684f","modified":1502021818370},{"_id":"public/2017/04/02/2017-04-02-CSS：line-height 不同取值的差异/index.html","hash":"d3671e1d69ae255201e29be6abe797510e08a83f","modified":1502021818370},{"_id":"public/2017/04/02/2017-04-02-Sublime-Text-3的基本安装与配置/index.html","hash":"a678fdc72e510385bb02636604ee09f568d559e8","modified":1502021818370},{"_id":"public/2017/04/01/2017-04-01-CSS：如何去除 inline-block 带来的空白间距/index.html","hash":"2cce2dd9b8236a26b11ee74609d1e86c4b1c57a1","modified":1502021818370},{"_id":"public/2016/03/04/2016-03-04-SVN：同步版本库与网站目录/index.html","hash":"06184b6ab176346a0355a8c0c459c82a9846377d","modified":1502021818370},{"_id":"public/2016/03/04/2016-03-04-SVN：LNMP下搭建SVN服务器简明步骤/index.html","hash":"950579e32ee5f15bf5c2a164a7037463beee0d07","modified":1502021818370},{"_id":"public/archives/index.html","hash":"0324c318d36ee5d8de60a71cab0a55378a6949c6","modified":1502021818370},{"_id":"public/archives/page/2/index.html","hash":"a8a015d3adb6474d260cc579a7b597631af0077d","modified":1502021818370},{"_id":"public/archives/page/3/index.html","hash":"564aaf9d303aa6e83393b1427bbd68c1c2d072de","modified":1502021818371},{"_id":"public/archives/2016/index.html","hash":"cae6a6d91d9225169b8456f6712d39b9f3fb436f","modified":1502021818371},{"_id":"public/archives/2016/03/index.html","hash":"8ac8c417599a3938d8a7cb6d432967e9022f8c9f","modified":1502021818371},{"_id":"public/archives/2016/04/index.html","hash":"a47ba38585d93f9ced14b538921732813764bddd","modified":1502021818371},{"_id":"public/archives/2017/index.html","hash":"6dec2b980312ea19f86b9c82321ebd6ceae4b30f","modified":1502021818371},{"_id":"public/archives/2017/page/2/index.html","hash":"b5e4cbca1de4a8ae1b193424ca122cc3f22d2ad7","modified":1502021818371},{"_id":"public/archives/2017/page/3/index.html","hash":"acc41ceabf40c46c739f0990f68d782aadff17e0","modified":1502021818371},{"_id":"public/archives/2017/01/index.html","hash":"3cab4a242ece2b856393f86559b32cbf4e51d2ae","modified":1502021818371},{"_id":"public/archives/2017/04/index.html","hash":"6c767d33c70821eee7b91d8e6a42be95942b5de8","modified":1502021818371},{"_id":"public/archives/2017/04/page/2/index.html","hash":"f3597df28428f9b0c98da31739b5ace119866bf4","modified":1502021818371},{"_id":"public/archives/2017/05/index.html","hash":"cd117077eff71f0dfed3135eb172d349b5f0d4b3","modified":1502021818372},{"_id":"public/archives/2017/06/index.html","hash":"1e238ed9461a7f0c8be259c2bc86a0ba2a0460d7","modified":1502021818372},{"_id":"public/archives/2017/07/index.html","hash":"49c0d2bbbdc3c833c3678645393a14c95c9ca953","modified":1502021818372},{"_id":"public/archives/2017/08/index.html","hash":"77ae2911ba4a0ac527f36647253b1c922fb5a6a5","modified":1502021818372},{"_id":"public/categories/svn/index.html","hash":"a46e7516ccbbd4ea32dd0321df39b3327e697818","modified":1502021534979},{"_id":"public/categories/react/index.html","hash":"f778ba99af2199313c6765aa49371e8e149b0890","modified":1502021534979},{"_id":"public/categories/git/index.html","hash":"4936239c87f2a7cb4b070086a21e9e692dcf4e2e","modified":1502021534979},{"_id":"public/categories/css/index.html","hash":"875801d54583bd050a4a6066fdf8528df37a0cd9","modified":1502021534979},{"_id":"public/categories/sublime/index.html","hash":"12dc8b9ef1a529dff8f8ae7f8386463428fde95b","modified":1502021534979},{"_id":"public/categories/mac/index.html","hash":"43ae15f24620002e115e0bcfdee0473fa1928d5c","modified":1502021534980},{"_id":"public/categories/http/index.html","hash":"386577453d21c3463a0cde3d70e39c960c772b64","modified":1502021534980},{"_id":"public/categories/javascript/index.html","hash":"ff1a730d232d30ffc5f3a729528ac5f54d8f12b1","modified":1502021818370},{"_id":"public/categories/fe/index.html","hash":"2377f238e274e59347e0cbbeb5defcd40d208f5f","modified":1502021534980},{"_id":"public/categories/jquery/index.html","hash":"3e278d2a59100550add6f7cf25a5c615c3527d02","modified":1502021534980},{"_id":"public/categories/vue/index.html","hash":"65864f2631bb35da4dcb80ced263f9cb4c36c971","modified":1502021534980},{"_id":"public/categories/shell/index.html","hash":"a928009d1f63ad390e22f55f6f3509449e9726c3","modified":1502021534980},{"_id":"public/2017/07/06/2017-07-06-Shell 脚本入门/index.html","hash":"77a3302a86541e7bd5e15333a5adf40a6afac9b6","modified":1502021818372},{"_id":"public/2017/06/21/2017-06-21-Vue：基础用法与指令/index.html","hash":"00615cf436bf16a4e244327fd8467514fa49b46d","modified":1502021818372},{"_id":"public/2017/05/03/2017-05-03-JavaScript：从代码复用到面向对象/index.html","hash":"f264be4f69f632f48e7c8268aee5a4464c3ee7b9","modified":1502021818372},{"_id":"public/2017/04/27/2017-04-27-JavaScript：作用域、闭包 和 this/index.html","hash":"0a7a4c1264375446692fcde583303077948f2652","modified":1502021818372},{"_id":"public/2017/04/12/2017-04-12-HTTP：常见的状态码/index.html","hash":"2ac27359a7a9c7e45ee92319c46c1654bf2dfe1d","modified":1502021818372},{"_id":"public/2017/04/11/2017-04-11-HTTP：协议基础/index.html","hash":"b8eb889bf421f7f6a282e0ba273b6ac29364f113","modified":1502021818372},{"_id":"public/2017/04/11/2017-04-11-JavaScript：基本数据类型整理/index.html","hash":"69a6d14cf0d126e0242866e6b05ef42f2eafb139","modified":1502021818372},{"_id":"public/2017/04/01/2017-04-01-CSS：那些居中的方法们/index.html","hash":"b79b135e948a48db99ee17a277e9000249d5faeb","modified":1502021818372},{"_id":"public/2017/01/30/2017-01-03-Git：常用命令整理/index.html","hash":"3ddea09d9a113564f106a1bc32390a524e8b1c9a","modified":1502021818372},{"_id":"public/2016/04/24/2016-04-24-深入浅出React读后笔记/index.html","hash":"81fa0432e223296b77fab83ded400c2b3e091829","modified":1502021818372},{"_id":"public/index.html","hash":"a5d04e145435107dba00e9f0eb3db185031db25c","modified":1502021818372},{"_id":"public/page/2/index.html","hash":"cec2ed56797a8e9fb6a66eeb9f53bd68f0e6edb2","modified":1502021818372},{"_id":"public/page/3/index.html","hash":"6a8c33977db9ff23925a4364579441a725dccaf5","modified":1502021818372},{"_id":"public/2017/08/06/JavaScript：Array类型小结（2）/index.html","hash":"9ade7ddff67205268a7517a341fb73db1ab6be7c","modified":1502021818372},{"_id":"public/2017/08/06/JavaScript：Array类型小结（1）/index.html","hash":"803837f51e128318237c742662f94eef6ea1569c","modified":1502021818372},{"_id":"public/tags/javascript/index.html","hash":"4cf7c08962d867c1ca732275ab56b1e1abd81c3c","modified":1502021818370},{"_id":"public/tags/svn/index.html","hash":"5525862ff560adff209da80d0875dcb8229a895b","modified":1502021818377},{"_id":"public/tags/react/index.html","hash":"7a6d4665849b62d5475506e1ccf4873ea6145df0","modified":1502021818377},{"_id":"public/tags/git/index.html","hash":"7fe67b8775408be5d640c4d6f03637fa19eb2183","modified":1502021818377},{"_id":"public/tags/css/index.html","hash":"4852dcef4382454b8704d9c9b4fd71e5b6f09fab","modified":1502021818377},{"_id":"public/tags/sublime/index.html","hash":"0ddc8371b1d53291fc42216f66f893f037585e17","modified":1502021818377},{"_id":"public/tags/mac/index.html","hash":"6727fd5592d3bc6f085e9f4fa9dd4df0a9372f9e","modified":1502021818378},{"_id":"public/tags/http/index.html","hash":"ef334d9970756b1fcc20fb84f86363b9447b125b","modified":1502021818378},{"_id":"public/tags/fe/index.html","hash":"d61637ffed7ad587230187195eda494cf51b18a8","modified":1502021818378},{"_id":"public/tags/jquery/index.html","hash":"a6e22883fb1b13c6b7eb3cab438d44e8c1ff4461","modified":1502021818378},{"_id":"public/tags/vue/index.html","hash":"5d00d9f69d6baf29112d3ad13e4d5fe037a51c34","modified":1502021818378},{"_id":"public/tags/shell/index.html","hash":"3fb101c3812550046ef15c97ed905924de2c1bca","modified":1502021818378}],"Category":[{"name":"svn","_id":"cj60bzxkd00021dorzsqwhtv6"},{"name":"react","_id":"cj60bzxkm000a1dorh6fjo54l"},{"name":"git","_id":"cj60bzxkp000e1dorl8oerl9v"},{"name":"css","_id":"cj60bzxks000i1dorc1f9kwbv"},{"name":"sublime","_id":"cj60bzxl2000v1dorgle7hanl"},{"name":"mac","_id":"cj60bzxl400101dordvy764ux"},{"name":"http","_id":"cj60bzxl900141dorimj8f5ef"},{"name":"javascript","_id":"cj60bzxlc001c1dorioezt843"},{"name":"fe","_id":"cj60bzxlg001i1dor20n9gyu9"},{"name":"jquery","_id":"cj60bzxli001o1dork9m78qi9"},{"name":"vue","_id":"cj60bzxls00251dorzykjj6ad"},{"name":"shell","_id":"cj60bzxls00271dortd8pkxzx"}],"Data":[],"Page":[],"Post":[{"layout":"post","title":"SVN：LNMP下搭建SVN服务器简明步骤","date":"2016-03-04T06:47:11.000Z","_content":"下文中PATH、PROJECT等全大写的字符串均为举例用，实际操作时请替换成自己的目录和版本库或项目名称等。\n## 安装\n\n    yum install subversion\n\n等待一段时间完成svn的安装。\n\n##建立版本库的文件夹，并给与777的权限\n\n    mkdir PATH/svn\n    chmod 777 -R PATH/svn\n    \n## 创建版本库\n\n    svnadmin create PATH/svn/PROJECT\n\n## 接下来对Svn进行配置\n### 配置svnserve.conf\n\n    vi PATH/svn/PROJECT/conf/svnserve.conf\n\n将内容中注释掉的以下部分去掉#和空格，并将anon-access = read改为none：\n\n\n     # anon-access = read\n     # auth-access = write\n     # password-db = passwd\n     # authz-db = authz\n\n变成\n\n     anon-access = none\n     auth-access = write\n     password-db = passwd\n     authz-db = authz\n\n### 配置authz\n    vi PATH/svn/PROJECT/conf/authz\n\n　　在[group]下加入\n\n    YOUR_GROUP = USER1,USER2\n\n　　在# [/foo/bar]下加入\n\n    [/]\n    @YOUR_GROUP=rw\n    * = r\n\n### 配置passwd\n    vi PATH/svn/PROJECT/conf/passwd\n\n　　在[users]下加入\n\n    USER1=PASSWD1\n    USER2=PASSWD2\n\n## 启动SVN服务\n\n    svnserve -d -r PATH/svn/\n\n这里需要注意，这里设置的是svn服务器的根目录。在checkout的时候，以这个目录（PATH/svn/)作为起点，可以添加多个版本库，访问的时候则可以用“svn://域名/版本库名”来进行checkout。\n\n### 如何关闭服务\n　　直接杀死相关进程即可\n   \n\n     killall svnserve\n    \n## 客户端访问方式\n\n    svn checkout svn://domain/project\n\n## 可能出现的问题\n### CentOS7下客户端无法访问\n\n这是因为在CentOS7下，原先的iptables被替换了firewalld，所以对iptables的防火墙设置是没有用的。\n\n因此如果想要让3690端口（SVN服务器端口）对外开放的话，则需要对firewalld进行配置。\n\n    firewall-cmd --permanent --query-port=3690/tcp\n\n通过上述命令可以查看3690端口是否开放。\n\n    irewall-cmd --permanent --add-port=3690/tcp\n\n通过上述命令则可以添加开放端口。","source":"_posts/2016-03-04-SVN：LNMP下搭建SVN服务器简明步骤.markdown","raw":"---\nlayout: post\ntitle:  \"SVN：LNMP下搭建SVN服务器简明步骤\"\ndate:   2016-03-04 14:47:11 +0800\ntags: svn\n---\n下文中PATH、PROJECT等全大写的字符串均为举例用，实际操作时请替换成自己的目录和版本库或项目名称等。\n## 安装\n\n    yum install subversion\n\n等待一段时间完成svn的安装。\n\n##建立版本库的文件夹，并给与777的权限\n\n    mkdir PATH/svn\n    chmod 777 -R PATH/svn\n    \n## 创建版本库\n\n    svnadmin create PATH/svn/PROJECT\n\n## 接下来对Svn进行配置\n### 配置svnserve.conf\n\n    vi PATH/svn/PROJECT/conf/svnserve.conf\n\n将内容中注释掉的以下部分去掉#和空格，并将anon-access = read改为none：\n\n\n     # anon-access = read\n     # auth-access = write\n     # password-db = passwd\n     # authz-db = authz\n\n变成\n\n     anon-access = none\n     auth-access = write\n     password-db = passwd\n     authz-db = authz\n\n### 配置authz\n    vi PATH/svn/PROJECT/conf/authz\n\n　　在[group]下加入\n\n    YOUR_GROUP = USER1,USER2\n\n　　在# [/foo/bar]下加入\n\n    [/]\n    @YOUR_GROUP=rw\n    * = r\n\n### 配置passwd\n    vi PATH/svn/PROJECT/conf/passwd\n\n　　在[users]下加入\n\n    USER1=PASSWD1\n    USER2=PASSWD2\n\n## 启动SVN服务\n\n    svnserve -d -r PATH/svn/\n\n这里需要注意，这里设置的是svn服务器的根目录。在checkout的时候，以这个目录（PATH/svn/)作为起点，可以添加多个版本库，访问的时候则可以用“svn://域名/版本库名”来进行checkout。\n\n### 如何关闭服务\n　　直接杀死相关进程即可\n   \n\n     killall svnserve\n    \n## 客户端访问方式\n\n    svn checkout svn://domain/project\n\n## 可能出现的问题\n### CentOS7下客户端无法访问\n\n这是因为在CentOS7下，原先的iptables被替换了firewalld，所以对iptables的防火墙设置是没有用的。\n\n因此如果想要让3690端口（SVN服务器端口）对外开放的话，则需要对firewalld进行配置。\n\n    firewall-cmd --permanent --query-port=3690/tcp\n\n通过上述命令可以查看3690端口是否开放。\n\n    irewall-cmd --permanent --add-port=3690/tcp\n\n通过上述命令则可以添加开放端口。","slug":"2016-03-04-SVN：LNMP下搭建SVN服务器简明步骤","published":1,"updated":"2017-08-06T12:14:24.000Z","_id":"cj60bzxk600001dorj89n6wm7","comments":1,"photos":[],"link":"","content":"<p>下文中PATH、PROJECT等全大写的字符串均为举例用，实际操作时请替换成自己的目录和版本库或项目名称等。</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><pre><code>yum install subversion\n</code></pre><p>等待一段时间完成svn的安装。</p>\n<p>##建立版本库的文件夹，并给与777的权限</p>\n<pre><code>mkdir PATH/svn\nchmod 777 -R PATH/svn\n</code></pre><h2 id=\"创建版本库\"><a href=\"#创建版本库\" class=\"headerlink\" title=\"创建版本库\"></a>创建版本库</h2><pre><code>svnadmin create PATH/svn/PROJECT\n</code></pre><h2 id=\"接下来对Svn进行配置\"><a href=\"#接下来对Svn进行配置\" class=\"headerlink\" title=\"接下来对Svn进行配置\"></a>接下来对Svn进行配置</h2><h3 id=\"配置svnserve-conf\"><a href=\"#配置svnserve-conf\" class=\"headerlink\" title=\"配置svnserve.conf\"></a>配置svnserve.conf</h3><pre><code>vi PATH/svn/PROJECT/conf/svnserve.conf\n</code></pre><p>将内容中注释掉的以下部分去掉#和空格，并将anon-access = read改为none：</p>\n<pre><code># anon-access = read\n# auth-access = write\n# password-db = passwd\n# authz-db = authz\n</code></pre><p>变成</p>\n<pre><code>anon-access = none\nauth-access = write\npassword-db = passwd\nauthz-db = authz\n</code></pre><h3 id=\"配置authz\"><a href=\"#配置authz\" class=\"headerlink\" title=\"配置authz\"></a>配置authz</h3><pre><code>vi PATH/svn/PROJECT/conf/authz\n</code></pre><p>　　在[group]下加入</p>\n<pre><code>YOUR_GROUP = USER1,USER2\n</code></pre><p>　　在# [/foo/bar]下加入</p>\n<pre><code>[/]\n@YOUR_GROUP=rw\n* = r\n</code></pre><h3 id=\"配置passwd\"><a href=\"#配置passwd\" class=\"headerlink\" title=\"配置passwd\"></a>配置passwd</h3><pre><code>vi PATH/svn/PROJECT/conf/passwd\n</code></pre><p>　　在[users]下加入</p>\n<pre><code>USER1=PASSWD1\nUSER2=PASSWD2\n</code></pre><h2 id=\"启动SVN服务\"><a href=\"#启动SVN服务\" class=\"headerlink\" title=\"启动SVN服务\"></a>启动SVN服务</h2><pre><code>svnserve -d -r PATH/svn/\n</code></pre><p>这里需要注意，这里设置的是svn服务器的根目录。在checkout的时候，以这个目录（PATH/svn/)作为起点，可以添加多个版本库，访问的时候则可以用“svn://域名/版本库名”来进行checkout。</p>\n<h3 id=\"如何关闭服务\"><a href=\"#如何关闭服务\" class=\"headerlink\" title=\"如何关闭服务\"></a>如何关闭服务</h3><p>　　直接杀死相关进程即可</p>\n<pre><code>killall svnserve\n</code></pre><h2 id=\"客户端访问方式\"><a href=\"#客户端访问方式\" class=\"headerlink\" title=\"客户端访问方式\"></a>客户端访问方式</h2><pre><code>svn checkout svn://domain/project\n</code></pre><h2 id=\"可能出现的问题\"><a href=\"#可能出现的问题\" class=\"headerlink\" title=\"可能出现的问题\"></a>可能出现的问题</h2><h3 id=\"CentOS7下客户端无法访问\"><a href=\"#CentOS7下客户端无法访问\" class=\"headerlink\" title=\"CentOS7下客户端无法访问\"></a>CentOS7下客户端无法访问</h3><p>这是因为在CentOS7下，原先的iptables被替换了firewalld，所以对iptables的防火墙设置是没有用的。</p>\n<p>因此如果想要让3690端口（SVN服务器端口）对外开放的话，则需要对firewalld进行配置。</p>\n<pre><code>firewall-cmd --permanent --query-port=3690/tcp\n</code></pre><p>通过上述命令可以查看3690端口是否开放。</p>\n<pre><code>irewall-cmd --permanent --add-port=3690/tcp\n</code></pre><p>通过上述命令则可以添加开放端口。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>下文中PATH、PROJECT等全大写的字符串均为举例用，实际操作时请替换成自己的目录和版本库或项目名称等。</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><pre><code>yum install subversion\n</code></pre><p>等待一段时间完成svn的安装。</p>\n<p>##建立版本库的文件夹，并给与777的权限</p>\n<pre><code>mkdir PATH/svn\nchmod 777 -R PATH/svn\n</code></pre><h2 id=\"创建版本库\"><a href=\"#创建版本库\" class=\"headerlink\" title=\"创建版本库\"></a>创建版本库</h2><pre><code>svnadmin create PATH/svn/PROJECT\n</code></pre><h2 id=\"接下来对Svn进行配置\"><a href=\"#接下来对Svn进行配置\" class=\"headerlink\" title=\"接下来对Svn进行配置\"></a>接下来对Svn进行配置</h2><h3 id=\"配置svnserve-conf\"><a href=\"#配置svnserve-conf\" class=\"headerlink\" title=\"配置svnserve.conf\"></a>配置svnserve.conf</h3><pre><code>vi PATH/svn/PROJECT/conf/svnserve.conf\n</code></pre><p>将内容中注释掉的以下部分去掉#和空格，并将anon-access = read改为none：</p>\n<pre><code># anon-access = read\n# auth-access = write\n# password-db = passwd\n# authz-db = authz\n</code></pre><p>变成</p>\n<pre><code>anon-access = none\nauth-access = write\npassword-db = passwd\nauthz-db = authz\n</code></pre><h3 id=\"配置authz\"><a href=\"#配置authz\" class=\"headerlink\" title=\"配置authz\"></a>配置authz</h3><pre><code>vi PATH/svn/PROJECT/conf/authz\n</code></pre><p>　　在[group]下加入</p>\n<pre><code>YOUR_GROUP = USER1,USER2\n</code></pre><p>　　在# [/foo/bar]下加入</p>\n<pre><code>[/]\n@YOUR_GROUP=rw\n* = r\n</code></pre><h3 id=\"配置passwd\"><a href=\"#配置passwd\" class=\"headerlink\" title=\"配置passwd\"></a>配置passwd</h3><pre><code>vi PATH/svn/PROJECT/conf/passwd\n</code></pre><p>　　在[users]下加入</p>\n<pre><code>USER1=PASSWD1\nUSER2=PASSWD2\n</code></pre><h2 id=\"启动SVN服务\"><a href=\"#启动SVN服务\" class=\"headerlink\" title=\"启动SVN服务\"></a>启动SVN服务</h2><pre><code>svnserve -d -r PATH/svn/\n</code></pre><p>这里需要注意，这里设置的是svn服务器的根目录。在checkout的时候，以这个目录（PATH/svn/)作为起点，可以添加多个版本库，访问的时候则可以用“svn://域名/版本库名”来进行checkout。</p>\n<h3 id=\"如何关闭服务\"><a href=\"#如何关闭服务\" class=\"headerlink\" title=\"如何关闭服务\"></a>如何关闭服务</h3><p>　　直接杀死相关进程即可</p>\n<pre><code>killall svnserve\n</code></pre><h2 id=\"客户端访问方式\"><a href=\"#客户端访问方式\" class=\"headerlink\" title=\"客户端访问方式\"></a>客户端访问方式</h2><pre><code>svn checkout svn://domain/project\n</code></pre><h2 id=\"可能出现的问题\"><a href=\"#可能出现的问题\" class=\"headerlink\" title=\"可能出现的问题\"></a>可能出现的问题</h2><h3 id=\"CentOS7下客户端无法访问\"><a href=\"#CentOS7下客户端无法访问\" class=\"headerlink\" title=\"CentOS7下客户端无法访问\"></a>CentOS7下客户端无法访问</h3><p>这是因为在CentOS7下，原先的iptables被替换了firewalld，所以对iptables的防火墙设置是没有用的。</p>\n<p>因此如果想要让3690端口（SVN服务器端口）对外开放的话，则需要对firewalld进行配置。</p>\n<pre><code>firewall-cmd --permanent --query-port=3690/tcp\n</code></pre><p>通过上述命令可以查看3690端口是否开放。</p>\n<pre><code>irewall-cmd --permanent --add-port=3690/tcp\n</code></pre><p>通过上述命令则可以添加开放端口。</p>\n"},{"layout":"post","title":"SVN：同步版本库与网站目录","date":"2016-03-04T15:10:15.000Z","_content":"\n承接之前[Lnmp下搭建Svn服务器]({% post_url 2016-03-04-SVN：LNMP下搭建SVN服务器简明步骤 %})的步骤，接下来要使用Svn中的hooks来进行版本库与网站目录的同步更新。以方便对网站代码进行管理和发布。\n\n注意，下文中PATH、PROJECT等全大写的字符串均为举例用，实际操作时请替换成自己的目录和版本库或项目名称。\n\n## 原理\n\n首先切换到版本库的目录\n\n    cd /PATH/svn/PROJECT\n    ls\n\n会看到有hooks文件夹\n\n    cd hooks\n    ls\n\n可以看到有一个post-commit.tmpl，这个是svn官方的一个模板，在每次commit操作之后都会执行这个脚本，其他的hooks同理。\n\n看到这里你应该可以想到，版本库与网站目录同步的原理，就是在客户端commit了代码之后，执行这个脚本来同时update网站目录的内容，保证两者的同步。\n\n## 配置操作\n\n### 首先需要在网站目录checkout版本库\n\n先不要着急打接下来的命令\n\n    cd PATH/wwwroot/www.example.com\n    svn checkout file://PATH/svn/PROJECT\n    \n因为执行了这个命令之后你也许会发现，在网站目录下多了一个PROJECT文件夹，这个文件夹里面才是版本库控制的内容。\n\n然而我们的目的是想让当前网站的根目录与svn直接同步，因此我们在上一级目录进行checkout。\n\n接下来正确的做法是\n\n    cd PATH/wwwroot\n    svn checkout file://PATH/svn/PROJECT www.example.com\n\n上述命令是在checkout版本库的同时对它进行了重命名，这样子，网站的根目录就如预想的一样在版本库的控制之下了。\n\n### 接下来配置hooks\n\n    cd PATH/svn/PROJECT/hooks\n    cp post-commit.tmpl post-commit\n\n复制一份post-commit并去掉它的后缀名，这么做的原因是，.tmpl是一个模板文件，实际并不会执行，只有去掉后缀名之后它才会生效。\n\n    vi post-commit\n\n在末尾加入\n\n    export LANG=zh_CN.UTF-8\n    svn update PATH/wwwroot/www.example.com --username USER1 --password PASSWD1 --no-auth-cache\n\nexport的作用是防止乱码。\n\nupdate则是对网站目录进行更新，让网站目录与版本库同步，这里USER1和PASSWD1是之前的教程里配置的用户名和密码，请根据实际情况进行替换。\n编辑完成之后，按ESC并输入:wq，保存并退出。\n\n### 测试hooks\n#### 添加可执行权限\n\n    chmod +x post-commit\n\n#### 运行测试\n\n    ./post-commit\n    \n　　如果有报错，请重新vi一遍看看是不是有打错\n\n#### 切换用户进行测试\n\n由于ssh VPS之后大多数情况用的都是root用户，而svn commit之后执行hooks的是另外一个用户，所以在root权限下执行没有问题，在另外的用户下可能就没有那么足够的权限了。所以接下来\n\n    su www\n    ./post-commit\n\n如果执行成功，那么基本不会有问题。\n如果su www时出现not available的情况，尝试下面这个命令\n\n    usermod -s /bin/bash www\n\n　　如果出现各种权限不足的情况，我建议上述所有步骤都在www用户下执行（除了部分更改文件执行权限操作等必须用root用户的）。\n\n### 实际测试\n\n使用你的svn客户端checkout该版本库并上传一些文件或做一些改动，接着进行commit，查看网站目录是否与版本库同步。\n\n## 总结\n\nSvn的hooks是非常好用的脚本，在每次commit之后，你也可以加入日志记录、通知提醒等等功能。当然，这些功能也是需要一定的shell能力才写的出来。\n","source":"_posts/2016-03-04-SVN：同步版本库与网站目录.markdown","raw":"---\nlayout: post\ntitle:  \"SVN：同步版本库与网站目录\"\ndate:   2016-03-04 23:10:15 +0800\ntags: svn\n---\n\n承接之前[Lnmp下搭建Svn服务器]({% post_url 2016-03-04-SVN：LNMP下搭建SVN服务器简明步骤 %})的步骤，接下来要使用Svn中的hooks来进行版本库与网站目录的同步更新。以方便对网站代码进行管理和发布。\n\n注意，下文中PATH、PROJECT等全大写的字符串均为举例用，实际操作时请替换成自己的目录和版本库或项目名称。\n\n## 原理\n\n首先切换到版本库的目录\n\n    cd /PATH/svn/PROJECT\n    ls\n\n会看到有hooks文件夹\n\n    cd hooks\n    ls\n\n可以看到有一个post-commit.tmpl，这个是svn官方的一个模板，在每次commit操作之后都会执行这个脚本，其他的hooks同理。\n\n看到这里你应该可以想到，版本库与网站目录同步的原理，就是在客户端commit了代码之后，执行这个脚本来同时update网站目录的内容，保证两者的同步。\n\n## 配置操作\n\n### 首先需要在网站目录checkout版本库\n\n先不要着急打接下来的命令\n\n    cd PATH/wwwroot/www.example.com\n    svn checkout file://PATH/svn/PROJECT\n    \n因为执行了这个命令之后你也许会发现，在网站目录下多了一个PROJECT文件夹，这个文件夹里面才是版本库控制的内容。\n\n然而我们的目的是想让当前网站的根目录与svn直接同步，因此我们在上一级目录进行checkout。\n\n接下来正确的做法是\n\n    cd PATH/wwwroot\n    svn checkout file://PATH/svn/PROJECT www.example.com\n\n上述命令是在checkout版本库的同时对它进行了重命名，这样子，网站的根目录就如预想的一样在版本库的控制之下了。\n\n### 接下来配置hooks\n\n    cd PATH/svn/PROJECT/hooks\n    cp post-commit.tmpl post-commit\n\n复制一份post-commit并去掉它的后缀名，这么做的原因是，.tmpl是一个模板文件，实际并不会执行，只有去掉后缀名之后它才会生效。\n\n    vi post-commit\n\n在末尾加入\n\n    export LANG=zh_CN.UTF-8\n    svn update PATH/wwwroot/www.example.com --username USER1 --password PASSWD1 --no-auth-cache\n\nexport的作用是防止乱码。\n\nupdate则是对网站目录进行更新，让网站目录与版本库同步，这里USER1和PASSWD1是之前的教程里配置的用户名和密码，请根据实际情况进行替换。\n编辑完成之后，按ESC并输入:wq，保存并退出。\n\n### 测试hooks\n#### 添加可执行权限\n\n    chmod +x post-commit\n\n#### 运行测试\n\n    ./post-commit\n    \n　　如果有报错，请重新vi一遍看看是不是有打错\n\n#### 切换用户进行测试\n\n由于ssh VPS之后大多数情况用的都是root用户，而svn commit之后执行hooks的是另外一个用户，所以在root权限下执行没有问题，在另外的用户下可能就没有那么足够的权限了。所以接下来\n\n    su www\n    ./post-commit\n\n如果执行成功，那么基本不会有问题。\n如果su www时出现not available的情况，尝试下面这个命令\n\n    usermod -s /bin/bash www\n\n　　如果出现各种权限不足的情况，我建议上述所有步骤都在www用户下执行（除了部分更改文件执行权限操作等必须用root用户的）。\n\n### 实际测试\n\n使用你的svn客户端checkout该版本库并上传一些文件或做一些改动，接着进行commit，查看网站目录是否与版本库同步。\n\n## 总结\n\nSvn的hooks是非常好用的脚本，在每次commit之后，你也可以加入日志记录、通知提醒等等功能。当然，这些功能也是需要一定的shell能力才写的出来。\n","slug":"2016-03-04-SVN：同步版本库与网站目录","published":1,"updated":"2017-08-06T12:14:18.000Z","_id":"cj60bzxkb00011dora9q1u9wb","comments":1,"photos":[],"link":"","content":"<p>承接之前<a href=\"!--￼0--\">Lnmp下搭建Svn服务器</a>的步骤，接下来要使用Svn中的hooks来进行版本库与网站目录的同步更新。以方便对网站代码进行管理和发布。</p>\n<p>注意，下文中PATH、PROJECT等全大写的字符串均为举例用，实际操作时请替换成自己的目录和版本库或项目名称。</p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>首先切换到版本库的目录</p>\n<pre><code>cd /PATH/svn/PROJECT\nls\n</code></pre><p>会看到有hooks文件夹</p>\n<pre><code>cd hooks\nls\n</code></pre><p>可以看到有一个post-commit.tmpl，这个是svn官方的一个模板，在每次commit操作之后都会执行这个脚本，其他的hooks同理。</p>\n<p>看到这里你应该可以想到，版本库与网站目录同步的原理，就是在客户端commit了代码之后，执行这个脚本来同时update网站目录的内容，保证两者的同步。</p>\n<h2 id=\"配置操作\"><a href=\"#配置操作\" class=\"headerlink\" title=\"配置操作\"></a>配置操作</h2><h3 id=\"首先需要在网站目录checkout版本库\"><a href=\"#首先需要在网站目录checkout版本库\" class=\"headerlink\" title=\"首先需要在网站目录checkout版本库\"></a>首先需要在网站目录checkout版本库</h3><p>先不要着急打接下来的命令</p>\n<pre><code>cd PATH/wwwroot/www.example.com\nsvn checkout file://PATH/svn/PROJECT\n</code></pre><p>因为执行了这个命令之后你也许会发现，在网站目录下多了一个PROJECT文件夹，这个文件夹里面才是版本库控制的内容。</p>\n<p>然而我们的目的是想让当前网站的根目录与svn直接同步，因此我们在上一级目录进行checkout。</p>\n<p>接下来正确的做法是</p>\n<pre><code>cd PATH/wwwroot\nsvn checkout file://PATH/svn/PROJECT www.example.com\n</code></pre><p>上述命令是在checkout版本库的同时对它进行了重命名，这样子，网站的根目录就如预想的一样在版本库的控制之下了。</p>\n<h3 id=\"接下来配置hooks\"><a href=\"#接下来配置hooks\" class=\"headerlink\" title=\"接下来配置hooks\"></a>接下来配置hooks</h3><pre><code>cd PATH/svn/PROJECT/hooks\ncp post-commit.tmpl post-commit\n</code></pre><p>复制一份post-commit并去掉它的后缀名，这么做的原因是，.tmpl是一个模板文件，实际并不会执行，只有去掉后缀名之后它才会生效。</p>\n<pre><code>vi post-commit\n</code></pre><p>在末尾加入</p>\n<pre><code>export LANG=zh_CN.UTF-8\nsvn update PATH/wwwroot/www.example.com --username USER1 --password PASSWD1 --no-auth-cache\n</code></pre><p>export的作用是防止乱码。</p>\n<p>update则是对网站目录进行更新，让网站目录与版本库同步，这里USER1和PASSWD1是之前的教程里配置的用户名和密码，请根据实际情况进行替换。<br>编辑完成之后，按ESC并输入:wq，保存并退出。</p>\n<h3 id=\"测试hooks\"><a href=\"#测试hooks\" class=\"headerlink\" title=\"测试hooks\"></a>测试hooks</h3><h4 id=\"添加可执行权限\"><a href=\"#添加可执行权限\" class=\"headerlink\" title=\"添加可执行权限\"></a>添加可执行权限</h4><pre><code>chmod +x post-commit\n</code></pre><h4 id=\"运行测试\"><a href=\"#运行测试\" class=\"headerlink\" title=\"运行测试\"></a>运行测试</h4><pre><code>./post-commit\n</code></pre><p>　　如果有报错，请重新vi一遍看看是不是有打错</p>\n<h4 id=\"切换用户进行测试\"><a href=\"#切换用户进行测试\" class=\"headerlink\" title=\"切换用户进行测试\"></a>切换用户进行测试</h4><p>由于ssh VPS之后大多数情况用的都是root用户，而svn commit之后执行hooks的是另外一个用户，所以在root权限下执行没有问题，在另外的用户下可能就没有那么足够的权限了。所以接下来</p>\n<pre><code>su www\n./post-commit\n</code></pre><p>如果执行成功，那么基本不会有问题。<br>如果su www时出现not available的情况，尝试下面这个命令</p>\n<pre><code>usermod -s /bin/bash www\n</code></pre><p>　　如果出现各种权限不足的情况，我建议上述所有步骤都在www用户下执行（除了部分更改文件执行权限操作等必须用root用户的）。</p>\n<h3 id=\"实际测试\"><a href=\"#实际测试\" class=\"headerlink\" title=\"实际测试\"></a>实际测试</h3><p>使用你的svn客户端checkout该版本库并上传一些文件或做一些改动，接着进行commit，查看网站目录是否与版本库同步。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>Svn的hooks是非常好用的脚本，在每次commit之后，你也可以加入日志记录、通知提醒等等功能。当然，这些功能也是需要一定的shell能力才写的出来。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>承接之前<a href=\"!--￼0--\">Lnmp下搭建Svn服务器</a>的步骤，接下来要使用Svn中的hooks来进行版本库与网站目录的同步更新。以方便对网站代码进行管理和发布。</p>\n<p>注意，下文中PATH、PROJECT等全大写的字符串均为举例用，实际操作时请替换成自己的目录和版本库或项目名称。</p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>首先切换到版本库的目录</p>\n<pre><code>cd /PATH/svn/PROJECT\nls\n</code></pre><p>会看到有hooks文件夹</p>\n<pre><code>cd hooks\nls\n</code></pre><p>可以看到有一个post-commit.tmpl，这个是svn官方的一个模板，在每次commit操作之后都会执行这个脚本，其他的hooks同理。</p>\n<p>看到这里你应该可以想到，版本库与网站目录同步的原理，就是在客户端commit了代码之后，执行这个脚本来同时update网站目录的内容，保证两者的同步。</p>\n<h2 id=\"配置操作\"><a href=\"#配置操作\" class=\"headerlink\" title=\"配置操作\"></a>配置操作</h2><h3 id=\"首先需要在网站目录checkout版本库\"><a href=\"#首先需要在网站目录checkout版本库\" class=\"headerlink\" title=\"首先需要在网站目录checkout版本库\"></a>首先需要在网站目录checkout版本库</h3><p>先不要着急打接下来的命令</p>\n<pre><code>cd PATH/wwwroot/www.example.com\nsvn checkout file://PATH/svn/PROJECT\n</code></pre><p>因为执行了这个命令之后你也许会发现，在网站目录下多了一个PROJECT文件夹，这个文件夹里面才是版本库控制的内容。</p>\n<p>然而我们的目的是想让当前网站的根目录与svn直接同步，因此我们在上一级目录进行checkout。</p>\n<p>接下来正确的做法是</p>\n<pre><code>cd PATH/wwwroot\nsvn checkout file://PATH/svn/PROJECT www.example.com\n</code></pre><p>上述命令是在checkout版本库的同时对它进行了重命名，这样子，网站的根目录就如预想的一样在版本库的控制之下了。</p>\n<h3 id=\"接下来配置hooks\"><a href=\"#接下来配置hooks\" class=\"headerlink\" title=\"接下来配置hooks\"></a>接下来配置hooks</h3><pre><code>cd PATH/svn/PROJECT/hooks\ncp post-commit.tmpl post-commit\n</code></pre><p>复制一份post-commit并去掉它的后缀名，这么做的原因是，.tmpl是一个模板文件，实际并不会执行，只有去掉后缀名之后它才会生效。</p>\n<pre><code>vi post-commit\n</code></pre><p>在末尾加入</p>\n<pre><code>export LANG=zh_CN.UTF-8\nsvn update PATH/wwwroot/www.example.com --username USER1 --password PASSWD1 --no-auth-cache\n</code></pre><p>export的作用是防止乱码。</p>\n<p>update则是对网站目录进行更新，让网站目录与版本库同步，这里USER1和PASSWD1是之前的教程里配置的用户名和密码，请根据实际情况进行替换。<br>编辑完成之后，按ESC并输入:wq，保存并退出。</p>\n<h3 id=\"测试hooks\"><a href=\"#测试hooks\" class=\"headerlink\" title=\"测试hooks\"></a>测试hooks</h3><h4 id=\"添加可执行权限\"><a href=\"#添加可执行权限\" class=\"headerlink\" title=\"添加可执行权限\"></a>添加可执行权限</h4><pre><code>chmod +x post-commit\n</code></pre><h4 id=\"运行测试\"><a href=\"#运行测试\" class=\"headerlink\" title=\"运行测试\"></a>运行测试</h4><pre><code>./post-commit\n</code></pre><p>　　如果有报错，请重新vi一遍看看是不是有打错</p>\n<h4 id=\"切换用户进行测试\"><a href=\"#切换用户进行测试\" class=\"headerlink\" title=\"切换用户进行测试\"></a>切换用户进行测试</h4><p>由于ssh VPS之后大多数情况用的都是root用户，而svn commit之后执行hooks的是另外一个用户，所以在root权限下执行没有问题，在另外的用户下可能就没有那么足够的权限了。所以接下来</p>\n<pre><code>su www\n./post-commit\n</code></pre><p>如果执行成功，那么基本不会有问题。<br>如果su www时出现not available的情况，尝试下面这个命令</p>\n<pre><code>usermod -s /bin/bash www\n</code></pre><p>　　如果出现各种权限不足的情况，我建议上述所有步骤都在www用户下执行（除了部分更改文件执行权限操作等必须用root用户的）。</p>\n<h3 id=\"实际测试\"><a href=\"#实际测试\" class=\"headerlink\" title=\"实际测试\"></a>实际测试</h3><p>使用你的svn客户端checkout该版本库并上传一些文件或做一些改动，接着进行commit，查看网站目录是否与版本库同步。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>Svn的hooks是非常好用的脚本，在每次commit之后，你也可以加入日志记录、通知提醒等等功能。当然，这些功能也是需要一定的shell能力才写的出来。</p>\n"},{"layout":"post","title":"深入浅出React读后笔记","date":"2016-04-24T10:36:56.000Z","_content":"## React的设计哲学\n\nReact最有价值的是声明式的，直观的编程方式。编程方式 简单直观 且 符合习惯，可以使得代码 更容易理解 、易于维护和有助于演进。可理解，可维护的代码代表着工程的质量和效率。\n \n## JSX定义用户界面更加直观\n\nJSX定义的用户界面使得HTML可以直接嵌入到JS中，而不使用模板。原因在于，模板背后的代码逻辑严重依赖其模板中的内容和DOM结构，两者紧密耦合。虽然模板可以使得文件分离，且让非开发人员也可以对界面进行修改，但是为了保证两者之间的协作，需要引入更多的概念和机制。\n\n而在JSX中，React并没有引入更多新的概念，你仍可以用HTML和JS的思路去构建自己的应用。这种直观的方式降低了React的学习门槛，也使得新手更容易理解。\n\n## 所谓组件，其实就是状态机器\n组件是某个独立功能或界面的封装（定义），使其能够进行复用或是业务逻辑分离（目的）。\n\n在React中，为了更加容易保证界面一致性，React把它看做简单的状态机器。即根据状态去输出基于状态的界面，React则负责以最高效的方式去更新整个界面和DOM树。\n\n对组件的管理，实际就是对组件状态的管理。更新一个组件，就是更新一个组件的状态。设计者需要做的，就是关心不同状态的用户界面。这相比于原始的JS直接控制真实DOM（过于自由）来说，预先设定好组件的状态对应的用户界面，可以让问题缩小到组件中，而不需要开发者考虑整一个应用的DOM或是担心新加入的代码可能会产生不被期望的副作用。像这样将DOM限制在组件之中，尽管失去了“自由”，但是也可以使得开发者更好的对界面进行管理和控制。\n\n组件作为用户界面的基本单位，与外界的交互方式除了状态（state）之外，还有其属性（props）。state由组件内部进行维护，而属性则是在外部初始化时传递进来，一旦赋值不建议进行变化。同一类组件就像是人一样，可以有着不同的身高和肤色（属性），但是其呼吸、运动等活动方式（状态）则是相通的。\n \n## 每一次变化都是整体刷新\n数据模型驱动用户界面在概念上是直观的，但是在实践中确实困难重重。数据模型的变化可能会导致分散在整个用户界面各个角落的UI同时进行变化。界面越复杂，数据与界面的一致性越难以维护。\n\n关于这个问题，在原文中并没有被解释的很清楚。所谓数据模型，是一个整体的、全局的数据，不同于AJAX获取那种局部的数据，数据模型代表了整个UI界面的状态。\n\n考虑一下实际的开发场景，当我们拿到一个新的数据之后，我们需要做哪些事情。首先是分析数据，在概念上明确我们需要更新的UI，接着拿新数据与UI进行对比（检查），判断哪些需要更新而哪些不需要变化。接下来是实际通过编码的方式更新UI，进行DOM操作，最后检查UI是否被正确的刷新。\n\n实际上在界面复杂并且有许多UI之间的依赖更新的情况下，开发者无法立刻得知当前的UI与之后刷新的UI是否一致。出于减少DOM操作的角度考虑，当然是只刷新那些有变化的UI就好。但是想要实现它，开发者必须对UI一一进行前后对比，界面越复杂越难以实现。而如果把涉及到的所有UI都进行更新，则会产生不必要的性能损耗（把一个UI删除了又产生一个同样的UI）。\n为此，React引入了虚拟DOM的概念。既然整体进行渲染（把所有涉及到的UI都进行刷新）一定可以保证数据模型与用户界面的一致性，那不如就整体进行刷新吧，让框架来解决哪些需要进行DOM操作而哪些UI则保持原样。React通过虚拟DOM把所有的现有UI的数据模型与新的数据模型进行一一的对比，最终进行最优化的局部真实DOM更新。虚拟DOM可以通过其算法获得不论界面多么复杂的情况下，都可以接受的性能代价。\n何时是React的最有价值的时候？当你的界面越来越复杂时。\n \n## 单向数据流动Flux\n\n既然已经有了组件机制去定义界面，那么也还需要一定的机制来定义组件之间，以及组件和数据模型之间如何通信。为此Facebook提出了Flux，其提倡的是单向数据流动。即永远只有模型到视图的数据流动。\n\nFlux的定义非常宽松，目前社区中还出现了很多不同的实现，如Flexible，Reflux等。\n \n## 让数据模型也变简单\n\nReact提倡只用只读数据来建立数据模型，所有的数据都是只读的，如果你想要进行修改，那么就只能产生一份包含新的修改的数据。这有点像同一个类的实例，其成员变量是私有的并且在实例化之后没有相关函数能够对其进行修改，如果想要进行修改，那么就只能重新实例一个。\n\n只读的数据可以让代码更加的安全和易于维护，至少开发者不用担心数据在某个角落被某段神奇的代码所修改。数据的来源只有数据出生的时候，这无疑可以抹杀很多bug出现的可能。\n \n## 其他\n\nReact Native：移动开发。React把UI层进行了完美的抽象使得开发者不需要进行DOM操作，而React Native正是把DOM替换成了iOS或Android的原声控件。其开发方式都是一致的。\n\nReact Canvas：所有的界面元素都通过Canvas来进行绘制，彻底舍弃了DOM。\n \n## 总结\n\n任何框架诞生的初衷都离不开对开发问题的解决。React同样是为了解决前端开发中的痛点而生。原文总结分析了其相关技术背后的设计思想，是一篇质量很高的文章。\n\n我一直坚信在计算机这样的人造学科中，理解一门技术的初衷，能够使自己更好的去学习和使用。很多人都可以在短时间入门一门技术，但是很少有人去关注其背后的设计思想和方式。尽管我现在技术基础不扎实，但是React的设计思路确确实实是我在实际开发中会遇到和疑惑的问题。这样一想，React就变得十分可爱了，我也期望自己能在实际的开发中，遵循简单直观的原则，进行高效率和高质量的开发。\n\n## 参考\n[深入浅出React（一）：React的设计哲学 - 简单之美](http://www.infoq.com/cn/articles/react-art-of-simplity)","source":"_posts/2016-04-24-深入浅出React读后笔记.markdown","raw":"---\nlayout: post\ntitle:  \"深入浅出React读后笔记\"\ndate:   2016-04-24 18:36:56 +0800\ntags: react\n---\n## React的设计哲学\n\nReact最有价值的是声明式的，直观的编程方式。编程方式 简单直观 且 符合习惯，可以使得代码 更容易理解 、易于维护和有助于演进。可理解，可维护的代码代表着工程的质量和效率。\n \n## JSX定义用户界面更加直观\n\nJSX定义的用户界面使得HTML可以直接嵌入到JS中，而不使用模板。原因在于，模板背后的代码逻辑严重依赖其模板中的内容和DOM结构，两者紧密耦合。虽然模板可以使得文件分离，且让非开发人员也可以对界面进行修改，但是为了保证两者之间的协作，需要引入更多的概念和机制。\n\n而在JSX中，React并没有引入更多新的概念，你仍可以用HTML和JS的思路去构建自己的应用。这种直观的方式降低了React的学习门槛，也使得新手更容易理解。\n\n## 所谓组件，其实就是状态机器\n组件是某个独立功能或界面的封装（定义），使其能够进行复用或是业务逻辑分离（目的）。\n\n在React中，为了更加容易保证界面一致性，React把它看做简单的状态机器。即根据状态去输出基于状态的界面，React则负责以最高效的方式去更新整个界面和DOM树。\n\n对组件的管理，实际就是对组件状态的管理。更新一个组件，就是更新一个组件的状态。设计者需要做的，就是关心不同状态的用户界面。这相比于原始的JS直接控制真实DOM（过于自由）来说，预先设定好组件的状态对应的用户界面，可以让问题缩小到组件中，而不需要开发者考虑整一个应用的DOM或是担心新加入的代码可能会产生不被期望的副作用。像这样将DOM限制在组件之中，尽管失去了“自由”，但是也可以使得开发者更好的对界面进行管理和控制。\n\n组件作为用户界面的基本单位，与外界的交互方式除了状态（state）之外，还有其属性（props）。state由组件内部进行维护，而属性则是在外部初始化时传递进来，一旦赋值不建议进行变化。同一类组件就像是人一样，可以有着不同的身高和肤色（属性），但是其呼吸、运动等活动方式（状态）则是相通的。\n \n## 每一次变化都是整体刷新\n数据模型驱动用户界面在概念上是直观的，但是在实践中确实困难重重。数据模型的变化可能会导致分散在整个用户界面各个角落的UI同时进行变化。界面越复杂，数据与界面的一致性越难以维护。\n\n关于这个问题，在原文中并没有被解释的很清楚。所谓数据模型，是一个整体的、全局的数据，不同于AJAX获取那种局部的数据，数据模型代表了整个UI界面的状态。\n\n考虑一下实际的开发场景，当我们拿到一个新的数据之后，我们需要做哪些事情。首先是分析数据，在概念上明确我们需要更新的UI，接着拿新数据与UI进行对比（检查），判断哪些需要更新而哪些不需要变化。接下来是实际通过编码的方式更新UI，进行DOM操作，最后检查UI是否被正确的刷新。\n\n实际上在界面复杂并且有许多UI之间的依赖更新的情况下，开发者无法立刻得知当前的UI与之后刷新的UI是否一致。出于减少DOM操作的角度考虑，当然是只刷新那些有变化的UI就好。但是想要实现它，开发者必须对UI一一进行前后对比，界面越复杂越难以实现。而如果把涉及到的所有UI都进行更新，则会产生不必要的性能损耗（把一个UI删除了又产生一个同样的UI）。\n为此，React引入了虚拟DOM的概念。既然整体进行渲染（把所有涉及到的UI都进行刷新）一定可以保证数据模型与用户界面的一致性，那不如就整体进行刷新吧，让框架来解决哪些需要进行DOM操作而哪些UI则保持原样。React通过虚拟DOM把所有的现有UI的数据模型与新的数据模型进行一一的对比，最终进行最优化的局部真实DOM更新。虚拟DOM可以通过其算法获得不论界面多么复杂的情况下，都可以接受的性能代价。\n何时是React的最有价值的时候？当你的界面越来越复杂时。\n \n## 单向数据流动Flux\n\n既然已经有了组件机制去定义界面，那么也还需要一定的机制来定义组件之间，以及组件和数据模型之间如何通信。为此Facebook提出了Flux，其提倡的是单向数据流动。即永远只有模型到视图的数据流动。\n\nFlux的定义非常宽松，目前社区中还出现了很多不同的实现，如Flexible，Reflux等。\n \n## 让数据模型也变简单\n\nReact提倡只用只读数据来建立数据模型，所有的数据都是只读的，如果你想要进行修改，那么就只能产生一份包含新的修改的数据。这有点像同一个类的实例，其成员变量是私有的并且在实例化之后没有相关函数能够对其进行修改，如果想要进行修改，那么就只能重新实例一个。\n\n只读的数据可以让代码更加的安全和易于维护，至少开发者不用担心数据在某个角落被某段神奇的代码所修改。数据的来源只有数据出生的时候，这无疑可以抹杀很多bug出现的可能。\n \n## 其他\n\nReact Native：移动开发。React把UI层进行了完美的抽象使得开发者不需要进行DOM操作，而React Native正是把DOM替换成了iOS或Android的原声控件。其开发方式都是一致的。\n\nReact Canvas：所有的界面元素都通过Canvas来进行绘制，彻底舍弃了DOM。\n \n## 总结\n\n任何框架诞生的初衷都离不开对开发问题的解决。React同样是为了解决前端开发中的痛点而生。原文总结分析了其相关技术背后的设计思想，是一篇质量很高的文章。\n\n我一直坚信在计算机这样的人造学科中，理解一门技术的初衷，能够使自己更好的去学习和使用。很多人都可以在短时间入门一门技术，但是很少有人去关注其背后的设计思想和方式。尽管我现在技术基础不扎实，但是React的设计思路确确实实是我在实际开发中会遇到和疑惑的问题。这样一想，React就变得十分可爱了，我也期望自己能在实际的开发中，遵循简单直观的原则，进行高效率和高质量的开发。\n\n## 参考\n[深入浅出React（一）：React的设计哲学 - 简单之美](http://www.infoq.com/cn/articles/react-art-of-simplity)","slug":"2016-04-24-深入浅出React读后笔记","published":1,"updated":"2017-08-06T12:14:27.000Z","_id":"cj60bzxke00031doruwuu5vxj","comments":1,"photos":[],"link":"","content":"<h2 id=\"React的设计哲学\"><a href=\"#React的设计哲学\" class=\"headerlink\" title=\"React的设计哲学\"></a>React的设计哲学</h2><p>React最有价值的是声明式的，直观的编程方式。编程方式 简单直观 且 符合习惯，可以使得代码 更容易理解 、易于维护和有助于演进。可理解，可维护的代码代表着工程的质量和效率。</p>\n<h2 id=\"JSX定义用户界面更加直观\"><a href=\"#JSX定义用户界面更加直观\" class=\"headerlink\" title=\"JSX定义用户界面更加直观\"></a>JSX定义用户界面更加直观</h2><p>JSX定义的用户界面使得HTML可以直接嵌入到JS中，而不使用模板。原因在于，模板背后的代码逻辑严重依赖其模板中的内容和DOM结构，两者紧密耦合。虽然模板可以使得文件分离，且让非开发人员也可以对界面进行修改，但是为了保证两者之间的协作，需要引入更多的概念和机制。</p>\n<p>而在JSX中，React并没有引入更多新的概念，你仍可以用HTML和JS的思路去构建自己的应用。这种直观的方式降低了React的学习门槛，也使得新手更容易理解。</p>\n<h2 id=\"所谓组件，其实就是状态机器\"><a href=\"#所谓组件，其实就是状态机器\" class=\"headerlink\" title=\"所谓组件，其实就是状态机器\"></a>所谓组件，其实就是状态机器</h2><p>组件是某个独立功能或界面的封装（定义），使其能够进行复用或是业务逻辑分离（目的）。</p>\n<p>在React中，为了更加容易保证界面一致性，React把它看做简单的状态机器。即根据状态去输出基于状态的界面，React则负责以最高效的方式去更新整个界面和DOM树。</p>\n<p>对组件的管理，实际就是对组件状态的管理。更新一个组件，就是更新一个组件的状态。设计者需要做的，就是关心不同状态的用户界面。这相比于原始的JS直接控制真实DOM（过于自由）来说，预先设定好组件的状态对应的用户界面，可以让问题缩小到组件中，而不需要开发者考虑整一个应用的DOM或是担心新加入的代码可能会产生不被期望的副作用。像这样将DOM限制在组件之中，尽管失去了“自由”，但是也可以使得开发者更好的对界面进行管理和控制。</p>\n<p>组件作为用户界面的基本单位，与外界的交互方式除了状态（state）之外，还有其属性（props）。state由组件内部进行维护，而属性则是在外部初始化时传递进来，一旦赋值不建议进行变化。同一类组件就像是人一样，可以有着不同的身高和肤色（属性），但是其呼吸、运动等活动方式（状态）则是相通的。</p>\n<h2 id=\"每一次变化都是整体刷新\"><a href=\"#每一次变化都是整体刷新\" class=\"headerlink\" title=\"每一次变化都是整体刷新\"></a>每一次变化都是整体刷新</h2><p>数据模型驱动用户界面在概念上是直观的，但是在实践中确实困难重重。数据模型的变化可能会导致分散在整个用户界面各个角落的UI同时进行变化。界面越复杂，数据与界面的一致性越难以维护。</p>\n<p>关于这个问题，在原文中并没有被解释的很清楚。所谓数据模型，是一个整体的、全局的数据，不同于AJAX获取那种局部的数据，数据模型代表了整个UI界面的状态。</p>\n<p>考虑一下实际的开发场景，当我们拿到一个新的数据之后，我们需要做哪些事情。首先是分析数据，在概念上明确我们需要更新的UI，接着拿新数据与UI进行对比（检查），判断哪些需要更新而哪些不需要变化。接下来是实际通过编码的方式更新UI，进行DOM操作，最后检查UI是否被正确的刷新。</p>\n<p>实际上在界面复杂并且有许多UI之间的依赖更新的情况下，开发者无法立刻得知当前的UI与之后刷新的UI是否一致。出于减少DOM操作的角度考虑，当然是只刷新那些有变化的UI就好。但是想要实现它，开发者必须对UI一一进行前后对比，界面越复杂越难以实现。而如果把涉及到的所有UI都进行更新，则会产生不必要的性能损耗（把一个UI删除了又产生一个同样的UI）。<br>为此，React引入了虚拟DOM的概念。既然整体进行渲染（把所有涉及到的UI都进行刷新）一定可以保证数据模型与用户界面的一致性，那不如就整体进行刷新吧，让框架来解决哪些需要进行DOM操作而哪些UI则保持原样。React通过虚拟DOM把所有的现有UI的数据模型与新的数据模型进行一一的对比，最终进行最优化的局部真实DOM更新。虚拟DOM可以通过其算法获得不论界面多么复杂的情况下，都可以接受的性能代价。<br>何时是React的最有价值的时候？当你的界面越来越复杂时。</p>\n<h2 id=\"单向数据流动Flux\"><a href=\"#单向数据流动Flux\" class=\"headerlink\" title=\"单向数据流动Flux\"></a>单向数据流动Flux</h2><p>既然已经有了组件机制去定义界面，那么也还需要一定的机制来定义组件之间，以及组件和数据模型之间如何通信。为此Facebook提出了Flux，其提倡的是单向数据流动。即永远只有模型到视图的数据流动。</p>\n<p>Flux的定义非常宽松，目前社区中还出现了很多不同的实现，如Flexible，Reflux等。</p>\n<h2 id=\"让数据模型也变简单\"><a href=\"#让数据模型也变简单\" class=\"headerlink\" title=\"让数据模型也变简单\"></a>让数据模型也变简单</h2><p>React提倡只用只读数据来建立数据模型，所有的数据都是只读的，如果你想要进行修改，那么就只能产生一份包含新的修改的数据。这有点像同一个类的实例，其成员变量是私有的并且在实例化之后没有相关函数能够对其进行修改，如果想要进行修改，那么就只能重新实例一个。</p>\n<p>只读的数据可以让代码更加的安全和易于维护，至少开发者不用担心数据在某个角落被某段神奇的代码所修改。数据的来源只有数据出生的时候，这无疑可以抹杀很多bug出现的可能。</p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>React Native：移动开发。React把UI层进行了完美的抽象使得开发者不需要进行DOM操作，而React Native正是把DOM替换成了iOS或Android的原声控件。其开发方式都是一致的。</p>\n<p>React Canvas：所有的界面元素都通过Canvas来进行绘制，彻底舍弃了DOM。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>任何框架诞生的初衷都离不开对开发问题的解决。React同样是为了解决前端开发中的痛点而生。原文总结分析了其相关技术背后的设计思想，是一篇质量很高的文章。</p>\n<p>我一直坚信在计算机这样的人造学科中，理解一门技术的初衷，能够使自己更好的去学习和使用。很多人都可以在短时间入门一门技术，但是很少有人去关注其背后的设计思想和方式。尽管我现在技术基础不扎实，但是React的设计思路确确实实是我在实际开发中会遇到和疑惑的问题。这样一想，React就变得十分可爱了，我也期望自己能在实际的开发中，遵循简单直观的原则，进行高效率和高质量的开发。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://www.infoq.com/cn/articles/react-art-of-simplity\" target=\"_blank\" rel=\"external\">深入浅出React（一）：React的设计哲学 - 简单之美</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"React的设计哲学\"><a href=\"#React的设计哲学\" class=\"headerlink\" title=\"React的设计哲学\"></a>React的设计哲学</h2><p>React最有价值的是声明式的，直观的编程方式。编程方式 简单直观 且 符合习惯，可以使得代码 更容易理解 、易于维护和有助于演进。可理解，可维护的代码代表着工程的质量和效率。</p>\n<h2 id=\"JSX定义用户界面更加直观\"><a href=\"#JSX定义用户界面更加直观\" class=\"headerlink\" title=\"JSX定义用户界面更加直观\"></a>JSX定义用户界面更加直观</h2><p>JSX定义的用户界面使得HTML可以直接嵌入到JS中，而不使用模板。原因在于，模板背后的代码逻辑严重依赖其模板中的内容和DOM结构，两者紧密耦合。虽然模板可以使得文件分离，且让非开发人员也可以对界面进行修改，但是为了保证两者之间的协作，需要引入更多的概念和机制。</p>\n<p>而在JSX中，React并没有引入更多新的概念，你仍可以用HTML和JS的思路去构建自己的应用。这种直观的方式降低了React的学习门槛，也使得新手更容易理解。</p>\n<h2 id=\"所谓组件，其实就是状态机器\"><a href=\"#所谓组件，其实就是状态机器\" class=\"headerlink\" title=\"所谓组件，其实就是状态机器\"></a>所谓组件，其实就是状态机器</h2><p>组件是某个独立功能或界面的封装（定义），使其能够进行复用或是业务逻辑分离（目的）。</p>\n<p>在React中，为了更加容易保证界面一致性，React把它看做简单的状态机器。即根据状态去输出基于状态的界面，React则负责以最高效的方式去更新整个界面和DOM树。</p>\n<p>对组件的管理，实际就是对组件状态的管理。更新一个组件，就是更新一个组件的状态。设计者需要做的，就是关心不同状态的用户界面。这相比于原始的JS直接控制真实DOM（过于自由）来说，预先设定好组件的状态对应的用户界面，可以让问题缩小到组件中，而不需要开发者考虑整一个应用的DOM或是担心新加入的代码可能会产生不被期望的副作用。像这样将DOM限制在组件之中，尽管失去了“自由”，但是也可以使得开发者更好的对界面进行管理和控制。</p>\n<p>组件作为用户界面的基本单位，与外界的交互方式除了状态（state）之外，还有其属性（props）。state由组件内部进行维护，而属性则是在外部初始化时传递进来，一旦赋值不建议进行变化。同一类组件就像是人一样，可以有着不同的身高和肤色（属性），但是其呼吸、运动等活动方式（状态）则是相通的。</p>\n<h2 id=\"每一次变化都是整体刷新\"><a href=\"#每一次变化都是整体刷新\" class=\"headerlink\" title=\"每一次变化都是整体刷新\"></a>每一次变化都是整体刷新</h2><p>数据模型驱动用户界面在概念上是直观的，但是在实践中确实困难重重。数据模型的变化可能会导致分散在整个用户界面各个角落的UI同时进行变化。界面越复杂，数据与界面的一致性越难以维护。</p>\n<p>关于这个问题，在原文中并没有被解释的很清楚。所谓数据模型，是一个整体的、全局的数据，不同于AJAX获取那种局部的数据，数据模型代表了整个UI界面的状态。</p>\n<p>考虑一下实际的开发场景，当我们拿到一个新的数据之后，我们需要做哪些事情。首先是分析数据，在概念上明确我们需要更新的UI，接着拿新数据与UI进行对比（检查），判断哪些需要更新而哪些不需要变化。接下来是实际通过编码的方式更新UI，进行DOM操作，最后检查UI是否被正确的刷新。</p>\n<p>实际上在界面复杂并且有许多UI之间的依赖更新的情况下，开发者无法立刻得知当前的UI与之后刷新的UI是否一致。出于减少DOM操作的角度考虑，当然是只刷新那些有变化的UI就好。但是想要实现它，开发者必须对UI一一进行前后对比，界面越复杂越难以实现。而如果把涉及到的所有UI都进行更新，则会产生不必要的性能损耗（把一个UI删除了又产生一个同样的UI）。<br>为此，React引入了虚拟DOM的概念。既然整体进行渲染（把所有涉及到的UI都进行刷新）一定可以保证数据模型与用户界面的一致性，那不如就整体进行刷新吧，让框架来解决哪些需要进行DOM操作而哪些UI则保持原样。React通过虚拟DOM把所有的现有UI的数据模型与新的数据模型进行一一的对比，最终进行最优化的局部真实DOM更新。虚拟DOM可以通过其算法获得不论界面多么复杂的情况下，都可以接受的性能代价。<br>何时是React的最有价值的时候？当你的界面越来越复杂时。</p>\n<h2 id=\"单向数据流动Flux\"><a href=\"#单向数据流动Flux\" class=\"headerlink\" title=\"单向数据流动Flux\"></a>单向数据流动Flux</h2><p>既然已经有了组件机制去定义界面，那么也还需要一定的机制来定义组件之间，以及组件和数据模型之间如何通信。为此Facebook提出了Flux，其提倡的是单向数据流动。即永远只有模型到视图的数据流动。</p>\n<p>Flux的定义非常宽松，目前社区中还出现了很多不同的实现，如Flexible，Reflux等。</p>\n<h2 id=\"让数据模型也变简单\"><a href=\"#让数据模型也变简单\" class=\"headerlink\" title=\"让数据模型也变简单\"></a>让数据模型也变简单</h2><p>React提倡只用只读数据来建立数据模型，所有的数据都是只读的，如果你想要进行修改，那么就只能产生一份包含新的修改的数据。这有点像同一个类的实例，其成员变量是私有的并且在实例化之后没有相关函数能够对其进行修改，如果想要进行修改，那么就只能重新实例一个。</p>\n<p>只读的数据可以让代码更加的安全和易于维护，至少开发者不用担心数据在某个角落被某段神奇的代码所修改。数据的来源只有数据出生的时候，这无疑可以抹杀很多bug出现的可能。</p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>React Native：移动开发。React把UI层进行了完美的抽象使得开发者不需要进行DOM操作，而React Native正是把DOM替换成了iOS或Android的原声控件。其开发方式都是一致的。</p>\n<p>React Canvas：所有的界面元素都通过Canvas来进行绘制，彻底舍弃了DOM。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>任何框架诞生的初衷都离不开对开发问题的解决。React同样是为了解决前端开发中的痛点而生。原文总结分析了其相关技术背后的设计思想，是一篇质量很高的文章。</p>\n<p>我一直坚信在计算机这样的人造学科中，理解一门技术的初衷，能够使自己更好的去学习和使用。很多人都可以在短时间入门一门技术，但是很少有人去关注其背后的设计思想和方式。尽管我现在技术基础不扎实，但是React的设计思路确确实实是我在实际开发中会遇到和疑惑的问题。这样一想，React就变得十分可爱了，我也期望自己能在实际的开发中，遵循简单直观的原则，进行高效率和高质量的开发。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://www.infoq.com/cn/articles/react-art-of-simplity\" target=\"_blank\" rel=\"external\">深入浅出React（一）：React的设计哲学 - 简单之美</a></p>\n"},{"layout":"post","title":"Git：那些常用命令的整理","date":"2017-01-30T14:45:14.000Z","_content":"Git是一个分布式版本控制系统，相比集中式的版本控制系统，分布式版本控制系统每个人手上都是一个完整的版本库。\n\n## 创建版本库\n\n    git init\n\n初始化一个git仓库。\n\n    git add <file>\n\n添加文件到暂存区。\n\n    git commit -m \"message\"\n\n把之前`git add`的文件提交到仓库，可以add多个文件，然后执行一次commit。\n\n> SVN上`add`之后直接就添加到版本库了，但是Git上还需要`commit`才行，注意SVN与Git之间`commit`与`add`的异同。\n\n## 查看版本库的状态\n\n    git status\n\n查看当前工作区的状态。\n\n    git diff\n\n查看difference，显示的格式是Unix通用的diff格式。\n\n> 简单来说`git status`命令可以知道哪些文件做了修改，`git diff`命令可以知道被修改了哪些内容。\n\n    git log\n    git log --pretty=oneline\n\n显示从最近到最远的提交日志。\n\n> `commit id`是版本号，用 SHA1 十六进制表示\n\n## 版本回退\n\n    git reset --hard HEAD^\n    git reset --hard HEAD~100\n    git reset --hard 3628164\n\n`HEAD`表示当前版本，`HEAD^`表示当前版本的上一个版本，`~100`等同于100个`^`。`3628164`是版本号，版本号不用写全，Git中只要知道`commit id`就可以回退。\n\n    git reflog\n\n查看历史命令，通过历史命令可以知道版本号。\n\n> 需要提交的文件通通使用`git add`放到暂存区（stage），然后使用`git commit`一次性提交暂存区所有修改到分之。工作区（working diretory）是电脑里能看到的目录，版本库（repository）则是工作区中一个隐藏的文件夹`.git`。\ngit跟踪并管理的是修改，每次修改都需要`add`到暂存区，这样才能被`commit`到分支中。\n\n## 管理修改\n\n    git checkout --file\n\n把file在工作区的修改全部撤销，也就是把这个文件回到最近一次`git commit`或者`git add`的状态（用版本库的版本替换工作区）。\n\n    git reset HEAD file\n\n把暂存区的修改回退到工作区，不会影响工作区的状态。\n\n    git rm file\n\n从版本库中删除某个文件。这个命令跟`git add`一样，需要`git commit`之后才能提交到版本库中。\n\n## 分支管理\n\n### 创建分支\n\n    git checkout -b dev\n\n创建并切换到dev分支，`-b`参数表示**创建并切换**，这个命令实际上是下面两个命令的结合。\n\n    git branch dev\n    git checkout dev \n`git branch`是创建一个dev分支，`git checkout`则是切换到dev分支。\n\n    git branch\n\n查看当前分支，当前分支会标有一个*号。\n\n    git checkout master\n\n切换到master分支。\n\n    git merge dev\n\n合并指定分支到当前分支。\n\n    git branch -d dev\n\n删除指定分支。\n\n### 解决冲突\n\n当切换到master分支并尝试合并dev分支时，若有冲突存在，必须手动解决冲突再进行提交。\n\nGit用<<<<<<，======，>>>>>>标记处不同分支的内容。\n\n    git log --graph --pretty=oneline --abbrev-commit\n\n用带参数的`git log`命令可以看到分支的合并情况。\n\n> 当Git无法自动合并分支时，必须首先解决冲突，再提交。合并后用`git log --graph`可以看到分支合并图。\n\n### 分支管理策略\n\n默认情况下，Git会用`Fast forward`模式合并分支，但这种情况下，删除分支会丢掉分支信息，会看不出来曾经做过合并\n\n    git merge --no-ff -m \"message\" dev\n\n本次合并会创建一个新的commit，通过`-m`把commit描述写进去，`--no-ff`表示禁用`Fast forward`。\n\n> `master`一般是最稳定的版本，用来发布新版本。\n建立以个`dev`分支来进行协作，每个人都在`dev`分支上写代码，时不时向`dev`分支上提交，dev提交到`master`上来发布稳定版本。\n\n### Bug分支\n\n    git stash\n\n可以把当前工作区存起来，等以后恢复现场继续工作。执行完后，工作区是clean的，可以拿来创建分支。\n\n    git checkout master\n    git checkout -b issue-101\n\n创建`issue-101`分支并修复Bug。\n\n    git stash list\n\n查看保存的工作区。\n\n    git stash apply\n\n恢复指定工作区。\n\n    git stash drop\n\n删除stash。\n\n    git stash pop\n\n恢复的同时会删除stash的内容。\n\n## 配置\ngit config 命令用来设置git的一些基本设置，包括全局配置以及针对特定仓库的配置。\n### 使用方法\n#### 设置名字\n    git config user.name <name>\n\n设置当前仓库`commit`时作者的名字。\n\n    git config --global user.name <name>\n\n设置全局的作者名字，这样以后其他仓库`commit`时，都会以这个名字提交。\n#### 设置邮箱\n    git config --global user.email <email>\n\n设置全局的作者邮箱。\n\n例子：\n\n    git config --global user.name \"denight\"\n    git config --global user.email denight@qq.com\n\n#### 设置简写/别名\n    git config --global alias.<alias-name> <git-comman>\n    \n\n设置git命令的简写。比如`git status`可以通过下面的命令简写为`git st`。\n\n    git config --global alias.st status\n\n### 更多\nGit把配置文件存储在三个不同的文件中，一个作用于当前仓库，一个作用于当前用户，一个作用于整个系统。\n\n - <repo>/.git/config 当前仓库的配置\n - ~/.gitconfig 当前用户所属的配置，即---global的配置\n - $(prefix)/etc/gitconfig 系统级别的配置\n\n优先级从高到底。\n","source":"_posts/2017-01-03-Git：常用命令整理.markdown","raw":"---\nlayout: post\ntitle:  \"Git：那些常用命令的整理\"\ndate:   2017-01-30 22:45:14 +0800\ntags: git\n---\nGit是一个分布式版本控制系统，相比集中式的版本控制系统，分布式版本控制系统每个人手上都是一个完整的版本库。\n\n## 创建版本库\n\n    git init\n\n初始化一个git仓库。\n\n    git add <file>\n\n添加文件到暂存区。\n\n    git commit -m \"message\"\n\n把之前`git add`的文件提交到仓库，可以add多个文件，然后执行一次commit。\n\n> SVN上`add`之后直接就添加到版本库了，但是Git上还需要`commit`才行，注意SVN与Git之间`commit`与`add`的异同。\n\n## 查看版本库的状态\n\n    git status\n\n查看当前工作区的状态。\n\n    git diff\n\n查看difference，显示的格式是Unix通用的diff格式。\n\n> 简单来说`git status`命令可以知道哪些文件做了修改，`git diff`命令可以知道被修改了哪些内容。\n\n    git log\n    git log --pretty=oneline\n\n显示从最近到最远的提交日志。\n\n> `commit id`是版本号，用 SHA1 十六进制表示\n\n## 版本回退\n\n    git reset --hard HEAD^\n    git reset --hard HEAD~100\n    git reset --hard 3628164\n\n`HEAD`表示当前版本，`HEAD^`表示当前版本的上一个版本，`~100`等同于100个`^`。`3628164`是版本号，版本号不用写全，Git中只要知道`commit id`就可以回退。\n\n    git reflog\n\n查看历史命令，通过历史命令可以知道版本号。\n\n> 需要提交的文件通通使用`git add`放到暂存区（stage），然后使用`git commit`一次性提交暂存区所有修改到分之。工作区（working diretory）是电脑里能看到的目录，版本库（repository）则是工作区中一个隐藏的文件夹`.git`。\ngit跟踪并管理的是修改，每次修改都需要`add`到暂存区，这样才能被`commit`到分支中。\n\n## 管理修改\n\n    git checkout --file\n\n把file在工作区的修改全部撤销，也就是把这个文件回到最近一次`git commit`或者`git add`的状态（用版本库的版本替换工作区）。\n\n    git reset HEAD file\n\n把暂存区的修改回退到工作区，不会影响工作区的状态。\n\n    git rm file\n\n从版本库中删除某个文件。这个命令跟`git add`一样，需要`git commit`之后才能提交到版本库中。\n\n## 分支管理\n\n### 创建分支\n\n    git checkout -b dev\n\n创建并切换到dev分支，`-b`参数表示**创建并切换**，这个命令实际上是下面两个命令的结合。\n\n    git branch dev\n    git checkout dev \n`git branch`是创建一个dev分支，`git checkout`则是切换到dev分支。\n\n    git branch\n\n查看当前分支，当前分支会标有一个*号。\n\n    git checkout master\n\n切换到master分支。\n\n    git merge dev\n\n合并指定分支到当前分支。\n\n    git branch -d dev\n\n删除指定分支。\n\n### 解决冲突\n\n当切换到master分支并尝试合并dev分支时，若有冲突存在，必须手动解决冲突再进行提交。\n\nGit用<<<<<<，======，>>>>>>标记处不同分支的内容。\n\n    git log --graph --pretty=oneline --abbrev-commit\n\n用带参数的`git log`命令可以看到分支的合并情况。\n\n> 当Git无法自动合并分支时，必须首先解决冲突，再提交。合并后用`git log --graph`可以看到分支合并图。\n\n### 分支管理策略\n\n默认情况下，Git会用`Fast forward`模式合并分支，但这种情况下，删除分支会丢掉分支信息，会看不出来曾经做过合并\n\n    git merge --no-ff -m \"message\" dev\n\n本次合并会创建一个新的commit，通过`-m`把commit描述写进去，`--no-ff`表示禁用`Fast forward`。\n\n> `master`一般是最稳定的版本，用来发布新版本。\n建立以个`dev`分支来进行协作，每个人都在`dev`分支上写代码，时不时向`dev`分支上提交，dev提交到`master`上来发布稳定版本。\n\n### Bug分支\n\n    git stash\n\n可以把当前工作区存起来，等以后恢复现场继续工作。执行完后，工作区是clean的，可以拿来创建分支。\n\n    git checkout master\n    git checkout -b issue-101\n\n创建`issue-101`分支并修复Bug。\n\n    git stash list\n\n查看保存的工作区。\n\n    git stash apply\n\n恢复指定工作区。\n\n    git stash drop\n\n删除stash。\n\n    git stash pop\n\n恢复的同时会删除stash的内容。\n\n## 配置\ngit config 命令用来设置git的一些基本设置，包括全局配置以及针对特定仓库的配置。\n### 使用方法\n#### 设置名字\n    git config user.name <name>\n\n设置当前仓库`commit`时作者的名字。\n\n    git config --global user.name <name>\n\n设置全局的作者名字，这样以后其他仓库`commit`时，都会以这个名字提交。\n#### 设置邮箱\n    git config --global user.email <email>\n\n设置全局的作者邮箱。\n\n例子：\n\n    git config --global user.name \"denight\"\n    git config --global user.email denight@qq.com\n\n#### 设置简写/别名\n    git config --global alias.<alias-name> <git-comman>\n    \n\n设置git命令的简写。比如`git status`可以通过下面的命令简写为`git st`。\n\n    git config --global alias.st status\n\n### 更多\nGit把配置文件存储在三个不同的文件中，一个作用于当前仓库，一个作用于当前用户，一个作用于整个系统。\n\n - <repo>/.git/config 当前仓库的配置\n - ~/.gitconfig 当前用户所属的配置，即---global的配置\n - $(prefix)/etc/gitconfig 系统级别的配置\n\n优先级从高到底。\n","slug":"2017-01-03-Git：常用命令整理","published":1,"updated":"2017-08-06T12:14:30.000Z","_id":"cj60bzxkh00041dord46ns8ay","comments":1,"photos":[],"link":"","content":"<p>Git是一个分布式版本控制系统，相比集中式的版本控制系统，分布式版本控制系统每个人手上都是一个完整的版本库。</p>\n<h2 id=\"创建版本库\"><a href=\"#创建版本库\" class=\"headerlink\" title=\"创建版本库\"></a>创建版本库</h2><pre><code>git init\n</code></pre><p>初始化一个git仓库。</p>\n<pre><code>git add &lt;file&gt;\n</code></pre><p>添加文件到暂存区。</p>\n<pre><code>git commit -m &quot;message&quot;\n</code></pre><p>把之前<code>git add</code>的文件提交到仓库，可以add多个文件，然后执行一次commit。</p>\n<blockquote>\n<p>SVN上<code>add</code>之后直接就添加到版本库了，但是Git上还需要<code>commit</code>才行，注意SVN与Git之间<code>commit</code>与<code>add</code>的异同。</p>\n</blockquote>\n<h2 id=\"查看版本库的状态\"><a href=\"#查看版本库的状态\" class=\"headerlink\" title=\"查看版本库的状态\"></a>查看版本库的状态</h2><pre><code>git status\n</code></pre><p>查看当前工作区的状态。</p>\n<pre><code>git diff\n</code></pre><p>查看difference，显示的格式是Unix通用的diff格式。</p>\n<blockquote>\n<p>简单来说<code>git status</code>命令可以知道哪些文件做了修改，<code>git diff</code>命令可以知道被修改了哪些内容。</p>\n</blockquote>\n<pre><code>git log\ngit log --pretty=oneline\n</code></pre><p>显示从最近到最远的提交日志。</p>\n<blockquote>\n<p><code>commit id</code>是版本号，用 SHA1 十六进制表示</p>\n</blockquote>\n<h2 id=\"版本回退\"><a href=\"#版本回退\" class=\"headerlink\" title=\"版本回退\"></a>版本回退</h2><pre><code>git reset --hard HEAD^\ngit reset --hard HEAD~100\ngit reset --hard 3628164\n</code></pre><p><code>HEAD</code>表示当前版本，<code>HEAD^</code>表示当前版本的上一个版本，<code>~100</code>等同于100个<code>^</code>。<code>3628164</code>是版本号，版本号不用写全，Git中只要知道<code>commit id</code>就可以回退。</p>\n<pre><code>git reflog\n</code></pre><p>查看历史命令，通过历史命令可以知道版本号。</p>\n<blockquote>\n<p>需要提交的文件通通使用<code>git add</code>放到暂存区（stage），然后使用<code>git commit</code>一次性提交暂存区所有修改到分之。工作区（working diretory）是电脑里能看到的目录，版本库（repository）则是工作区中一个隐藏的文件夹<code>.git</code>。<br>git跟踪并管理的是修改，每次修改都需要<code>add</code>到暂存区，这样才能被<code>commit</code>到分支中。</p>\n</blockquote>\n<h2 id=\"管理修改\"><a href=\"#管理修改\" class=\"headerlink\" title=\"管理修改\"></a>管理修改</h2><pre><code>git checkout --file\n</code></pre><p>把file在工作区的修改全部撤销，也就是把这个文件回到最近一次<code>git commit</code>或者<code>git add</code>的状态（用版本库的版本替换工作区）。</p>\n<pre><code>git reset HEAD file\n</code></pre><p>把暂存区的修改回退到工作区，不会影响工作区的状态。</p>\n<pre><code>git rm file\n</code></pre><p>从版本库中删除某个文件。这个命令跟<code>git add</code>一样，需要<code>git commit</code>之后才能提交到版本库中。</p>\n<h2 id=\"分支管理\"><a href=\"#分支管理\" class=\"headerlink\" title=\"分支管理\"></a>分支管理</h2><h3 id=\"创建分支\"><a href=\"#创建分支\" class=\"headerlink\" title=\"创建分支\"></a>创建分支</h3><pre><code>git checkout -b dev\n</code></pre><p>创建并切换到dev分支，<code>-b</code>参数表示<strong>创建并切换</strong>，这个命令实际上是下面两个命令的结合。</p>\n<pre><code>git branch dev\ngit checkout dev \n</code></pre><p><code>git branch</code>是创建一个dev分支，<code>git checkout</code>则是切换到dev分支。</p>\n<pre><code>git branch\n</code></pre><p>查看当前分支，当前分支会标有一个*号。</p>\n<pre><code>git checkout master\n</code></pre><p>切换到master分支。</p>\n<pre><code>git merge dev\n</code></pre><p>合并指定分支到当前分支。</p>\n<pre><code>git branch -d dev\n</code></pre><p>删除指定分支。</p>\n<h3 id=\"解决冲突\"><a href=\"#解决冲突\" class=\"headerlink\" title=\"解决冲突\"></a>解决冲突</h3><p>当切换到master分支并尝试合并dev分支时，若有冲突存在，必须手动解决冲突再进行提交。</p>\n<p>Git用&lt;&lt;&lt;&lt;&lt;&lt;，======，&gt;&gt;&gt;&gt;&gt;&gt;标记处不同分支的内容。</p>\n<pre><code>git log --graph --pretty=oneline --abbrev-commit\n</code></pre><p>用带参数的<code>git log</code>命令可以看到分支的合并情况。</p>\n<blockquote>\n<p>当Git无法自动合并分支时，必须首先解决冲突，再提交。合并后用<code>git log --graph</code>可以看到分支合并图。</p>\n</blockquote>\n<h3 id=\"分支管理策略\"><a href=\"#分支管理策略\" class=\"headerlink\" title=\"分支管理策略\"></a>分支管理策略</h3><p>默认情况下，Git会用<code>Fast forward</code>模式合并分支，但这种情况下，删除分支会丢掉分支信息，会看不出来曾经做过合并</p>\n<pre><code>git merge --no-ff -m &quot;message&quot; dev\n</code></pre><p>本次合并会创建一个新的commit，通过<code>-m</code>把commit描述写进去，<code>--no-ff</code>表示禁用<code>Fast forward</code>。</p>\n<blockquote>\n<p><code>master</code>一般是最稳定的版本，用来发布新版本。<br>建立以个<code>dev</code>分支来进行协作，每个人都在<code>dev</code>分支上写代码，时不时向<code>dev</code>分支上提交，dev提交到<code>master</code>上来发布稳定版本。</p>\n</blockquote>\n<h3 id=\"Bug分支\"><a href=\"#Bug分支\" class=\"headerlink\" title=\"Bug分支\"></a>Bug分支</h3><pre><code>git stash\n</code></pre><p>可以把当前工作区存起来，等以后恢复现场继续工作。执行完后，工作区是clean的，可以拿来创建分支。</p>\n<pre><code>git checkout master\ngit checkout -b issue-101\n</code></pre><p>创建<code>issue-101</code>分支并修复Bug。</p>\n<pre><code>git stash list\n</code></pre><p>查看保存的工作区。</p>\n<pre><code>git stash apply\n</code></pre><p>恢复指定工作区。</p>\n<pre><code>git stash drop\n</code></pre><p>删除stash。</p>\n<pre><code>git stash pop\n</code></pre><p>恢复的同时会删除stash的内容。</p>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><p>git config 命令用来设置git的一些基本设置，包括全局配置以及针对特定仓库的配置。</p>\n<h3 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h3><h4 id=\"设置名字\"><a href=\"#设置名字\" class=\"headerlink\" title=\"设置名字\"></a>设置名字</h4><pre><code>git config user.name &lt;name&gt;\n</code></pre><p>设置当前仓库<code>commit</code>时作者的名字。</p>\n<pre><code>git config --global user.name &lt;name&gt;\n</code></pre><p>设置全局的作者名字，这样以后其他仓库<code>commit</code>时，都会以这个名字提交。</p>\n<h4 id=\"设置邮箱\"><a href=\"#设置邮箱\" class=\"headerlink\" title=\"设置邮箱\"></a>设置邮箱</h4><pre><code>git config --global user.email &lt;email&gt;\n</code></pre><p>设置全局的作者邮箱。</p>\n<p>例子：</p>\n<pre><code>git config --global user.name &quot;denight&quot;\ngit config --global user.email denight@qq.com\n</code></pre><h4 id=\"设置简写-别名\"><a href=\"#设置简写-别名\" class=\"headerlink\" title=\"设置简写/别名\"></a>设置简写/别名</h4><pre><code>git config --global alias.&lt;alias-name&gt; &lt;git-comman&gt;\n</code></pre><p>设置git命令的简写。比如<code>git status</code>可以通过下面的命令简写为<code>git st</code>。</p>\n<pre><code>git config --global alias.st status\n</code></pre><h3 id=\"更多\"><a href=\"#更多\" class=\"headerlink\" title=\"更多\"></a>更多</h3><p>Git把配置文件存储在三个不同的文件中，一个作用于当前仓库，一个作用于当前用户，一个作用于整个系统。</p>\n<ul>\n<li><repo>/.git/config 当前仓库的配置</repo></li>\n<li>~/.gitconfig 当前用户所属的配置，即—global的配置</li>\n<li>$(prefix)/etc/gitconfig 系统级别的配置</li>\n</ul>\n<p>优先级从高到底。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Git是一个分布式版本控制系统，相比集中式的版本控制系统，分布式版本控制系统每个人手上都是一个完整的版本库。</p>\n<h2 id=\"创建版本库\"><a href=\"#创建版本库\" class=\"headerlink\" title=\"创建版本库\"></a>创建版本库</h2><pre><code>git init\n</code></pre><p>初始化一个git仓库。</p>\n<pre><code>git add &lt;file&gt;\n</code></pre><p>添加文件到暂存区。</p>\n<pre><code>git commit -m &quot;message&quot;\n</code></pre><p>把之前<code>git add</code>的文件提交到仓库，可以add多个文件，然后执行一次commit。</p>\n<blockquote>\n<p>SVN上<code>add</code>之后直接就添加到版本库了，但是Git上还需要<code>commit</code>才行，注意SVN与Git之间<code>commit</code>与<code>add</code>的异同。</p>\n</blockquote>\n<h2 id=\"查看版本库的状态\"><a href=\"#查看版本库的状态\" class=\"headerlink\" title=\"查看版本库的状态\"></a>查看版本库的状态</h2><pre><code>git status\n</code></pre><p>查看当前工作区的状态。</p>\n<pre><code>git diff\n</code></pre><p>查看difference，显示的格式是Unix通用的diff格式。</p>\n<blockquote>\n<p>简单来说<code>git status</code>命令可以知道哪些文件做了修改，<code>git diff</code>命令可以知道被修改了哪些内容。</p>\n</blockquote>\n<pre><code>git log\ngit log --pretty=oneline\n</code></pre><p>显示从最近到最远的提交日志。</p>\n<blockquote>\n<p><code>commit id</code>是版本号，用 SHA1 十六进制表示</p>\n</blockquote>\n<h2 id=\"版本回退\"><a href=\"#版本回退\" class=\"headerlink\" title=\"版本回退\"></a>版本回退</h2><pre><code>git reset --hard HEAD^\ngit reset --hard HEAD~100\ngit reset --hard 3628164\n</code></pre><p><code>HEAD</code>表示当前版本，<code>HEAD^</code>表示当前版本的上一个版本，<code>~100</code>等同于100个<code>^</code>。<code>3628164</code>是版本号，版本号不用写全，Git中只要知道<code>commit id</code>就可以回退。</p>\n<pre><code>git reflog\n</code></pre><p>查看历史命令，通过历史命令可以知道版本号。</p>\n<blockquote>\n<p>需要提交的文件通通使用<code>git add</code>放到暂存区（stage），然后使用<code>git commit</code>一次性提交暂存区所有修改到分之。工作区（working diretory）是电脑里能看到的目录，版本库（repository）则是工作区中一个隐藏的文件夹<code>.git</code>。<br>git跟踪并管理的是修改，每次修改都需要<code>add</code>到暂存区，这样才能被<code>commit</code>到分支中。</p>\n</blockquote>\n<h2 id=\"管理修改\"><a href=\"#管理修改\" class=\"headerlink\" title=\"管理修改\"></a>管理修改</h2><pre><code>git checkout --file\n</code></pre><p>把file在工作区的修改全部撤销，也就是把这个文件回到最近一次<code>git commit</code>或者<code>git add</code>的状态（用版本库的版本替换工作区）。</p>\n<pre><code>git reset HEAD file\n</code></pre><p>把暂存区的修改回退到工作区，不会影响工作区的状态。</p>\n<pre><code>git rm file\n</code></pre><p>从版本库中删除某个文件。这个命令跟<code>git add</code>一样，需要<code>git commit</code>之后才能提交到版本库中。</p>\n<h2 id=\"分支管理\"><a href=\"#分支管理\" class=\"headerlink\" title=\"分支管理\"></a>分支管理</h2><h3 id=\"创建分支\"><a href=\"#创建分支\" class=\"headerlink\" title=\"创建分支\"></a>创建分支</h3><pre><code>git checkout -b dev\n</code></pre><p>创建并切换到dev分支，<code>-b</code>参数表示<strong>创建并切换</strong>，这个命令实际上是下面两个命令的结合。</p>\n<pre><code>git branch dev\ngit checkout dev \n</code></pre><p><code>git branch</code>是创建一个dev分支，<code>git checkout</code>则是切换到dev分支。</p>\n<pre><code>git branch\n</code></pre><p>查看当前分支，当前分支会标有一个*号。</p>\n<pre><code>git checkout master\n</code></pre><p>切换到master分支。</p>\n<pre><code>git merge dev\n</code></pre><p>合并指定分支到当前分支。</p>\n<pre><code>git branch -d dev\n</code></pre><p>删除指定分支。</p>\n<h3 id=\"解决冲突\"><a href=\"#解决冲突\" class=\"headerlink\" title=\"解决冲突\"></a>解决冲突</h3><p>当切换到master分支并尝试合并dev分支时，若有冲突存在，必须手动解决冲突再进行提交。</p>\n<p>Git用&lt;&lt;&lt;&lt;&lt;&lt;，======，&gt;&gt;&gt;&gt;&gt;&gt;标记处不同分支的内容。</p>\n<pre><code>git log --graph --pretty=oneline --abbrev-commit\n</code></pre><p>用带参数的<code>git log</code>命令可以看到分支的合并情况。</p>\n<blockquote>\n<p>当Git无法自动合并分支时，必须首先解决冲突，再提交。合并后用<code>git log --graph</code>可以看到分支合并图。</p>\n</blockquote>\n<h3 id=\"分支管理策略\"><a href=\"#分支管理策略\" class=\"headerlink\" title=\"分支管理策略\"></a>分支管理策略</h3><p>默认情况下，Git会用<code>Fast forward</code>模式合并分支，但这种情况下，删除分支会丢掉分支信息，会看不出来曾经做过合并</p>\n<pre><code>git merge --no-ff -m &quot;message&quot; dev\n</code></pre><p>本次合并会创建一个新的commit，通过<code>-m</code>把commit描述写进去，<code>--no-ff</code>表示禁用<code>Fast forward</code>。</p>\n<blockquote>\n<p><code>master</code>一般是最稳定的版本，用来发布新版本。<br>建立以个<code>dev</code>分支来进行协作，每个人都在<code>dev</code>分支上写代码，时不时向<code>dev</code>分支上提交，dev提交到<code>master</code>上来发布稳定版本。</p>\n</blockquote>\n<h3 id=\"Bug分支\"><a href=\"#Bug分支\" class=\"headerlink\" title=\"Bug分支\"></a>Bug分支</h3><pre><code>git stash\n</code></pre><p>可以把当前工作区存起来，等以后恢复现场继续工作。执行完后，工作区是clean的，可以拿来创建分支。</p>\n<pre><code>git checkout master\ngit checkout -b issue-101\n</code></pre><p>创建<code>issue-101</code>分支并修复Bug。</p>\n<pre><code>git stash list\n</code></pre><p>查看保存的工作区。</p>\n<pre><code>git stash apply\n</code></pre><p>恢复指定工作区。</p>\n<pre><code>git stash drop\n</code></pre><p>删除stash。</p>\n<pre><code>git stash pop\n</code></pre><p>恢复的同时会删除stash的内容。</p>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><p>git config 命令用来设置git的一些基本设置，包括全局配置以及针对特定仓库的配置。</p>\n<h3 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h3><h4 id=\"设置名字\"><a href=\"#设置名字\" class=\"headerlink\" title=\"设置名字\"></a>设置名字</h4><pre><code>git config user.name &lt;name&gt;\n</code></pre><p>设置当前仓库<code>commit</code>时作者的名字。</p>\n<pre><code>git config --global user.name &lt;name&gt;\n</code></pre><p>设置全局的作者名字，这样以后其他仓库<code>commit</code>时，都会以这个名字提交。</p>\n<h4 id=\"设置邮箱\"><a href=\"#设置邮箱\" class=\"headerlink\" title=\"设置邮箱\"></a>设置邮箱</h4><pre><code>git config --global user.email &lt;email&gt;\n</code></pre><p>设置全局的作者邮箱。</p>\n<p>例子：</p>\n<pre><code>git config --global user.name &quot;denight&quot;\ngit config --global user.email denight@qq.com\n</code></pre><h4 id=\"设置简写-别名\"><a href=\"#设置简写-别名\" class=\"headerlink\" title=\"设置简写/别名\"></a>设置简写/别名</h4><pre><code>git config --global alias.&lt;alias-name&gt; &lt;git-comman&gt;\n</code></pre><p>设置git命令的简写。比如<code>git status</code>可以通过下面的命令简写为<code>git st</code>。</p>\n<pre><code>git config --global alias.st status\n</code></pre><h3 id=\"更多\"><a href=\"#更多\" class=\"headerlink\" title=\"更多\"></a>更多</h3><p>Git把配置文件存储在三个不同的文件中，一个作用于当前仓库，一个作用于当前用户，一个作用于整个系统。</p>\n<ul>\n<li><repo>/.git/config 当前仓库的配置</repo></li>\n<li>~/.gitconfig 当前用户所属的配置，即—global的配置</li>\n<li>$(prefix)/etc/gitconfig 系统级别的配置</li>\n</ul>\n<p>优先级从高到底。</p>\n"},{"layout":"post","title":"CSS：如何去除 inline-block 带来的空白间距","date":"2017-04-01T12:00:00.000Z","_content":"## 1、使用负margin\n\n```\n<ul>\n    <li>item</li>\n    <li>item</li>\n    <li>item</li>\n</ul>\n```\n\n```\nul {\n    list-style:none;\n}\nli {\n    display: inline-block;\n    margin-left: -4px;\n}\n```\n\n## 2、改变HTML结构，把li标签写在同一行\n\n```\n<ul>\n    <li>item</li><li>item</li><li>item</li>\n</ul>\n```\n\n## 3、父元素中设置字体大小为0\n\n```\n<ul>\n    <li>item</li>\n    <li>item</li>\n    <li>item</li>\n</ul>\n```\n\n```\nul {\n    list-style: none;\n    font-size: 0;\n}\nli {\n    display: inline-block;\n    font-size: 16px;\n}\n```\n\n\n\n","source":"_posts/2017-04-01-CSS：如何去除 inline-block 带来的空白间距.md","raw":"---\nlayout: post\ntitle:  \"CSS：如何去除 inline-block 带来的空白间距\"\ndate:   2017-04-01 20:00:00 +0800\ntags: css\n---\n## 1、使用负margin\n\n```\n<ul>\n    <li>item</li>\n    <li>item</li>\n    <li>item</li>\n</ul>\n```\n\n```\nul {\n    list-style:none;\n}\nli {\n    display: inline-block;\n    margin-left: -4px;\n}\n```\n\n## 2、改变HTML结构，把li标签写在同一行\n\n```\n<ul>\n    <li>item</li><li>item</li><li>item</li>\n</ul>\n```\n\n## 3、父元素中设置字体大小为0\n\n```\n<ul>\n    <li>item</li>\n    <li>item</li>\n    <li>item</li>\n</ul>\n```\n\n```\nul {\n    list-style: none;\n    font-size: 0;\n}\nli {\n    display: inline-block;\n    font-size: 16px;\n}\n```\n\n\n\n","slug":"2017-04-01-CSS：如何去除 inline-block 带来的空白间距","published":1,"updated":"2017-08-06T12:14:37.000Z","_id":"cj60bzxki00051dorbpu9nox6","comments":1,"photos":[],"link":"","content":"<h2 id=\"1、使用负margin\"><a href=\"#1、使用负margin\" class=\"headerlink\" title=\"1、使用负margin\"></a>1、使用负margin</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;ul&gt;</div><div class=\"line\">    &lt;li&gt;item&lt;/li&gt;</div><div class=\"line\">    &lt;li&gt;item&lt;/li&gt;</div><div class=\"line\">    &lt;li&gt;item&lt;/li&gt;</div><div class=\"line\">&lt;/ul&gt;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">ul &#123;</div><div class=\"line\">    list-style:none;</div><div class=\"line\">&#125;</div><div class=\"line\">li &#123;</div><div class=\"line\">    display: inline-block;</div><div class=\"line\">    margin-left: -4px;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"2、改变HTML结构，把li标签写在同一行\"><a href=\"#2、改变HTML结构，把li标签写在同一行\" class=\"headerlink\" title=\"2、改变HTML结构，把li标签写在同一行\"></a>2、改变HTML结构，把li标签写在同一行</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;ul&gt;</div><div class=\"line\">    &lt;li&gt;item&lt;/li&gt;&lt;li&gt;item&lt;/li&gt;&lt;li&gt;item&lt;/li&gt;</div><div class=\"line\">&lt;/ul&gt;</div></pre></td></tr></table></figure>\n<h2 id=\"3、父元素中设置字体大小为0\"><a href=\"#3、父元素中设置字体大小为0\" class=\"headerlink\" title=\"3、父元素中设置字体大小为0\"></a>3、父元素中设置字体大小为0</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;ul&gt;</div><div class=\"line\">    &lt;li&gt;item&lt;/li&gt;</div><div class=\"line\">    &lt;li&gt;item&lt;/li&gt;</div><div class=\"line\">    &lt;li&gt;item&lt;/li&gt;</div><div class=\"line\">&lt;/ul&gt;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">ul &#123;</div><div class=\"line\">    list-style: none;</div><div class=\"line\">    font-size: 0;</div><div class=\"line\">&#125;</div><div class=\"line\">li &#123;</div><div class=\"line\">    display: inline-block;</div><div class=\"line\">    font-size: 16px;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1、使用负margin\"><a href=\"#1、使用负margin\" class=\"headerlink\" title=\"1、使用负margin\"></a>1、使用负margin</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;ul&gt;</div><div class=\"line\">    &lt;li&gt;item&lt;/li&gt;</div><div class=\"line\">    &lt;li&gt;item&lt;/li&gt;</div><div class=\"line\">    &lt;li&gt;item&lt;/li&gt;</div><div class=\"line\">&lt;/ul&gt;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">ul &#123;</div><div class=\"line\">    list-style:none;</div><div class=\"line\">&#125;</div><div class=\"line\">li &#123;</div><div class=\"line\">    display: inline-block;</div><div class=\"line\">    margin-left: -4px;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"2、改变HTML结构，把li标签写在同一行\"><a href=\"#2、改变HTML结构，把li标签写在同一行\" class=\"headerlink\" title=\"2、改变HTML结构，把li标签写在同一行\"></a>2、改变HTML结构，把li标签写在同一行</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;ul&gt;</div><div class=\"line\">    &lt;li&gt;item&lt;/li&gt;&lt;li&gt;item&lt;/li&gt;&lt;li&gt;item&lt;/li&gt;</div><div class=\"line\">&lt;/ul&gt;</div></pre></td></tr></table></figure>\n<h2 id=\"3、父元素中设置字体大小为0\"><a href=\"#3、父元素中设置字体大小为0\" class=\"headerlink\" title=\"3、父元素中设置字体大小为0\"></a>3、父元素中设置字体大小为0</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;ul&gt;</div><div class=\"line\">    &lt;li&gt;item&lt;/li&gt;</div><div class=\"line\">    &lt;li&gt;item&lt;/li&gt;</div><div class=\"line\">    &lt;li&gt;item&lt;/li&gt;</div><div class=\"line\">&lt;/ul&gt;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">ul &#123;</div><div class=\"line\">    list-style: none;</div><div class=\"line\">    font-size: 0;</div><div class=\"line\">&#125;</div><div class=\"line\">li &#123;</div><div class=\"line\">    display: inline-block;</div><div class=\"line\">    font-size: 16px;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n"},{"layout":"post","title":"CSS：那些居中的方法们","date":"2017-04-01T12:00:00.000Z","_content":"## 水平居中\n\n### 1、宽度已知，使用margin\n\n```\n<div>\n    <div class=\"center\">需要居中的元素</div>\n</div>\n```\n\n```\n.center {\n    width: 100px;\n    margin: 0 auto;\n}\n```\n\n### 2、宽度不定，使用text-align + inline-block\n\n```\n<div class=\"wrapper\">\n    <div class=\"center\">需要居中的元素</divß>\n</div>\n```\n\n```\n.wrapper {\n    text-align: center;\n}\n.center {\n    display:inline-block;\n}\n```\n\n### 3、宽度不定，使用弹性盒子\n\n```\n<div class=\"wrapper\">\n    <div>需要居中的元素</div>\n</div>\n```\n\n```\n.wrapper {\n    display: flex;\n    justify-content: center;\n}\n```\n\n### 4、宽度已知，使用绝对定位\n\n```\n<div class=\"wrapper\">\n    <div class=\"center\">需要居中的元素</div>\n</div>\n```\n\n```\n.wrapper {\n    position: relative;\n}\n.center {\n    postion: absolute;\n    width: 100px;\n    left:50%;\n    margin-left:-50px;\n}\n```\n\n## 完全居中\n\n### 1、完全居中\n\n```\n<div class=\"wrapper\">\n    <div class=\"center\">需要居中的元素</div>\n</div>\n```\n\n```\n.wrapper {\n    height:200px;\n    position: relative;\n}\n.center {\n    height: 50%;\n    width: 50%;\n    margin: auto;\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    left: 0;\n    right: 0；\n}\n```\n\n### 2、使用负margin\n\n```\n<div class=\"wrapper\">\n    <div class=\"center\">需要居中的元素</div>\n</div>\n```\n\n```\n.warpper {\n    height: 200px;\n    position: relative;\n}\n.center {\n    width: 100px;\n    height: 100px;\n    margin: auto;\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    margin-top: -50px;\n    margin-left: -50px;\n}\n```\n\n优点：兼容IE6-7；\n\n缺点：不能使用百分比的大小，内容高度不可变；内容可能会超出容器；\n\n### 3、使用transform\n\n```\n<div class=\"wrapper\">\n    <div class=\"center\">需要居中的元素</div>\n</div>\n```\n\n```\n.wrapper {\n    height: 200px;\n    postion: relative;\n}\n.center {\n    height: 50%;\n    width: 50%;\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    transform:translate(-50%,-50%);\n}\n```\n\n优点：内容高度可变；\n\n缺点：不兼容IE8；会和其他transform样式有冲突；\n\n### 4、使用table-cell\n\n```\n<div class=\"table\">\n    <div class=\"table-cell\">\n        <div class=\"center\">需要居中的元素</div>\n    </div>\n</div>\n```\n\n```\n.table {\n    display: table;\n    width: 100%;\n}\n.table-cell {\n    display: table-cell;\n    vertical-align: middle;\n    height: 200px;\n}\n.center {\n    width: 50%;\n    margin: 0 auto;\n}\n```\n\n优点：内容高度可变；能自动撑开父元素；浏览器兼容性好；\n\n缺点：需要额外的HTML标签；\n\n### 5、使用flex-box\n\n```\n<div class=\"wrapper\">\n    <div>需要居中的元素</div>\n</div>\n```\n\n```\n.wrapper {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    height: 200px;\n}\n```\n\n优点：内容高度可变；\n\n缺点：不支持IE8-9；\n\n","source":"_posts/2017-04-01-CSS：那些居中的方法们.md","raw":"---\nlayout: post\ntitle:  \"CSS：那些居中的方法们\"\ndate:   2017-04-01 20:00:00 +0800\ntags: css\n---\n## 水平居中\n\n### 1、宽度已知，使用margin\n\n```\n<div>\n    <div class=\"center\">需要居中的元素</div>\n</div>\n```\n\n```\n.center {\n    width: 100px;\n    margin: 0 auto;\n}\n```\n\n### 2、宽度不定，使用text-align + inline-block\n\n```\n<div class=\"wrapper\">\n    <div class=\"center\">需要居中的元素</divß>\n</div>\n```\n\n```\n.wrapper {\n    text-align: center;\n}\n.center {\n    display:inline-block;\n}\n```\n\n### 3、宽度不定，使用弹性盒子\n\n```\n<div class=\"wrapper\">\n    <div>需要居中的元素</div>\n</div>\n```\n\n```\n.wrapper {\n    display: flex;\n    justify-content: center;\n}\n```\n\n### 4、宽度已知，使用绝对定位\n\n```\n<div class=\"wrapper\">\n    <div class=\"center\">需要居中的元素</div>\n</div>\n```\n\n```\n.wrapper {\n    position: relative;\n}\n.center {\n    postion: absolute;\n    width: 100px;\n    left:50%;\n    margin-left:-50px;\n}\n```\n\n## 完全居中\n\n### 1、完全居中\n\n```\n<div class=\"wrapper\">\n    <div class=\"center\">需要居中的元素</div>\n</div>\n```\n\n```\n.wrapper {\n    height:200px;\n    position: relative;\n}\n.center {\n    height: 50%;\n    width: 50%;\n    margin: auto;\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    left: 0;\n    right: 0；\n}\n```\n\n### 2、使用负margin\n\n```\n<div class=\"wrapper\">\n    <div class=\"center\">需要居中的元素</div>\n</div>\n```\n\n```\n.warpper {\n    height: 200px;\n    position: relative;\n}\n.center {\n    width: 100px;\n    height: 100px;\n    margin: auto;\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    margin-top: -50px;\n    margin-left: -50px;\n}\n```\n\n优点：兼容IE6-7；\n\n缺点：不能使用百分比的大小，内容高度不可变；内容可能会超出容器；\n\n### 3、使用transform\n\n```\n<div class=\"wrapper\">\n    <div class=\"center\">需要居中的元素</div>\n</div>\n```\n\n```\n.wrapper {\n    height: 200px;\n    postion: relative;\n}\n.center {\n    height: 50%;\n    width: 50%;\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    transform:translate(-50%,-50%);\n}\n```\n\n优点：内容高度可变；\n\n缺点：不兼容IE8；会和其他transform样式有冲突；\n\n### 4、使用table-cell\n\n```\n<div class=\"table\">\n    <div class=\"table-cell\">\n        <div class=\"center\">需要居中的元素</div>\n    </div>\n</div>\n```\n\n```\n.table {\n    display: table;\n    width: 100%;\n}\n.table-cell {\n    display: table-cell;\n    vertical-align: middle;\n    height: 200px;\n}\n.center {\n    width: 50%;\n    margin: 0 auto;\n}\n```\n\n优点：内容高度可变；能自动撑开父元素；浏览器兼容性好；\n\n缺点：需要额外的HTML标签；\n\n### 5、使用flex-box\n\n```\n<div class=\"wrapper\">\n    <div>需要居中的元素</div>\n</div>\n```\n\n```\n.wrapper {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    height: 200px;\n}\n```\n\n优点：内容高度可变；\n\n缺点：不支持IE8-9；\n\n","slug":"2017-04-01-CSS：那些居中的方法们","published":1,"updated":"2017-08-06T12:14:33.000Z","_id":"cj60bzxkl00071dor1qi3qqoh","comments":1,"photos":[],"link":"","content":"<h2 id=\"水平居中\"><a href=\"#水平居中\" class=\"headerlink\" title=\"水平居中\"></a>水平居中</h2><h3 id=\"1、宽度已知，使用margin\"><a href=\"#1、宽度已知，使用margin\" class=\"headerlink\" title=\"1、宽度已知，使用margin\"></a>1、宽度已知，使用margin</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div&gt;</div><div class=\"line\">    &lt;div class=&quot;center&quot;&gt;需要居中的元素&lt;/div&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">.center &#123;</div><div class=\"line\">    width: 100px;</div><div class=\"line\">    margin: 0 auto;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"2、宽度不定，使用text-align-inline-block\"><a href=\"#2、宽度不定，使用text-align-inline-block\" class=\"headerlink\" title=\"2、宽度不定，使用text-align + inline-block\"></a>2、宽度不定，使用text-align + inline-block</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div class=&quot;wrapper&quot;&gt;</div><div class=\"line\">    &lt;div class=&quot;center&quot;&gt;需要居中的元素&lt;/divß&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">.wrapper &#123;</div><div class=\"line\">    text-align: center;</div><div class=\"line\">&#125;</div><div class=\"line\">.center &#123;</div><div class=\"line\">    display:inline-block;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"3、宽度不定，使用弹性盒子\"><a href=\"#3、宽度不定，使用弹性盒子\" class=\"headerlink\" title=\"3、宽度不定，使用弹性盒子\"></a>3、宽度不定，使用弹性盒子</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div class=&quot;wrapper&quot;&gt;</div><div class=\"line\">    &lt;div&gt;需要居中的元素&lt;/div&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">.wrapper &#123;</div><div class=\"line\">    display: flex;</div><div class=\"line\">    justify-content: center;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"4、宽度已知，使用绝对定位\"><a href=\"#4、宽度已知，使用绝对定位\" class=\"headerlink\" title=\"4、宽度已知，使用绝对定位\"></a>4、宽度已知，使用绝对定位</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div class=&quot;wrapper&quot;&gt;</div><div class=\"line\">    &lt;div class=&quot;center&quot;&gt;需要居中的元素&lt;/div&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">.wrapper &#123;</div><div class=\"line\">    position: relative;</div><div class=\"line\">&#125;</div><div class=\"line\">.center &#123;</div><div class=\"line\">    postion: absolute;</div><div class=\"line\">    width: 100px;</div><div class=\"line\">    left:50%;</div><div class=\"line\">    margin-left:-50px;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"完全居中\"><a href=\"#完全居中\" class=\"headerlink\" title=\"完全居中\"></a>完全居中</h2><h3 id=\"1、完全居中\"><a href=\"#1、完全居中\" class=\"headerlink\" title=\"1、完全居中\"></a>1、完全居中</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div class=&quot;wrapper&quot;&gt;</div><div class=\"line\">    &lt;div class=&quot;center&quot;&gt;需要居中的元素&lt;/div&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">.wrapper &#123;</div><div class=\"line\">    height:200px;</div><div class=\"line\">    position: relative;</div><div class=\"line\">&#125;</div><div class=\"line\">.center &#123;</div><div class=\"line\">    height: 50%;</div><div class=\"line\">    width: 50%;</div><div class=\"line\">    margin: auto;</div><div class=\"line\">    position: absolute;</div><div class=\"line\">    top: 0;</div><div class=\"line\">    bottom: 0;</div><div class=\"line\">    left: 0;</div><div class=\"line\">    right: 0；</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"2、使用负margin\"><a href=\"#2、使用负margin\" class=\"headerlink\" title=\"2、使用负margin\"></a>2、使用负margin</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div class=&quot;wrapper&quot;&gt;</div><div class=\"line\">    &lt;div class=&quot;center&quot;&gt;需要居中的元素&lt;/div&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">.warpper &#123;</div><div class=\"line\">    height: 200px;</div><div class=\"line\">    position: relative;</div><div class=\"line\">&#125;</div><div class=\"line\">.center &#123;</div><div class=\"line\">    width: 100px;</div><div class=\"line\">    height: 100px;</div><div class=\"line\">    margin: auto;</div><div class=\"line\">    position: absolute;</div><div class=\"line\">    top: 50%;</div><div class=\"line\">    left: 50%;</div><div class=\"line\">    margin-top: -50px;</div><div class=\"line\">    margin-left: -50px;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>优点：兼容IE6-7；</p>\n<p>缺点：不能使用百分比的大小，内容高度不可变；内容可能会超出容器；</p>\n<h3 id=\"3、使用transform\"><a href=\"#3、使用transform\" class=\"headerlink\" title=\"3、使用transform\"></a>3、使用transform</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div class=&quot;wrapper&quot;&gt;</div><div class=\"line\">    &lt;div class=&quot;center&quot;&gt;需要居中的元素&lt;/div&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">.wrapper &#123;</div><div class=\"line\">    height: 200px;</div><div class=\"line\">    postion: relative;</div><div class=\"line\">&#125;</div><div class=\"line\">.center &#123;</div><div class=\"line\">    height: 50%;</div><div class=\"line\">    width: 50%;</div><div class=\"line\">    position: absolute;</div><div class=\"line\">    top: 50%;</div><div class=\"line\">    left: 50%;</div><div class=\"line\">    transform:translate(-50%,-50%);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>优点：内容高度可变；</p>\n<p>缺点：不兼容IE8；会和其他transform样式有冲突；</p>\n<h3 id=\"4、使用table-cell\"><a href=\"#4、使用table-cell\" class=\"headerlink\" title=\"4、使用table-cell\"></a>4、使用table-cell</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div class=&quot;table&quot;&gt;</div><div class=\"line\">    &lt;div class=&quot;table-cell&quot;&gt;</div><div class=\"line\">        &lt;div class=&quot;center&quot;&gt;需要居中的元素&lt;/div&gt;</div><div class=\"line\">    &lt;/div&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">.table &#123;</div><div class=\"line\">    display: table;</div><div class=\"line\">    width: 100%;</div><div class=\"line\">&#125;</div><div class=\"line\">.table-cell &#123;</div><div class=\"line\">    display: table-cell;</div><div class=\"line\">    vertical-align: middle;</div><div class=\"line\">    height: 200px;</div><div class=\"line\">&#125;</div><div class=\"line\">.center &#123;</div><div class=\"line\">    width: 50%;</div><div class=\"line\">    margin: 0 auto;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>优点：内容高度可变；能自动撑开父元素；浏览器兼容性好；</p>\n<p>缺点：需要额外的HTML标签；</p>\n<h3 id=\"5、使用flex-box\"><a href=\"#5、使用flex-box\" class=\"headerlink\" title=\"5、使用flex-box\"></a>5、使用flex-box</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div class=&quot;wrapper&quot;&gt;</div><div class=\"line\">    &lt;div&gt;需要居中的元素&lt;/div&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">.wrapper &#123;</div><div class=\"line\">    display: flex;</div><div class=\"line\">    align-items: center;</div><div class=\"line\">    justify-content: center;</div><div class=\"line\">    height: 200px;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>优点：内容高度可变；</p>\n<p>缺点：不支持IE8-9；</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"水平居中\"><a href=\"#水平居中\" class=\"headerlink\" title=\"水平居中\"></a>水平居中</h2><h3 id=\"1、宽度已知，使用margin\"><a href=\"#1、宽度已知，使用margin\" class=\"headerlink\" title=\"1、宽度已知，使用margin\"></a>1、宽度已知，使用margin</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div&gt;</div><div class=\"line\">    &lt;div class=&quot;center&quot;&gt;需要居中的元素&lt;/div&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">.center &#123;</div><div class=\"line\">    width: 100px;</div><div class=\"line\">    margin: 0 auto;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"2、宽度不定，使用text-align-inline-block\"><a href=\"#2、宽度不定，使用text-align-inline-block\" class=\"headerlink\" title=\"2、宽度不定，使用text-align + inline-block\"></a>2、宽度不定，使用text-align + inline-block</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div class=&quot;wrapper&quot;&gt;</div><div class=\"line\">    &lt;div class=&quot;center&quot;&gt;需要居中的元素&lt;/divß&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">.wrapper &#123;</div><div class=\"line\">    text-align: center;</div><div class=\"line\">&#125;</div><div class=\"line\">.center &#123;</div><div class=\"line\">    display:inline-block;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"3、宽度不定，使用弹性盒子\"><a href=\"#3、宽度不定，使用弹性盒子\" class=\"headerlink\" title=\"3、宽度不定，使用弹性盒子\"></a>3、宽度不定，使用弹性盒子</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div class=&quot;wrapper&quot;&gt;</div><div class=\"line\">    &lt;div&gt;需要居中的元素&lt;/div&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">.wrapper &#123;</div><div class=\"line\">    display: flex;</div><div class=\"line\">    justify-content: center;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"4、宽度已知，使用绝对定位\"><a href=\"#4、宽度已知，使用绝对定位\" class=\"headerlink\" title=\"4、宽度已知，使用绝对定位\"></a>4、宽度已知，使用绝对定位</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div class=&quot;wrapper&quot;&gt;</div><div class=\"line\">    &lt;div class=&quot;center&quot;&gt;需要居中的元素&lt;/div&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">.wrapper &#123;</div><div class=\"line\">    position: relative;</div><div class=\"line\">&#125;</div><div class=\"line\">.center &#123;</div><div class=\"line\">    postion: absolute;</div><div class=\"line\">    width: 100px;</div><div class=\"line\">    left:50%;</div><div class=\"line\">    margin-left:-50px;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"完全居中\"><a href=\"#完全居中\" class=\"headerlink\" title=\"完全居中\"></a>完全居中</h2><h3 id=\"1、完全居中\"><a href=\"#1、完全居中\" class=\"headerlink\" title=\"1、完全居中\"></a>1、完全居中</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div class=&quot;wrapper&quot;&gt;</div><div class=\"line\">    &lt;div class=&quot;center&quot;&gt;需要居中的元素&lt;/div&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">.wrapper &#123;</div><div class=\"line\">    height:200px;</div><div class=\"line\">    position: relative;</div><div class=\"line\">&#125;</div><div class=\"line\">.center &#123;</div><div class=\"line\">    height: 50%;</div><div class=\"line\">    width: 50%;</div><div class=\"line\">    margin: auto;</div><div class=\"line\">    position: absolute;</div><div class=\"line\">    top: 0;</div><div class=\"line\">    bottom: 0;</div><div class=\"line\">    left: 0;</div><div class=\"line\">    right: 0；</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"2、使用负margin\"><a href=\"#2、使用负margin\" class=\"headerlink\" title=\"2、使用负margin\"></a>2、使用负margin</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div class=&quot;wrapper&quot;&gt;</div><div class=\"line\">    &lt;div class=&quot;center&quot;&gt;需要居中的元素&lt;/div&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">.warpper &#123;</div><div class=\"line\">    height: 200px;</div><div class=\"line\">    position: relative;</div><div class=\"line\">&#125;</div><div class=\"line\">.center &#123;</div><div class=\"line\">    width: 100px;</div><div class=\"line\">    height: 100px;</div><div class=\"line\">    margin: auto;</div><div class=\"line\">    position: absolute;</div><div class=\"line\">    top: 50%;</div><div class=\"line\">    left: 50%;</div><div class=\"line\">    margin-top: -50px;</div><div class=\"line\">    margin-left: -50px;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>优点：兼容IE6-7；</p>\n<p>缺点：不能使用百分比的大小，内容高度不可变；内容可能会超出容器；</p>\n<h3 id=\"3、使用transform\"><a href=\"#3、使用transform\" class=\"headerlink\" title=\"3、使用transform\"></a>3、使用transform</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div class=&quot;wrapper&quot;&gt;</div><div class=\"line\">    &lt;div class=&quot;center&quot;&gt;需要居中的元素&lt;/div&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">.wrapper &#123;</div><div class=\"line\">    height: 200px;</div><div class=\"line\">    postion: relative;</div><div class=\"line\">&#125;</div><div class=\"line\">.center &#123;</div><div class=\"line\">    height: 50%;</div><div class=\"line\">    width: 50%;</div><div class=\"line\">    position: absolute;</div><div class=\"line\">    top: 50%;</div><div class=\"line\">    left: 50%;</div><div class=\"line\">    transform:translate(-50%,-50%);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>优点：内容高度可变；</p>\n<p>缺点：不兼容IE8；会和其他transform样式有冲突；</p>\n<h3 id=\"4、使用table-cell\"><a href=\"#4、使用table-cell\" class=\"headerlink\" title=\"4、使用table-cell\"></a>4、使用table-cell</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div class=&quot;table&quot;&gt;</div><div class=\"line\">    &lt;div class=&quot;table-cell&quot;&gt;</div><div class=\"line\">        &lt;div class=&quot;center&quot;&gt;需要居中的元素&lt;/div&gt;</div><div class=\"line\">    &lt;/div&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">.table &#123;</div><div class=\"line\">    display: table;</div><div class=\"line\">    width: 100%;</div><div class=\"line\">&#125;</div><div class=\"line\">.table-cell &#123;</div><div class=\"line\">    display: table-cell;</div><div class=\"line\">    vertical-align: middle;</div><div class=\"line\">    height: 200px;</div><div class=\"line\">&#125;</div><div class=\"line\">.center &#123;</div><div class=\"line\">    width: 50%;</div><div class=\"line\">    margin: 0 auto;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>优点：内容高度可变；能自动撑开父元素；浏览器兼容性好；</p>\n<p>缺点：需要额外的HTML标签；</p>\n<h3 id=\"5、使用flex-box\"><a href=\"#5、使用flex-box\" class=\"headerlink\" title=\"5、使用flex-box\"></a>5、使用flex-box</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div class=&quot;wrapper&quot;&gt;</div><div class=\"line\">    &lt;div&gt;需要居中的元素&lt;/div&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">.wrapper &#123;</div><div class=\"line\">    display: flex;</div><div class=\"line\">    align-items: center;</div><div class=\"line\">    justify-content: center;</div><div class=\"line\">    height: 200px;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>优点：内容高度可变；</p>\n<p>缺点：不支持IE8-9；</p>\n"},{"layout":"post","title":"CSS：line-height 不同取值的差异","date":"2017-04-02T12:00:00.000Z","_content":"\n## 百分比值\n\n> line-height = （父元素 font-size）×（百分比）\n\n```\n<div class=\"outer\">\n    父元素\n    <div class=\"inner\">子元素</div>\n</div>\n```\n\n```\n.outer {\n    /* 父元素行高 = 父元素font-size 30px × 150% = 45px */\n    line-height: 150%;\n    font-size: 30px;\n}\n.inner {\n    /* 子元素行高 = 父元素font-size 30px × 150% = 45px */\n    font-size: 20px; \n}\n```\n\n## em值\n\n> line-height = （父元素 font-size）×（em值）\n\n```\n.outer {\n    /* 父元素行高 = 父元素font-size 30px × 1.5 = 45px */\n    line-height: 1.5em;\n    font-size: 30px;\n}\n.inner {\n    /* 子元素行高 = 父元素font-size 30px × 1.5 = 45px */\n    font-size: 20px;\n}\n```\n\n这里特别要注意尽管em是相对当前元素的`font-size`值来计算的，同时`line-height`也是可以被继承的属性，但是实际上子元素继承时并不是`line-height: 1.5em`，而是父元素计算完成后的`line-height: 45px;`\n\n## 无单位数字\n\n> line-height = （当前元素 font-size）×（无单位数字）\n\n```\n.outer {\n    /* 父元素行高 = 父元素font-size 30px × 1.5 = 45px */\n    line-height: 1.5;\n    font-size: 30px;\n}\n.inner {\n    /* 子元素行高 = 子元素font-size 20px × 1.5 = 30px */\n    font-size: 20px;\n}\n```\n\n无单位数字与百分比值和em值相反，是根据当前元素的`font-size`来计算的。\n\n## 小结\n\n其实仔细观察会发现，百分比值和em值，在子元素继承父元素的`line-height`属性时，继承的是计算完成后（以px为单位）的值。而无单位数字，则是需要根据子元素的`font-size`，让子元素自行计算的。\n\n### 计算em值的大致流程：\n\n --&gt; 设置父元素font-size = 30px；\n\n --&gt; 设置父元素line-height = 1.5em;\n\n --&gt; 计算父元素line-height =  font-size × 1.5 = 30px × 1.5 = 45px; \n\n --&gt; 设置子元素font-size = 20px;\n\n --&gt; 计算子元素line-height = 继承父元素line-height = 45px; \n\n### 计算无单位数字的大致流程：\n\n--&gt; 设置父元素font-size = 30px;\n\n--&gt; 设置父元素line-height = 1.5;\n\n--&gt; 计算父元素line-height = 当前元素font-size × 1.5 = 30px × 1.5 = 45px;\n\n--&gt; 设置子元素font-size = 20px;\n\n--&gt; 计算子元素line-height = 继承父元素line-height = 1.5;\n\n--&gt; 计算实际子元素line-height = 当前元素font-size × 1.5 = 20px × 1.5 = 30px;\n\n","source":"_posts/2017-04-02-CSS：line-height 不同取值的差异.md","raw":"---\nlayout: post\ntitle:  \"CSS：line-height 不同取值的差异\"\ndate:   2017-04-02 20:00:00 +0800\ntags: css\n---\n\n## 百分比值\n\n> line-height = （父元素 font-size）×（百分比）\n\n```\n<div class=\"outer\">\n    父元素\n    <div class=\"inner\">子元素</div>\n</div>\n```\n\n```\n.outer {\n    /* 父元素行高 = 父元素font-size 30px × 150% = 45px */\n    line-height: 150%;\n    font-size: 30px;\n}\n.inner {\n    /* 子元素行高 = 父元素font-size 30px × 150% = 45px */\n    font-size: 20px; \n}\n```\n\n## em值\n\n> line-height = （父元素 font-size）×（em值）\n\n```\n.outer {\n    /* 父元素行高 = 父元素font-size 30px × 1.5 = 45px */\n    line-height: 1.5em;\n    font-size: 30px;\n}\n.inner {\n    /* 子元素行高 = 父元素font-size 30px × 1.5 = 45px */\n    font-size: 20px;\n}\n```\n\n这里特别要注意尽管em是相对当前元素的`font-size`值来计算的，同时`line-height`也是可以被继承的属性，但是实际上子元素继承时并不是`line-height: 1.5em`，而是父元素计算完成后的`line-height: 45px;`\n\n## 无单位数字\n\n> line-height = （当前元素 font-size）×（无单位数字）\n\n```\n.outer {\n    /* 父元素行高 = 父元素font-size 30px × 1.5 = 45px */\n    line-height: 1.5;\n    font-size: 30px;\n}\n.inner {\n    /* 子元素行高 = 子元素font-size 20px × 1.5 = 30px */\n    font-size: 20px;\n}\n```\n\n无单位数字与百分比值和em值相反，是根据当前元素的`font-size`来计算的。\n\n## 小结\n\n其实仔细观察会发现，百分比值和em值，在子元素继承父元素的`line-height`属性时，继承的是计算完成后（以px为单位）的值。而无单位数字，则是需要根据子元素的`font-size`，让子元素自行计算的。\n\n### 计算em值的大致流程：\n\n --&gt; 设置父元素font-size = 30px；\n\n --&gt; 设置父元素line-height = 1.5em;\n\n --&gt; 计算父元素line-height =  font-size × 1.5 = 30px × 1.5 = 45px; \n\n --&gt; 设置子元素font-size = 20px;\n\n --&gt; 计算子元素line-height = 继承父元素line-height = 45px; \n\n### 计算无单位数字的大致流程：\n\n--&gt; 设置父元素font-size = 30px;\n\n--&gt; 设置父元素line-height = 1.5;\n\n--&gt; 计算父元素line-height = 当前元素font-size × 1.5 = 30px × 1.5 = 45px;\n\n--&gt; 设置子元素font-size = 20px;\n\n--&gt; 计算子元素line-height = 继承父元素line-height = 1.5;\n\n--&gt; 计算实际子元素line-height = 当前元素font-size × 1.5 = 20px × 1.5 = 30px;\n\n","slug":"2017-04-02-CSS：line-height 不同取值的差异","published":1,"updated":"2017-08-06T12:14:40.000Z","_id":"cj60bzxkm00091doril276aun","comments":1,"photos":[],"link":"","content":"<h2 id=\"百分比值\"><a href=\"#百分比值\" class=\"headerlink\" title=\"百分比值\"></a>百分比值</h2><blockquote>\n<p>line-height = （父元素 font-size）×（百分比）</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div class=&quot;outer&quot;&gt;</div><div class=\"line\">    父元素</div><div class=\"line\">    &lt;div class=&quot;inner&quot;&gt;子元素&lt;/div&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">.outer &#123;</div><div class=\"line\">    /* 父元素行高 = 父元素font-size 30px × 150% = 45px */</div><div class=\"line\">    line-height: 150%;</div><div class=\"line\">    font-size: 30px;</div><div class=\"line\">&#125;</div><div class=\"line\">.inner &#123;</div><div class=\"line\">    /* 子元素行高 = 父元素font-size 30px × 150% = 45px */</div><div class=\"line\">    font-size: 20px; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"em值\"><a href=\"#em值\" class=\"headerlink\" title=\"em值\"></a>em值</h2><blockquote>\n<p>line-height = （父元素 font-size）×（em值）</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">.outer &#123;</div><div class=\"line\">    /* 父元素行高 = 父元素font-size 30px × 1.5 = 45px */</div><div class=\"line\">    line-height: 1.5em;</div><div class=\"line\">    font-size: 30px;</div><div class=\"line\">&#125;</div><div class=\"line\">.inner &#123;</div><div class=\"line\">    /* 子元素行高 = 父元素font-size 30px × 1.5 = 45px */</div><div class=\"line\">    font-size: 20px;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里特别要注意尽管em是相对当前元素的<code>font-size</code>值来计算的，同时<code>line-height</code>也是可以被继承的属性，但是实际上子元素继承时并不是<code>line-height: 1.5em</code>，而是父元素计算完成后的<code>line-height: 45px;</code></p>\n<h2 id=\"无单位数字\"><a href=\"#无单位数字\" class=\"headerlink\" title=\"无单位数字\"></a>无单位数字</h2><blockquote>\n<p>line-height = （当前元素 font-size）×（无单位数字）</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">.outer &#123;</div><div class=\"line\">    /* 父元素行高 = 父元素font-size 30px × 1.5 = 45px */</div><div class=\"line\">    line-height: 1.5;</div><div class=\"line\">    font-size: 30px;</div><div class=\"line\">&#125;</div><div class=\"line\">.inner &#123;</div><div class=\"line\">    /* 子元素行高 = 子元素font-size 20px × 1.5 = 30px */</div><div class=\"line\">    font-size: 20px;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>无单位数字与百分比值和em值相反，是根据当前元素的<code>font-size</code>来计算的。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>其实仔细观察会发现，百分比值和em值，在子元素继承父元素的<code>line-height</code>属性时，继承的是计算完成后（以px为单位）的值。而无单位数字，则是需要根据子元素的<code>font-size</code>，让子元素自行计算的。</p>\n<h3 id=\"计算em值的大致流程：\"><a href=\"#计算em值的大致流程：\" class=\"headerlink\" title=\"计算em值的大致流程：\"></a>计算em值的大致流程：</h3><p> –&gt; 设置父元素font-size = 30px；</p>\n<p> –&gt; 设置父元素line-height = 1.5em;</p>\n<p> –&gt; 计算父元素line-height =  font-size × 1.5 = 30px × 1.5 = 45px; </p>\n<p> –&gt; 设置子元素font-size = 20px;</p>\n<p> –&gt; 计算子元素line-height = 继承父元素line-height = 45px; </p>\n<h3 id=\"计算无单位数字的大致流程：\"><a href=\"#计算无单位数字的大致流程：\" class=\"headerlink\" title=\"计算无单位数字的大致流程：\"></a>计算无单位数字的大致流程：</h3><p>–&gt; 设置父元素font-size = 30px;</p>\n<p>–&gt; 设置父元素line-height = 1.5;</p>\n<p>–&gt; 计算父元素line-height = 当前元素font-size × 1.5 = 30px × 1.5 = 45px;</p>\n<p>–&gt; 设置子元素font-size = 20px;</p>\n<p>–&gt; 计算子元素line-height = 继承父元素line-height = 1.5;</p>\n<p>–&gt; 计算实际子元素line-height = 当前元素font-size × 1.5 = 20px × 1.5 = 30px;</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"百分比值\"><a href=\"#百分比值\" class=\"headerlink\" title=\"百分比值\"></a>百分比值</h2><blockquote>\n<p>line-height = （父元素 font-size）×（百分比）</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div class=&quot;outer&quot;&gt;</div><div class=\"line\">    父元素</div><div class=\"line\">    &lt;div class=&quot;inner&quot;&gt;子元素&lt;/div&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">.outer &#123;</div><div class=\"line\">    /* 父元素行高 = 父元素font-size 30px × 150% = 45px */</div><div class=\"line\">    line-height: 150%;</div><div class=\"line\">    font-size: 30px;</div><div class=\"line\">&#125;</div><div class=\"line\">.inner &#123;</div><div class=\"line\">    /* 子元素行高 = 父元素font-size 30px × 150% = 45px */</div><div class=\"line\">    font-size: 20px; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"em值\"><a href=\"#em值\" class=\"headerlink\" title=\"em值\"></a>em值</h2><blockquote>\n<p>line-height = （父元素 font-size）×（em值）</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">.outer &#123;</div><div class=\"line\">    /* 父元素行高 = 父元素font-size 30px × 1.5 = 45px */</div><div class=\"line\">    line-height: 1.5em;</div><div class=\"line\">    font-size: 30px;</div><div class=\"line\">&#125;</div><div class=\"line\">.inner &#123;</div><div class=\"line\">    /* 子元素行高 = 父元素font-size 30px × 1.5 = 45px */</div><div class=\"line\">    font-size: 20px;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里特别要注意尽管em是相对当前元素的<code>font-size</code>值来计算的，同时<code>line-height</code>也是可以被继承的属性，但是实际上子元素继承时并不是<code>line-height: 1.5em</code>，而是父元素计算完成后的<code>line-height: 45px;</code></p>\n<h2 id=\"无单位数字\"><a href=\"#无单位数字\" class=\"headerlink\" title=\"无单位数字\"></a>无单位数字</h2><blockquote>\n<p>line-height = （当前元素 font-size）×（无单位数字）</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">.outer &#123;</div><div class=\"line\">    /* 父元素行高 = 父元素font-size 30px × 1.5 = 45px */</div><div class=\"line\">    line-height: 1.5;</div><div class=\"line\">    font-size: 30px;</div><div class=\"line\">&#125;</div><div class=\"line\">.inner &#123;</div><div class=\"line\">    /* 子元素行高 = 子元素font-size 20px × 1.5 = 30px */</div><div class=\"line\">    font-size: 20px;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>无单位数字与百分比值和em值相反，是根据当前元素的<code>font-size</code>来计算的。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>其实仔细观察会发现，百分比值和em值，在子元素继承父元素的<code>line-height</code>属性时，继承的是计算完成后（以px为单位）的值。而无单位数字，则是需要根据子元素的<code>font-size</code>，让子元素自行计算的。</p>\n<h3 id=\"计算em值的大致流程：\"><a href=\"#计算em值的大致流程：\" class=\"headerlink\" title=\"计算em值的大致流程：\"></a>计算em值的大致流程：</h3><p> –&gt; 设置父元素font-size = 30px；</p>\n<p> –&gt; 设置父元素line-height = 1.5em;</p>\n<p> –&gt; 计算父元素line-height =  font-size × 1.5 = 30px × 1.5 = 45px; </p>\n<p> –&gt; 设置子元素font-size = 20px;</p>\n<p> –&gt; 计算子元素line-height = 继承父元素line-height = 45px; </p>\n<h3 id=\"计算无单位数字的大致流程：\"><a href=\"#计算无单位数字的大致流程：\" class=\"headerlink\" title=\"计算无单位数字的大致流程：\"></a>计算无单位数字的大致流程：</h3><p>–&gt; 设置父元素font-size = 30px;</p>\n<p>–&gt; 设置父元素line-height = 1.5;</p>\n<p>–&gt; 计算父元素line-height = 当前元素font-size × 1.5 = 30px × 1.5 = 45px;</p>\n<p>–&gt; 设置子元素font-size = 20px;</p>\n<p>–&gt; 计算子元素line-height = 继承父元素line-height = 1.5;</p>\n<p>–&gt; 计算实际子元素line-height = 当前元素font-size × 1.5 = 20px × 1.5 = 30px;</p>\n"},{"layout":"post","title":"Sublime Text 3的基本安装与配置","date":"2017-04-01T16:13:06.000Z","_content":"## 下载\n[官网下载](https://www.sublimetext.com/)\n\n## Package Control\n### 安装\n### 简易方法\n最简单的安装方法，是通过Sublime Text控制台来安装。你可以通过Ctrl + ` 快捷键或者通过菜单栏 View > Show Console 来打开控制台。接着，输入下面这段代码按下回车即可。（最新的版本请参照官网）\n\n    import urllib.request,os,hashlib; h = 'df21e130d211cfc94d9b0905775a7c0f' + '1e3d39e33b79698005270310898eea76'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by)\n\n这段代码在必要的情况下会为你创建一个Installed Packages 文件夹，然后下载Package Control.sublime-package到这个文件夹中。这个下载由于Python标准库的限制，会通过HTTP而不是HTTPS来完成。文件会通过SHA-256来验证。\n### 手动下载\n如果由于一些原因，你无法在控制台中完成下载，那么你可以通过以下几个步骤来手动安装Package Control：\n\n 1. 点击菜单中的Preferences > Browse Packages...\n 2. 在打开的文件夹中创建一个Installed Packages文件夹\n 3. 下载这个文件[Package Control.sublime-package](https://packagecontrol.io/Package%20Control.sublime-package)并放到新建的Installed Packages文件夹中\n 4. 重启Sublime Text\n\n### 安装插件\n完成Package Control的安装后，在Sublime中按住`Shift + CMD + P`。在输入框中输入`Package Control:Install Package`，这时Sublime会获取服务器上所有的Package信息，稍等一下后就可以选择自己需要的插件进行安装了。\n你可以在[Package Control - Browse](https://packagecontrol.io/browse)中查看所有插件的信息。Package Control也可以用于下载一些Sublime的主题，只要在Package安装选择界面中以Theme开头即可。\n\n插件的配置和主题的选择都可以在Preferences菜单中进行。\n\n \n## 进阶\n### 在Terminal中打开Sublime\nSublime Text 包含了一个命令行工具，`subl`，能让你在命令行中打开文件。这个工具可以用来在Sublime中打开对应的文件和项目文件夹。\n#### 设置\n在Terminal中输入以下这段代码：\n\n    ln -s \"/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl\" /usr/local/bin/subl\n\n接下来你就可以在命令行中用`subl fileName`的方式来打开文件了。\n\n更多用法可以输入`subl --help`查看。\n### 在Sublime Text中运行JavaScript\n点击菜单中的Tools > Build System > New Build System，复制以下代码：\n\n    {\n\t    \"cmd\": [\"/usr/local/bin/node\",\"$file\"],\n\t    \"selector\": \"source.js\"\n    }\n\n命名为`JavaScript.sublime-build`保存至Package或Package/User文件夹。\n\n## 参考\n[Package Control - Installation](https://packagecontrol.io/installation)\n\n[Sublime Text 3 - OS X Command Line](https://www.sublimetext.com/docs/3/osx_command_line.html)\n\n[Build Systems](http://docs.sublimetext.info/en/latest/file_processing/build_systems.html)","source":"_posts/2017-04-02-Sublime-Text-3的基本安装与配置.markdown","raw":"---\nlayout: post\ntitle:  \"Sublime Text 3的基本安装与配置\"\ndate:   2017-04-02 00:13:06 +0800\ntags: sublime\n---\n## 下载\n[官网下载](https://www.sublimetext.com/)\n\n## Package Control\n### 安装\n### 简易方法\n最简单的安装方法，是通过Sublime Text控制台来安装。你可以通过Ctrl + ` 快捷键或者通过菜单栏 View > Show Console 来打开控制台。接着，输入下面这段代码按下回车即可。（最新的版本请参照官网）\n\n    import urllib.request,os,hashlib; h = 'df21e130d211cfc94d9b0905775a7c0f' + '1e3d39e33b79698005270310898eea76'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by)\n\n这段代码在必要的情况下会为你创建一个Installed Packages 文件夹，然后下载Package Control.sublime-package到这个文件夹中。这个下载由于Python标准库的限制，会通过HTTP而不是HTTPS来完成。文件会通过SHA-256来验证。\n### 手动下载\n如果由于一些原因，你无法在控制台中完成下载，那么你可以通过以下几个步骤来手动安装Package Control：\n\n 1. 点击菜单中的Preferences > Browse Packages...\n 2. 在打开的文件夹中创建一个Installed Packages文件夹\n 3. 下载这个文件[Package Control.sublime-package](https://packagecontrol.io/Package%20Control.sublime-package)并放到新建的Installed Packages文件夹中\n 4. 重启Sublime Text\n\n### 安装插件\n完成Package Control的安装后，在Sublime中按住`Shift + CMD + P`。在输入框中输入`Package Control:Install Package`，这时Sublime会获取服务器上所有的Package信息，稍等一下后就可以选择自己需要的插件进行安装了。\n你可以在[Package Control - Browse](https://packagecontrol.io/browse)中查看所有插件的信息。Package Control也可以用于下载一些Sublime的主题，只要在Package安装选择界面中以Theme开头即可。\n\n插件的配置和主题的选择都可以在Preferences菜单中进行。\n\n \n## 进阶\n### 在Terminal中打开Sublime\nSublime Text 包含了一个命令行工具，`subl`，能让你在命令行中打开文件。这个工具可以用来在Sublime中打开对应的文件和项目文件夹。\n#### 设置\n在Terminal中输入以下这段代码：\n\n    ln -s \"/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl\" /usr/local/bin/subl\n\n接下来你就可以在命令行中用`subl fileName`的方式来打开文件了。\n\n更多用法可以输入`subl --help`查看。\n### 在Sublime Text中运行JavaScript\n点击菜单中的Tools > Build System > New Build System，复制以下代码：\n\n    {\n\t    \"cmd\": [\"/usr/local/bin/node\",\"$file\"],\n\t    \"selector\": \"source.js\"\n    }\n\n命名为`JavaScript.sublime-build`保存至Package或Package/User文件夹。\n\n## 参考\n[Package Control - Installation](https://packagecontrol.io/installation)\n\n[Sublime Text 3 - OS X Command Line](https://www.sublimetext.com/docs/3/osx_command_line.html)\n\n[Build Systems](http://docs.sublimetext.info/en/latest/file_processing/build_systems.html)","slug":"2017-04-02-Sublime-Text-3的基本安装与配置","published":1,"updated":"2017-08-06T12:14:42.000Z","_id":"cj60bzxkn000b1dor2co5sa4q","comments":1,"photos":[],"link":"","content":"<h2 id=\"下载\"><a href=\"#下载\" class=\"headerlink\" title=\"下载\"></a>下载</h2><p><a href=\"https://www.sublimetext.com/\" target=\"_blank\" rel=\"external\">官网下载</a></p>\n<h2 id=\"Package-Control\"><a href=\"#Package-Control\" class=\"headerlink\" title=\"Package Control\"></a>Package Control</h2><h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><h3 id=\"简易方法\"><a href=\"#简易方法\" class=\"headerlink\" title=\"简易方法\"></a>简易方法</h3><p>最简单的安装方法，是通过Sublime Text控制台来安装。你可以通过Ctrl + ` 快捷键或者通过菜单栏 View &gt; Show Console 来打开控制台。接着，输入下面这段代码按下回车即可。（最新的版本请参照官网）</p>\n<pre><code>import urllib.request,os,hashlib; h = &apos;df21e130d211cfc94d9b0905775a7c0f&apos; + &apos;1e3d39e33b79698005270310898eea76&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by)\n</code></pre><p>这段代码在必要的情况下会为你创建一个Installed Packages 文件夹，然后下载Package Control.sublime-package到这个文件夹中。这个下载由于Python标准库的限制，会通过HTTP而不是HTTPS来完成。文件会通过SHA-256来验证。</p>\n<h3 id=\"手动下载\"><a href=\"#手动下载\" class=\"headerlink\" title=\"手动下载\"></a>手动下载</h3><p>如果由于一些原因，你无法在控制台中完成下载，那么你可以通过以下几个步骤来手动安装Package Control：</p>\n<ol>\n<li>点击菜单中的Preferences &gt; Browse Packages…</li>\n<li>在打开的文件夹中创建一个Installed Packages文件夹</li>\n<li>下载这个文件<a href=\"https://packagecontrol.io/Package%20Control.sublime-package\" target=\"_blank\" rel=\"external\">Package Control.sublime-package</a>并放到新建的Installed Packages文件夹中</li>\n<li>重启Sublime Text</li>\n</ol>\n<h3 id=\"安装插件\"><a href=\"#安装插件\" class=\"headerlink\" title=\"安装插件\"></a>安装插件</h3><p>完成Package Control的安装后，在Sublime中按住<code>Shift + CMD + P</code>。在输入框中输入<code>Package Control:Install Package</code>，这时Sublime会获取服务器上所有的Package信息，稍等一下后就可以选择自己需要的插件进行安装了。<br>你可以在<a href=\"https://packagecontrol.io/browse\" target=\"_blank\" rel=\"external\">Package Control - Browse</a>中查看所有插件的信息。Package Control也可以用于下载一些Sublime的主题，只要在Package安装选择界面中以Theme开头即可。</p>\n<p>插件的配置和主题的选择都可以在Preferences菜单中进行。</p>\n<h2 id=\"进阶\"><a href=\"#进阶\" class=\"headerlink\" title=\"进阶\"></a>进阶</h2><h3 id=\"在Terminal中打开Sublime\"><a href=\"#在Terminal中打开Sublime\" class=\"headerlink\" title=\"在Terminal中打开Sublime\"></a>在Terminal中打开Sublime</h3><p>Sublime Text 包含了一个命令行工具，<code>subl</code>，能让你在命令行中打开文件。这个工具可以用来在Sublime中打开对应的文件和项目文件夹。</p>\n<h4 id=\"设置\"><a href=\"#设置\" class=\"headerlink\" title=\"设置\"></a>设置</h4><p>在Terminal中输入以下这段代码：</p>\n<pre><code>ln -s &quot;/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl&quot; /usr/local/bin/subl\n</code></pre><p>接下来你就可以在命令行中用<code>subl fileName</code>的方式来打开文件了。</p>\n<p>更多用法可以输入<code>subl --help</code>查看。</p>\n<h3 id=\"在Sublime-Text中运行JavaScript\"><a href=\"#在Sublime-Text中运行JavaScript\" class=\"headerlink\" title=\"在Sublime Text中运行JavaScript\"></a>在Sublime Text中运行JavaScript</h3><p>点击菜单中的Tools &gt; Build System &gt; New Build System，复制以下代码：</p>\n<pre><code>{\n    &quot;cmd&quot;: [&quot;/usr/local/bin/node&quot;,&quot;$file&quot;],\n    &quot;selector&quot;: &quot;source.js&quot;\n}\n</code></pre><p>命名为<code>JavaScript.sublime-build</code>保存至Package或Package/User文件夹。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://packagecontrol.io/installation\" target=\"_blank\" rel=\"external\">Package Control - Installation</a></p>\n<p><a href=\"https://www.sublimetext.com/docs/3/osx_command_line.html\" target=\"_blank\" rel=\"external\">Sublime Text 3 - OS X Command Line</a></p>\n<p><a href=\"http://docs.sublimetext.info/en/latest/file_processing/build_systems.html\" target=\"_blank\" rel=\"external\">Build Systems</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"下载\"><a href=\"#下载\" class=\"headerlink\" title=\"下载\"></a>下载</h2><p><a href=\"https://www.sublimetext.com/\" target=\"_blank\" rel=\"external\">官网下载</a></p>\n<h2 id=\"Package-Control\"><a href=\"#Package-Control\" class=\"headerlink\" title=\"Package Control\"></a>Package Control</h2><h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><h3 id=\"简易方法\"><a href=\"#简易方法\" class=\"headerlink\" title=\"简易方法\"></a>简易方法</h3><p>最简单的安装方法，是通过Sublime Text控制台来安装。你可以通过Ctrl + ` 快捷键或者通过菜单栏 View &gt; Show Console 来打开控制台。接着，输入下面这段代码按下回车即可。（最新的版本请参照官网）</p>\n<pre><code>import urllib.request,os,hashlib; h = &apos;df21e130d211cfc94d9b0905775a7c0f&apos; + &apos;1e3d39e33b79698005270310898eea76&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by)\n</code></pre><p>这段代码在必要的情况下会为你创建一个Installed Packages 文件夹，然后下载Package Control.sublime-package到这个文件夹中。这个下载由于Python标准库的限制，会通过HTTP而不是HTTPS来完成。文件会通过SHA-256来验证。</p>\n<h3 id=\"手动下载\"><a href=\"#手动下载\" class=\"headerlink\" title=\"手动下载\"></a>手动下载</h3><p>如果由于一些原因，你无法在控制台中完成下载，那么你可以通过以下几个步骤来手动安装Package Control：</p>\n<ol>\n<li>点击菜单中的Preferences &gt; Browse Packages…</li>\n<li>在打开的文件夹中创建一个Installed Packages文件夹</li>\n<li>下载这个文件<a href=\"https://packagecontrol.io/Package%20Control.sublime-package\" target=\"_blank\" rel=\"external\">Package Control.sublime-package</a>并放到新建的Installed Packages文件夹中</li>\n<li>重启Sublime Text</li>\n</ol>\n<h3 id=\"安装插件\"><a href=\"#安装插件\" class=\"headerlink\" title=\"安装插件\"></a>安装插件</h3><p>完成Package Control的安装后，在Sublime中按住<code>Shift + CMD + P</code>。在输入框中输入<code>Package Control:Install Package</code>，这时Sublime会获取服务器上所有的Package信息，稍等一下后就可以选择自己需要的插件进行安装了。<br>你可以在<a href=\"https://packagecontrol.io/browse\" target=\"_blank\" rel=\"external\">Package Control - Browse</a>中查看所有插件的信息。Package Control也可以用于下载一些Sublime的主题，只要在Package安装选择界面中以Theme开头即可。</p>\n<p>插件的配置和主题的选择都可以在Preferences菜单中进行。</p>\n<h2 id=\"进阶\"><a href=\"#进阶\" class=\"headerlink\" title=\"进阶\"></a>进阶</h2><h3 id=\"在Terminal中打开Sublime\"><a href=\"#在Terminal中打开Sublime\" class=\"headerlink\" title=\"在Terminal中打开Sublime\"></a>在Terminal中打开Sublime</h3><p>Sublime Text 包含了一个命令行工具，<code>subl</code>，能让你在命令行中打开文件。这个工具可以用来在Sublime中打开对应的文件和项目文件夹。</p>\n<h4 id=\"设置\"><a href=\"#设置\" class=\"headerlink\" title=\"设置\"></a>设置</h4><p>在Terminal中输入以下这段代码：</p>\n<pre><code>ln -s &quot;/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl&quot; /usr/local/bin/subl\n</code></pre><p>接下来你就可以在命令行中用<code>subl fileName</code>的方式来打开文件了。</p>\n<p>更多用法可以输入<code>subl --help</code>查看。</p>\n<h3 id=\"在Sublime-Text中运行JavaScript\"><a href=\"#在Sublime-Text中运行JavaScript\" class=\"headerlink\" title=\"在Sublime Text中运行JavaScript\"></a>在Sublime Text中运行JavaScript</h3><p>点击菜单中的Tools &gt; Build System &gt; New Build System，复制以下代码：</p>\n<pre><code>{\n    &quot;cmd&quot;: [&quot;/usr/local/bin/node&quot;,&quot;$file&quot;],\n    &quot;selector&quot;: &quot;source.js&quot;\n}\n</code></pre><p>命名为<code>JavaScript.sublime-build</code>保存至Package或Package/User文件夹。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://packagecontrol.io/installation\" target=\"_blank\" rel=\"external\">Package Control - Installation</a></p>\n<p><a href=\"https://www.sublimetext.com/docs/3/osx_command_line.html\" target=\"_blank\" rel=\"external\">Sublime Text 3 - OS X Command Line</a></p>\n<p><a href=\"http://docs.sublimetext.info/en/latest/file_processing/build_systems.html\" target=\"_blank\" rel=\"external\">Build Systems</a></p>\n"},{"layout":"post","title":"Mac：如何在Terminal中打开Finder","date":"2017-04-07T14:16:35.000Z","_content":"## 前言\n对于习惯使用Terminal的小伙伴们来说，常常有“进入到某个目录中”并“在该目录中打开Finder”的需求。\n明明已经在目录下了，却还需要在桌面按个CMD+N来打开Finder再在Finder中一层一层打开，简直不要太痛苦。\n既然如此，那就试试open命令吧。\n## open命令\n在Terminal中输入`open -h`，可以看到如下的说明：\n\n\n\tUsage: open [-e] [-t] [-f] [-W] [-R] [-n] [-g] [-h] [-b <bundle identifier>] [-a <application>] [filenames] [--args arguments]\n\tHelp: Open opens files from a shell.\n\t      By default, opens each file using the default application for that file.  \n\t      If the file is in the form of a URL, the file will be opened as a URL.\n\tOptions: \n\t      -a                Opens with the specified application.\n\t      -b                Opens with the specified application bundle identifier.\n\t      -e                Opens with TextEdit.\n\t      -t                Opens with default text editor.\n\t      -f                Reads input from standard input and opens with TextEdit.\n\t      -F  --fresh       Launches the app fresh, that is, without restoring windows. Saved persistent state is lost, excluding Untitled documents.\n\t      -R, --reveal      Selects in the Finder instead of opening.\n\t      -W, --wait-apps   Blocks until the used applications are closed (even if they were already running).\n\t          --args        All remaining arguments are passed in argv to the application's main() function instead of opened.\n\t      -n, --new         Open a new instance of the application even if one is already running.\n\t      -j, --hide        Launches the app hidden.\n\t      -g, --background  Does not bring the application to the foreground.\n\t      -h, --header      Searches header file locations for headers matching the given filenames, and opens them.\n\n\n部分翻译如下：\n\n\n\t使用方法： open [-e] [-t] [-f] [-W] [-R] [-n] [-g] [-h] [-b <bundle identifier>] [-a <应用名>] [文件名] [--args arguments]\n\tHelp: 用于在命令行中打开文件\n\t      默认情况下，使用默认的应用打开对应的文件。\n\t      如果是URL格式的文件，那么就会在浏览器中打开。\n\tOptions: \n\t      -a                指定打开文件的应用\n\t      -e                用TextEdit打开该文件\n\t      -t                用默认文本编辑器打开该文件\n\t      -R, --reveal      在Finder中显示并选中\n\t      -g, --background  在后台打开该文件（此时焦点还在Terminal上）\n\n\n\n## 打开目录的正确方式\n那么如何解决“在Terminal中打开当前目录”的问题呢？只要输入以下命令即可：\n\n    $ open ./\n\n没错就这么简单。默认情况下，如果是个open之后是一个目录，那么就会用Finder打开。回车之后，会将焦点直接转移至打开的Finder目录。\n这时如果你是想打开多个Finder目录，就需要手动切回Terminal再执行命令了。这种情况下，你可以加一个-g参数，来让焦点始终保持在Terminal上。\n\n    $ open -g ./\n\n这样我们就可以一次性在命令行中打开所有想打开的目录了。\n### 浏览文件\n除此之外，文件太多了，想在Finder中浏览指定文件怎么办呢。可以用-R来解决：\n\n    $ open -R ./test.js\n\n这样就可以在Finder显示，并且已经被选中了。\n## 打开网站的正确方式\n除了打开目录之外，open命令也可以用于打开网站：\n\n    $ open http://denight.leanote.com\n\n记得一定要加http，否则是不会被识别成URL的。\n### 指定浏览器打开\n默认情况下，是用Safari打开浏览器的：\n\n    $ open http://denight.leanote.com\n\n等同于\n\n    $ open -a Safari http://denight.leanote.com\n\n如果要换成Firefox或者是Google Chrome，替换命令中的Safari即可\n\n    $ open -a Firefox http://denight.leanote.com\n    $ open -a Google\\ Chrome http://denight.leanote.com\n\n## 打开代码的正确方式\n\n    $open -e ./test.js\n\n使用这个命令，可以在TextEdit中打开test.js文件。如果不加-e的话，就会用默认的应用打开。\n也可以指定想要的打开的编辑器。\n\n    $open -a Sublime\\ Text ./test.js\n\n\n## 参考\n[在Mac终端下打开Finder](http://ju.outofmemory.cn/entry/75555)\n","source":"_posts/2017-04-07-Mac在Terminal打开Finder.markdown","raw":"---\nlayout: post\ntitle:  \"Mac：如何在Terminal中打开Finder\"\ndate:   2017-04-07 22:16:35 +0800\ntags: mac\n---\n## 前言\n对于习惯使用Terminal的小伙伴们来说，常常有“进入到某个目录中”并“在该目录中打开Finder”的需求。\n明明已经在目录下了，却还需要在桌面按个CMD+N来打开Finder再在Finder中一层一层打开，简直不要太痛苦。\n既然如此，那就试试open命令吧。\n## open命令\n在Terminal中输入`open -h`，可以看到如下的说明：\n\n\n\tUsage: open [-e] [-t] [-f] [-W] [-R] [-n] [-g] [-h] [-b <bundle identifier>] [-a <application>] [filenames] [--args arguments]\n\tHelp: Open opens files from a shell.\n\t      By default, opens each file using the default application for that file.  \n\t      If the file is in the form of a URL, the file will be opened as a URL.\n\tOptions: \n\t      -a                Opens with the specified application.\n\t      -b                Opens with the specified application bundle identifier.\n\t      -e                Opens with TextEdit.\n\t      -t                Opens with default text editor.\n\t      -f                Reads input from standard input and opens with TextEdit.\n\t      -F  --fresh       Launches the app fresh, that is, without restoring windows. Saved persistent state is lost, excluding Untitled documents.\n\t      -R, --reveal      Selects in the Finder instead of opening.\n\t      -W, --wait-apps   Blocks until the used applications are closed (even if they were already running).\n\t          --args        All remaining arguments are passed in argv to the application's main() function instead of opened.\n\t      -n, --new         Open a new instance of the application even if one is already running.\n\t      -j, --hide        Launches the app hidden.\n\t      -g, --background  Does not bring the application to the foreground.\n\t      -h, --header      Searches header file locations for headers matching the given filenames, and opens them.\n\n\n部分翻译如下：\n\n\n\t使用方法： open [-e] [-t] [-f] [-W] [-R] [-n] [-g] [-h] [-b <bundle identifier>] [-a <应用名>] [文件名] [--args arguments]\n\tHelp: 用于在命令行中打开文件\n\t      默认情况下，使用默认的应用打开对应的文件。\n\t      如果是URL格式的文件，那么就会在浏览器中打开。\n\tOptions: \n\t      -a                指定打开文件的应用\n\t      -e                用TextEdit打开该文件\n\t      -t                用默认文本编辑器打开该文件\n\t      -R, --reveal      在Finder中显示并选中\n\t      -g, --background  在后台打开该文件（此时焦点还在Terminal上）\n\n\n\n## 打开目录的正确方式\n那么如何解决“在Terminal中打开当前目录”的问题呢？只要输入以下命令即可：\n\n    $ open ./\n\n没错就这么简单。默认情况下，如果是个open之后是一个目录，那么就会用Finder打开。回车之后，会将焦点直接转移至打开的Finder目录。\n这时如果你是想打开多个Finder目录，就需要手动切回Terminal再执行命令了。这种情况下，你可以加一个-g参数，来让焦点始终保持在Terminal上。\n\n    $ open -g ./\n\n这样我们就可以一次性在命令行中打开所有想打开的目录了。\n### 浏览文件\n除此之外，文件太多了，想在Finder中浏览指定文件怎么办呢。可以用-R来解决：\n\n    $ open -R ./test.js\n\n这样就可以在Finder显示，并且已经被选中了。\n## 打开网站的正确方式\n除了打开目录之外，open命令也可以用于打开网站：\n\n    $ open http://denight.leanote.com\n\n记得一定要加http，否则是不会被识别成URL的。\n### 指定浏览器打开\n默认情况下，是用Safari打开浏览器的：\n\n    $ open http://denight.leanote.com\n\n等同于\n\n    $ open -a Safari http://denight.leanote.com\n\n如果要换成Firefox或者是Google Chrome，替换命令中的Safari即可\n\n    $ open -a Firefox http://denight.leanote.com\n    $ open -a Google\\ Chrome http://denight.leanote.com\n\n## 打开代码的正确方式\n\n    $open -e ./test.js\n\n使用这个命令，可以在TextEdit中打开test.js文件。如果不加-e的话，就会用默认的应用打开。\n也可以指定想要的打开的编辑器。\n\n    $open -a Sublime\\ Text ./test.js\n\n\n## 参考\n[在Mac终端下打开Finder](http://ju.outofmemory.cn/entry/75555)\n","slug":"2017-04-07-Mac在Terminal打开Finder","published":1,"updated":"2017-08-06T12:14:45.000Z","_id":"cj60bzxkp000d1dorkzss7csy","comments":1,"photos":[],"link":"","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>对于习惯使用Terminal的小伙伴们来说，常常有“进入到某个目录中”并“在该目录中打开Finder”的需求。<br>明明已经在目录下了，却还需要在桌面按个CMD+N来打开Finder再在Finder中一层一层打开，简直不要太痛苦。<br>既然如此，那就试试open命令吧。</p>\n<h2 id=\"open命令\"><a href=\"#open命令\" class=\"headerlink\" title=\"open命令\"></a>open命令</h2><p>在Terminal中输入<code>open -h</code>，可以看到如下的说明：</p>\n<pre><code>Usage: open [-e] [-t] [-f] [-W] [-R] [-n] [-g] [-h] [-b &lt;bundle identifier&gt;] [-a &lt;application&gt;] [filenames] [--args arguments]\nHelp: Open opens files from a shell.\n      By default, opens each file using the default application for that file.  \n      If the file is in the form of a URL, the file will be opened as a URL.\nOptions: \n      -a                Opens with the specified application.\n      -b                Opens with the specified application bundle identifier.\n      -e                Opens with TextEdit.\n      -t                Opens with default text editor.\n      -f                Reads input from standard input and opens with TextEdit.\n      -F  --fresh       Launches the app fresh, that is, without restoring windows. Saved persistent state is lost, excluding Untitled documents.\n      -R, --reveal      Selects in the Finder instead of opening.\n      -W, --wait-apps   Blocks until the used applications are closed (even if they were already running).\n          --args        All remaining arguments are passed in argv to the application&apos;s main() function instead of opened.\n      -n, --new         Open a new instance of the application even if one is already running.\n      -j, --hide        Launches the app hidden.\n      -g, --background  Does not bring the application to the foreground.\n      -h, --header      Searches header file locations for headers matching the given filenames, and opens them.\n</code></pre><p>部分翻译如下：</p>\n<pre><code>使用方法： open [-e] [-t] [-f] [-W] [-R] [-n] [-g] [-h] [-b &lt;bundle identifier&gt;] [-a &lt;应用名&gt;] [文件名] [--args arguments]\nHelp: 用于在命令行中打开文件\n      默认情况下，使用默认的应用打开对应的文件。\n      如果是URL格式的文件，那么就会在浏览器中打开。\nOptions: \n      -a                指定打开文件的应用\n      -e                用TextEdit打开该文件\n      -t                用默认文本编辑器打开该文件\n      -R, --reveal      在Finder中显示并选中\n      -g, --background  在后台打开该文件（此时焦点还在Terminal上）\n</code></pre><h2 id=\"打开目录的正确方式\"><a href=\"#打开目录的正确方式\" class=\"headerlink\" title=\"打开目录的正确方式\"></a>打开目录的正确方式</h2><p>那么如何解决“在Terminal中打开当前目录”的问题呢？只要输入以下命令即可：</p>\n<pre><code>$ open ./\n</code></pre><p>没错就这么简单。默认情况下，如果是个open之后是一个目录，那么就会用Finder打开。回车之后，会将焦点直接转移至打开的Finder目录。<br>这时如果你是想打开多个Finder目录，就需要手动切回Terminal再执行命令了。这种情况下，你可以加一个-g参数，来让焦点始终保持在Terminal上。</p>\n<pre><code>$ open -g ./\n</code></pre><p>这样我们就可以一次性在命令行中打开所有想打开的目录了。</p>\n<h3 id=\"浏览文件\"><a href=\"#浏览文件\" class=\"headerlink\" title=\"浏览文件\"></a>浏览文件</h3><p>除此之外，文件太多了，想在Finder中浏览指定文件怎么办呢。可以用-R来解决：</p>\n<pre><code>$ open -R ./test.js\n</code></pre><p>这样就可以在Finder显示，并且已经被选中了。</p>\n<h2 id=\"打开网站的正确方式\"><a href=\"#打开网站的正确方式\" class=\"headerlink\" title=\"打开网站的正确方式\"></a>打开网站的正确方式</h2><p>除了打开目录之外，open命令也可以用于打开网站：</p>\n<pre><code>$ open http://denight.leanote.com\n</code></pre><p>记得一定要加http，否则是不会被识别成URL的。</p>\n<h3 id=\"指定浏览器打开\"><a href=\"#指定浏览器打开\" class=\"headerlink\" title=\"指定浏览器打开\"></a>指定浏览器打开</h3><p>默认情况下，是用Safari打开浏览器的：</p>\n<pre><code>$ open http://denight.leanote.com\n</code></pre><p>等同于</p>\n<pre><code>$ open -a Safari http://denight.leanote.com\n</code></pre><p>如果要换成Firefox或者是Google Chrome，替换命令中的Safari即可</p>\n<pre><code>$ open -a Firefox http://denight.leanote.com\n$ open -a Google\\ Chrome http://denight.leanote.com\n</code></pre><h2 id=\"打开代码的正确方式\"><a href=\"#打开代码的正确方式\" class=\"headerlink\" title=\"打开代码的正确方式\"></a>打开代码的正确方式</h2><pre><code>$open -e ./test.js\n</code></pre><p>使用这个命令，可以在TextEdit中打开test.js文件。如果不加-e的话，就会用默认的应用打开。<br>也可以指定想要的打开的编辑器。</p>\n<pre><code>$open -a Sublime\\ Text ./test.js\n</code></pre><h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://ju.outofmemory.cn/entry/75555\" target=\"_blank\" rel=\"external\">在Mac终端下打开Finder</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>对于习惯使用Terminal的小伙伴们来说，常常有“进入到某个目录中”并“在该目录中打开Finder”的需求。<br>明明已经在目录下了，却还需要在桌面按个CMD+N来打开Finder再在Finder中一层一层打开，简直不要太痛苦。<br>既然如此，那就试试open命令吧。</p>\n<h2 id=\"open命令\"><a href=\"#open命令\" class=\"headerlink\" title=\"open命令\"></a>open命令</h2><p>在Terminal中输入<code>open -h</code>，可以看到如下的说明：</p>\n<pre><code>Usage: open [-e] [-t] [-f] [-W] [-R] [-n] [-g] [-h] [-b &lt;bundle identifier&gt;] [-a &lt;application&gt;] [filenames] [--args arguments]\nHelp: Open opens files from a shell.\n      By default, opens each file using the default application for that file.  \n      If the file is in the form of a URL, the file will be opened as a URL.\nOptions: \n      -a                Opens with the specified application.\n      -b                Opens with the specified application bundle identifier.\n      -e                Opens with TextEdit.\n      -t                Opens with default text editor.\n      -f                Reads input from standard input and opens with TextEdit.\n      -F  --fresh       Launches the app fresh, that is, without restoring windows. Saved persistent state is lost, excluding Untitled documents.\n      -R, --reveal      Selects in the Finder instead of opening.\n      -W, --wait-apps   Blocks until the used applications are closed (even if they were already running).\n          --args        All remaining arguments are passed in argv to the application&apos;s main() function instead of opened.\n      -n, --new         Open a new instance of the application even if one is already running.\n      -j, --hide        Launches the app hidden.\n      -g, --background  Does not bring the application to the foreground.\n      -h, --header      Searches header file locations for headers matching the given filenames, and opens them.\n</code></pre><p>部分翻译如下：</p>\n<pre><code>使用方法： open [-e] [-t] [-f] [-W] [-R] [-n] [-g] [-h] [-b &lt;bundle identifier&gt;] [-a &lt;应用名&gt;] [文件名] [--args arguments]\nHelp: 用于在命令行中打开文件\n      默认情况下，使用默认的应用打开对应的文件。\n      如果是URL格式的文件，那么就会在浏览器中打开。\nOptions: \n      -a                指定打开文件的应用\n      -e                用TextEdit打开该文件\n      -t                用默认文本编辑器打开该文件\n      -R, --reveal      在Finder中显示并选中\n      -g, --background  在后台打开该文件（此时焦点还在Terminal上）\n</code></pre><h2 id=\"打开目录的正确方式\"><a href=\"#打开目录的正确方式\" class=\"headerlink\" title=\"打开目录的正确方式\"></a>打开目录的正确方式</h2><p>那么如何解决“在Terminal中打开当前目录”的问题呢？只要输入以下命令即可：</p>\n<pre><code>$ open ./\n</code></pre><p>没错就这么简单。默认情况下，如果是个open之后是一个目录，那么就会用Finder打开。回车之后，会将焦点直接转移至打开的Finder目录。<br>这时如果你是想打开多个Finder目录，就需要手动切回Terminal再执行命令了。这种情况下，你可以加一个-g参数，来让焦点始终保持在Terminal上。</p>\n<pre><code>$ open -g ./\n</code></pre><p>这样我们就可以一次性在命令行中打开所有想打开的目录了。</p>\n<h3 id=\"浏览文件\"><a href=\"#浏览文件\" class=\"headerlink\" title=\"浏览文件\"></a>浏览文件</h3><p>除此之外，文件太多了，想在Finder中浏览指定文件怎么办呢。可以用-R来解决：</p>\n<pre><code>$ open -R ./test.js\n</code></pre><p>这样就可以在Finder显示，并且已经被选中了。</p>\n<h2 id=\"打开网站的正确方式\"><a href=\"#打开网站的正确方式\" class=\"headerlink\" title=\"打开网站的正确方式\"></a>打开网站的正确方式</h2><p>除了打开目录之外，open命令也可以用于打开网站：</p>\n<pre><code>$ open http://denight.leanote.com\n</code></pre><p>记得一定要加http，否则是不会被识别成URL的。</p>\n<h3 id=\"指定浏览器打开\"><a href=\"#指定浏览器打开\" class=\"headerlink\" title=\"指定浏览器打开\"></a>指定浏览器打开</h3><p>默认情况下，是用Safari打开浏览器的：</p>\n<pre><code>$ open http://denight.leanote.com\n</code></pre><p>等同于</p>\n<pre><code>$ open -a Safari http://denight.leanote.com\n</code></pre><p>如果要换成Firefox或者是Google Chrome，替换命令中的Safari即可</p>\n<pre><code>$ open -a Firefox http://denight.leanote.com\n$ open -a Google\\ Chrome http://denight.leanote.com\n</code></pre><h2 id=\"打开代码的正确方式\"><a href=\"#打开代码的正确方式\" class=\"headerlink\" title=\"打开代码的正确方式\"></a>打开代码的正确方式</h2><pre><code>$open -e ./test.js\n</code></pre><p>使用这个命令，可以在TextEdit中打开test.js文件。如果不加-e的话，就会用默认的应用打开。<br>也可以指定想要的打开的编辑器。</p>\n<pre><code>$open -a Sublime\\ Text ./test.js\n</code></pre><h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://ju.outofmemory.cn/entry/75555\" target=\"_blank\" rel=\"external\">在Mac终端下打开Finder</a></p>\n"},{"layout":"post","title":"HTTP基础（1）：概述","date":"2017-04-11T12:16:00.000Z","_content":"## HTTP协议\nHTTP，HyperText Tranfer Protocol，超文本传输协议（超文本转移协议）。\n\nHTTP协议用于客户端和服务器端之间的通信。访问文本或图像等资源的一端称为服务端（即浏览器），提供资源相应的一端称为服务端（即Web服务器）。\n\n客户端向服务器端发起一个HTTP请求，服务器端在收到HTTP请求后根据请求报文中的内容进行响应，随后返回一个HTTP响应报文。客户端得到响应后便获取到了想要获取的资源或者相关错误信息（如资源不存在）。\n\n## HTTP通过请求和响应的交换达成通信\n\nHTTP协议规定，请求从客户端发出，最后服务器端响应该请求并返回。\n\n### HTTP请求\n\n客户端发送请求：\n\n    GET /index.html HTTP/1.1\n    Host: www.example.com\n\nGET表示访问服务器的类型，称为方法（method）。随后的字符串`/index.html`指明了请求访问的资源对象，叫做请求URI（request-URI）。然后是HTTP/1.1，即HTTP的版本号。\n\n综上，这段请求的意思：通过GET方法，访问`www.example.com`这台主机上的`/index.html`页面资源。\n\n请求报文由以下几部分组成：\n\n- 请求方法\n- 请求URI\n- HTTP版本协议\n- 可选的请求首部字段\n- 可选的内容实体\n\n以下是一个用POST方法发起的HTTP请求：\n\n    POST /user/login HTTP/1.1\n    Host: www.example.com\n    Connect: keep-alive\n    Content-Type: application/x-www-form-urlencode\n    Content-Length: 16\n    \n    user=dxy&pwd=123\n    \n第一部分分别是请求方法（POST)，请求URI（/user/login），版本协议（HTTP/1.1）。接下来是请求首部字段（Host：...）。最后是内容实体（user=dxy&pwd=123）。\n\n这段请求的意思是：用POST方法，向`www.example.com/user/login`提交一个表单数据，表单数据为`user=dxy&pwd=123`。\n\n### HTTP响应\n\n服务器端发送响应：\n\n    HTTP/1.1 200 OK\n    Date: Mon, 10 Apr 2017 14:17:00 GMT\n    Content-Length: 3987\n    Content-Type: text/html\n    \n    <html>\n    ...\n\n第一部分分别是版本协议（HTTP/1.1），响应状态码（200，status code）和原因短语（reason-phrase）。接下来是创建响应的日期时间，和其他首部字段的内容。最后是一行隔开，为资源实体的主体（entity body）。\n\n响应报文由以下几部分组成：\n- HTTP版本协议\n- 状态码和原因短语\n- 创建响应的日期和可选的首部字段\n- 资源实体的主体\n\n## HTTP是不保存状态的协议\n\nHTTP是一种无状态的协议（stateless）,这意味着HTTP协议不会保存请求和响应时的通信状态，即对请求和响应都不会做持久化处理。\n\n这就会导致用户在访问一个网站时，其访问的状态无法得到保存，因为每次发起的HTTP请求都是“新”的请求，与之前是否发送过无关。\n\n为了解决这个问题，可以通过Cookie技术来实现用户状态的保存。\n\n## 请求URI定位资源\n\nHTTP协议使用URI（统一资源标识符）来定位互联网上的资源。当客户端请求访问某个资源时，需要指定该资源的URI作为HTTP请求中的请求URI。指定的方式由以下两种：\n第一种是在Host首部字段中写明访问的主机地址（域名或IP）\n\n    GET /index.html HTTP/1.1\n    Host: www.example.com\n\n第二种是完整的URI地址：\n\n    GET http://www.example.com/index.html HTTP/1.1\n\n如果不是访问特定资源而是对服务器发起请求，可以用*来代替URI。下面这个例子是查询HTTP服务器端支持的HTTP方法种类。\n\n    OPTIONS * HTTP/1.1\n\n## 基本的HTTP请求方法\n\n### GET：获取资源\nGET方法用来请求访问已被URI识别的资源。指定的资源经过服务器端解析后返回响应的内容。\n请求：\n\n    GET /index.html HTTP/1.1\n    Host: www.example.com\n    If-Modified-Since: Mon, 10 Apr 2017 14:17:00 GMT\n\n响应：\n返回2017年4月10日14点17分00秒后更新过的index.html内容，若没有更新过，则返回304 Not Modified。\n\n### POST：传输实体主体\n\n尽管GET也可以传输实体主体，但是一般来说GET用于获取资源，而POST则专门用于传输资源或更新数据。\n\n请求：\n\n    POST /submit HTTP/1.1\n    Host: www.example.com\n    ConTent-Length: 16\n    \n    user=dxy&pwd=123\n\n响应：\n返回submit响应后的处理结果\n\n### PUT：传输文件\n\nPUT方法用来传输文件，要求请求报文的主体中包含文件内容，然后保存到URI指定的位置。\n\n但是由于HTTP/1.1的PUT方法没有验证机制，任何人都可以上传文件，所以存在安全性问题。现在一般只用来配合RESTFul API。\n\n### DELETE：删除文件\n\nDELETE方法与PUT方法正好相反，用于删除指定URI上的文件。现在一般也只用在RESTFul API上。\n\n### HEAD：获取报文首部\n\nHEAD方法用来获取报文的首部，确认URI的有效性和资源的更新日期。HEAD方法基本和GET方法一样，只是GET方法获取资源内容，而HEAD方法不获取资源内容，仅获取响应报文的首部。\n\n### OPTIONS：询问支持的方法\n\nOPTIONS方法用来查询针对请求URI指定的资源支持的方法。\n\n请求：\n\n    OPTIONS * HTTP/1.1\n    Host: www.example.com\n\n响应：\n\n    HTTP/1.1 200 OK\n    Allow：Get,Post,Head,Options\n\n### TRACE：追踪路径\n\nTRACE方法是让Web服务器端将之前的请求通信环回给客户端的方法。客户端通过TRACE方法可以查询发送出去的请求是怎样被加工修改的。\n\n由于TRACE方法容易引发XST（Cross-Site Tracing 跨站追踪）攻击，且本身就不常用，这里不作展开。\n\n### CONNECT：要求用隧道协议连接代理\n\nCONNECT方法要求在与代理服务器通信时建立隧道，实现使用隧道协议进行TCP通信。主要使用SSL（Secure Sockets Layer，安全套接字）和TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。\n\n## 建立持久连接以节省通信量\n\n在HTTP协议的初始版本中，每次发送HTTP协议都会经历一次TCP连接和关闭。随着Web的发展，一个网页会包含多个HTTP请求去加载JS文件、CSS文件、图片文件等等。如果每次HTTP请求都要断开TCP连接的话，就会带来额外的通信量。为此，HTTP/1.1新增了持久化连接（HTTP keep-alive）的方案。\n\n持久连接的特点是：只要任意一方没有明确需要断开TCP连接，那么客户端和服务器端将一直保持TCP连接，旨在一次TCP连接中进行多次HTTP请求和响应。\n\nHTTP/1.1中，所有的连接默认都是持久连接。当然这需要客户端和服务器端同时支持。\n\n持久连接使得多数请求能够以管线化的方式发送，可以让客户端并行发送多个HTTP请求，大大降低Web页面的显示速度。如果没有持久化连接，那么每次发起HTTP请求，下一个HTTP请求都得等待上一个HTTP请求得到响应后才能发送。\n\n## 使用Cookie进行状态管理\n\n一方面，无状态协议能够节省服务器计算资源的开销，另一方面由于无状态的存在使得状态管理成为一个难题。\n\n为了保留无状态协议同时实现状态管理，引入了Cookie技术，通过在请求和响应的报文中写入Cookie信息来控制客户端的状态。\n\n第一次请求（没有Cookie信息）：\n\n    GET /reader HTTP/1.1\n    Host: www.example.com\n    \n响应（服务器生成Cookie信息）：\n\n    HTTP/1.1 200 OK\n    Date: Mon, 10 Apr 2017 14:17:00 GMT\n    Server: Apache\n    Set-Cookie: sid=1342077140226724; path=/; expires=Wed, 10-OCT-12 07:12:20 GMT\n    Content-Type: text/plain; charset=UTF-8\n\n之后再发起请求时，会自带Cookie信息：\n\n    GET /other HTTP/1.1\n    Host: www.example.com\n    Cookie: sid=1342077140226724\n\n可见服务器通过Set-Cookie来通知客户端保存Cookie信息，客户端随后针对这个站点的HTTP请求都会在请求头部中加入Cookie字段。如此一来，服务器端在接收到请求时就能根据客户端传来的Cookie中的sid信息，来辨别客户端了，客户端的状态就能够得到保持。\n\n## 小结\n\nHTTP协议是通过请求和响应来进行通信的无状态协议。\n\n其中要注意HTTP请求的基本格式，其组成（请求方法，请求URI，版本协议，可选的首部字段，可选的传输实体）。HTTP响应的基本格式，以及其组成（版本协议，状态码，原因短语，可选的首部字段，资源实体的主体）。\n\n要熟悉常见的请求方法（GET、POST、PUT、DELETE、OPTIONS、TRACE、CONNECT）。能写出基本的请求报文。\n\n能说出持久化连接的实现方法及其优点，以及如何通过Cookie解决客户端状态保持的问题。\n\n\n\n","source":"_posts/2017-04-11-HTTP：协议基础.markdown","raw":"---\nlayout: post\ntitle:  \"HTTP基础（1）：概述\"\ndate:   2017-04-11 20:16:00 +0800\ntags: http\n---\n## HTTP协议\nHTTP，HyperText Tranfer Protocol，超文本传输协议（超文本转移协议）。\n\nHTTP协议用于客户端和服务器端之间的通信。访问文本或图像等资源的一端称为服务端（即浏览器），提供资源相应的一端称为服务端（即Web服务器）。\n\n客户端向服务器端发起一个HTTP请求，服务器端在收到HTTP请求后根据请求报文中的内容进行响应，随后返回一个HTTP响应报文。客户端得到响应后便获取到了想要获取的资源或者相关错误信息（如资源不存在）。\n\n## HTTP通过请求和响应的交换达成通信\n\nHTTP协议规定，请求从客户端发出，最后服务器端响应该请求并返回。\n\n### HTTP请求\n\n客户端发送请求：\n\n    GET /index.html HTTP/1.1\n    Host: www.example.com\n\nGET表示访问服务器的类型，称为方法（method）。随后的字符串`/index.html`指明了请求访问的资源对象，叫做请求URI（request-URI）。然后是HTTP/1.1，即HTTP的版本号。\n\n综上，这段请求的意思：通过GET方法，访问`www.example.com`这台主机上的`/index.html`页面资源。\n\n请求报文由以下几部分组成：\n\n- 请求方法\n- 请求URI\n- HTTP版本协议\n- 可选的请求首部字段\n- 可选的内容实体\n\n以下是一个用POST方法发起的HTTP请求：\n\n    POST /user/login HTTP/1.1\n    Host: www.example.com\n    Connect: keep-alive\n    Content-Type: application/x-www-form-urlencode\n    Content-Length: 16\n    \n    user=dxy&pwd=123\n    \n第一部分分别是请求方法（POST)，请求URI（/user/login），版本协议（HTTP/1.1）。接下来是请求首部字段（Host：...）。最后是内容实体（user=dxy&pwd=123）。\n\n这段请求的意思是：用POST方法，向`www.example.com/user/login`提交一个表单数据，表单数据为`user=dxy&pwd=123`。\n\n### HTTP响应\n\n服务器端发送响应：\n\n    HTTP/1.1 200 OK\n    Date: Mon, 10 Apr 2017 14:17:00 GMT\n    Content-Length: 3987\n    Content-Type: text/html\n    \n    <html>\n    ...\n\n第一部分分别是版本协议（HTTP/1.1），响应状态码（200，status code）和原因短语（reason-phrase）。接下来是创建响应的日期时间，和其他首部字段的内容。最后是一行隔开，为资源实体的主体（entity body）。\n\n响应报文由以下几部分组成：\n- HTTP版本协议\n- 状态码和原因短语\n- 创建响应的日期和可选的首部字段\n- 资源实体的主体\n\n## HTTP是不保存状态的协议\n\nHTTP是一种无状态的协议（stateless）,这意味着HTTP协议不会保存请求和响应时的通信状态，即对请求和响应都不会做持久化处理。\n\n这就会导致用户在访问一个网站时，其访问的状态无法得到保存，因为每次发起的HTTP请求都是“新”的请求，与之前是否发送过无关。\n\n为了解决这个问题，可以通过Cookie技术来实现用户状态的保存。\n\n## 请求URI定位资源\n\nHTTP协议使用URI（统一资源标识符）来定位互联网上的资源。当客户端请求访问某个资源时，需要指定该资源的URI作为HTTP请求中的请求URI。指定的方式由以下两种：\n第一种是在Host首部字段中写明访问的主机地址（域名或IP）\n\n    GET /index.html HTTP/1.1\n    Host: www.example.com\n\n第二种是完整的URI地址：\n\n    GET http://www.example.com/index.html HTTP/1.1\n\n如果不是访问特定资源而是对服务器发起请求，可以用*来代替URI。下面这个例子是查询HTTP服务器端支持的HTTP方法种类。\n\n    OPTIONS * HTTP/1.1\n\n## 基本的HTTP请求方法\n\n### GET：获取资源\nGET方法用来请求访问已被URI识别的资源。指定的资源经过服务器端解析后返回响应的内容。\n请求：\n\n    GET /index.html HTTP/1.1\n    Host: www.example.com\n    If-Modified-Since: Mon, 10 Apr 2017 14:17:00 GMT\n\n响应：\n返回2017年4月10日14点17分00秒后更新过的index.html内容，若没有更新过，则返回304 Not Modified。\n\n### POST：传输实体主体\n\n尽管GET也可以传输实体主体，但是一般来说GET用于获取资源，而POST则专门用于传输资源或更新数据。\n\n请求：\n\n    POST /submit HTTP/1.1\n    Host: www.example.com\n    ConTent-Length: 16\n    \n    user=dxy&pwd=123\n\n响应：\n返回submit响应后的处理结果\n\n### PUT：传输文件\n\nPUT方法用来传输文件，要求请求报文的主体中包含文件内容，然后保存到URI指定的位置。\n\n但是由于HTTP/1.1的PUT方法没有验证机制，任何人都可以上传文件，所以存在安全性问题。现在一般只用来配合RESTFul API。\n\n### DELETE：删除文件\n\nDELETE方法与PUT方法正好相反，用于删除指定URI上的文件。现在一般也只用在RESTFul API上。\n\n### HEAD：获取报文首部\n\nHEAD方法用来获取报文的首部，确认URI的有效性和资源的更新日期。HEAD方法基本和GET方法一样，只是GET方法获取资源内容，而HEAD方法不获取资源内容，仅获取响应报文的首部。\n\n### OPTIONS：询问支持的方法\n\nOPTIONS方法用来查询针对请求URI指定的资源支持的方法。\n\n请求：\n\n    OPTIONS * HTTP/1.1\n    Host: www.example.com\n\n响应：\n\n    HTTP/1.1 200 OK\n    Allow：Get,Post,Head,Options\n\n### TRACE：追踪路径\n\nTRACE方法是让Web服务器端将之前的请求通信环回给客户端的方法。客户端通过TRACE方法可以查询发送出去的请求是怎样被加工修改的。\n\n由于TRACE方法容易引发XST（Cross-Site Tracing 跨站追踪）攻击，且本身就不常用，这里不作展开。\n\n### CONNECT：要求用隧道协议连接代理\n\nCONNECT方法要求在与代理服务器通信时建立隧道，实现使用隧道协议进行TCP通信。主要使用SSL（Secure Sockets Layer，安全套接字）和TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。\n\n## 建立持久连接以节省通信量\n\n在HTTP协议的初始版本中，每次发送HTTP协议都会经历一次TCP连接和关闭。随着Web的发展，一个网页会包含多个HTTP请求去加载JS文件、CSS文件、图片文件等等。如果每次HTTP请求都要断开TCP连接的话，就会带来额外的通信量。为此，HTTP/1.1新增了持久化连接（HTTP keep-alive）的方案。\n\n持久连接的特点是：只要任意一方没有明确需要断开TCP连接，那么客户端和服务器端将一直保持TCP连接，旨在一次TCP连接中进行多次HTTP请求和响应。\n\nHTTP/1.1中，所有的连接默认都是持久连接。当然这需要客户端和服务器端同时支持。\n\n持久连接使得多数请求能够以管线化的方式发送，可以让客户端并行发送多个HTTP请求，大大降低Web页面的显示速度。如果没有持久化连接，那么每次发起HTTP请求，下一个HTTP请求都得等待上一个HTTP请求得到响应后才能发送。\n\n## 使用Cookie进行状态管理\n\n一方面，无状态协议能够节省服务器计算资源的开销，另一方面由于无状态的存在使得状态管理成为一个难题。\n\n为了保留无状态协议同时实现状态管理，引入了Cookie技术，通过在请求和响应的报文中写入Cookie信息来控制客户端的状态。\n\n第一次请求（没有Cookie信息）：\n\n    GET /reader HTTP/1.1\n    Host: www.example.com\n    \n响应（服务器生成Cookie信息）：\n\n    HTTP/1.1 200 OK\n    Date: Mon, 10 Apr 2017 14:17:00 GMT\n    Server: Apache\n    Set-Cookie: sid=1342077140226724; path=/; expires=Wed, 10-OCT-12 07:12:20 GMT\n    Content-Type: text/plain; charset=UTF-8\n\n之后再发起请求时，会自带Cookie信息：\n\n    GET /other HTTP/1.1\n    Host: www.example.com\n    Cookie: sid=1342077140226724\n\n可见服务器通过Set-Cookie来通知客户端保存Cookie信息，客户端随后针对这个站点的HTTP请求都会在请求头部中加入Cookie字段。如此一来，服务器端在接收到请求时就能根据客户端传来的Cookie中的sid信息，来辨别客户端了，客户端的状态就能够得到保持。\n\n## 小结\n\nHTTP协议是通过请求和响应来进行通信的无状态协议。\n\n其中要注意HTTP请求的基本格式，其组成（请求方法，请求URI，版本协议，可选的首部字段，可选的传输实体）。HTTP响应的基本格式，以及其组成（版本协议，状态码，原因短语，可选的首部字段，资源实体的主体）。\n\n要熟悉常见的请求方法（GET、POST、PUT、DELETE、OPTIONS、TRACE、CONNECT）。能写出基本的请求报文。\n\n能说出持久化连接的实现方法及其优点，以及如何通过Cookie解决客户端状态保持的问题。\n\n\n\n","slug":"2017-04-11-HTTP：协议基础","published":1,"updated":"2017-08-06T12:14:48.000Z","_id":"cj60bzxkp000f1dor1ghp5u3k","comments":1,"photos":[],"link":"","content":"<h2 id=\"HTTP协议\"><a href=\"#HTTP协议\" class=\"headerlink\" title=\"HTTP协议\"></a>HTTP协议</h2><p>HTTP，HyperText Tranfer Protocol，超文本传输协议（超文本转移协议）。</p>\n<p>HTTP协议用于客户端和服务器端之间的通信。访问文本或图像等资源的一端称为服务端（即浏览器），提供资源相应的一端称为服务端（即Web服务器）。</p>\n<p>客户端向服务器端发起一个HTTP请求，服务器端在收到HTTP请求后根据请求报文中的内容进行响应，随后返回一个HTTP响应报文。客户端得到响应后便获取到了想要获取的资源或者相关错误信息（如资源不存在）。</p>\n<h2 id=\"HTTP通过请求和响应的交换达成通信\"><a href=\"#HTTP通过请求和响应的交换达成通信\" class=\"headerlink\" title=\"HTTP通过请求和响应的交换达成通信\"></a>HTTP通过请求和响应的交换达成通信</h2><p>HTTP协议规定，请求从客户端发出，最后服务器端响应该请求并返回。</p>\n<h3 id=\"HTTP请求\"><a href=\"#HTTP请求\" class=\"headerlink\" title=\"HTTP请求\"></a>HTTP请求</h3><p>客户端发送请求：</p>\n<pre><code>GET /index.html HTTP/1.1\nHost: www.example.com\n</code></pre><p>GET表示访问服务器的类型，称为方法（method）。随后的字符串<code>/index.html</code>指明了请求访问的资源对象，叫做请求URI（request-URI）。然后是HTTP/1.1，即HTTP的版本号。</p>\n<p>综上，这段请求的意思：通过GET方法，访问<code>www.example.com</code>这台主机上的<code>/index.html</code>页面资源。</p>\n<p>请求报文由以下几部分组成：</p>\n<ul>\n<li>请求方法</li>\n<li>请求URI</li>\n<li>HTTP版本协议</li>\n<li>可选的请求首部字段</li>\n<li>可选的内容实体</li>\n</ul>\n<p>以下是一个用POST方法发起的HTTP请求：</p>\n<pre><code>POST /user/login HTTP/1.1\nHost: www.example.com\nConnect: keep-alive\nContent-Type: application/x-www-form-urlencode\nContent-Length: 16\n\nuser=dxy&amp;pwd=123\n</code></pre><p>第一部分分别是请求方法（POST)，请求URI（/user/login），版本协议（HTTP/1.1）。接下来是请求首部字段（Host：…）。最后是内容实体（user=dxy&amp;pwd=123）。</p>\n<p>这段请求的意思是：用POST方法，向<code>www.example.com/user/login</code>提交一个表单数据，表单数据为<code>user=dxy&amp;pwd=123</code>。</p>\n<h3 id=\"HTTP响应\"><a href=\"#HTTP响应\" class=\"headerlink\" title=\"HTTP响应\"></a>HTTP响应</h3><p>服务器端发送响应：</p>\n<pre><code>HTTP/1.1 200 OK\nDate: Mon, 10 Apr 2017 14:17:00 GMT\nContent-Length: 3987\nContent-Type: text/html\n\n&lt;html&gt;\n...\n</code></pre><p>第一部分分别是版本协议（HTTP/1.1），响应状态码（200，status code）和原因短语（reason-phrase）。接下来是创建响应的日期时间，和其他首部字段的内容。最后是一行隔开，为资源实体的主体（entity body）。</p>\n<p>响应报文由以下几部分组成：</p>\n<ul>\n<li>HTTP版本协议</li>\n<li>状态码和原因短语</li>\n<li>创建响应的日期和可选的首部字段</li>\n<li>资源实体的主体</li>\n</ul>\n<h2 id=\"HTTP是不保存状态的协议\"><a href=\"#HTTP是不保存状态的协议\" class=\"headerlink\" title=\"HTTP是不保存状态的协议\"></a>HTTP是不保存状态的协议</h2><p>HTTP是一种无状态的协议（stateless）,这意味着HTTP协议不会保存请求和响应时的通信状态，即对请求和响应都不会做持久化处理。</p>\n<p>这就会导致用户在访问一个网站时，其访问的状态无法得到保存，因为每次发起的HTTP请求都是“新”的请求，与之前是否发送过无关。</p>\n<p>为了解决这个问题，可以通过Cookie技术来实现用户状态的保存。</p>\n<h2 id=\"请求URI定位资源\"><a href=\"#请求URI定位资源\" class=\"headerlink\" title=\"请求URI定位资源\"></a>请求URI定位资源</h2><p>HTTP协议使用URI（统一资源标识符）来定位互联网上的资源。当客户端请求访问某个资源时，需要指定该资源的URI作为HTTP请求中的请求URI。指定的方式由以下两种：<br>第一种是在Host首部字段中写明访问的主机地址（域名或IP）</p>\n<pre><code>GET /index.html HTTP/1.1\nHost: www.example.com\n</code></pre><p>第二种是完整的URI地址：</p>\n<pre><code>GET http://www.example.com/index.html HTTP/1.1\n</code></pre><p>如果不是访问特定资源而是对服务器发起请求，可以用*来代替URI。下面这个例子是查询HTTP服务器端支持的HTTP方法种类。</p>\n<pre><code>OPTIONS * HTTP/1.1\n</code></pre><h2 id=\"基本的HTTP请求方法\"><a href=\"#基本的HTTP请求方法\" class=\"headerlink\" title=\"基本的HTTP请求方法\"></a>基本的HTTP请求方法</h2><h3 id=\"GET：获取资源\"><a href=\"#GET：获取资源\" class=\"headerlink\" title=\"GET：获取资源\"></a>GET：获取资源</h3><p>GET方法用来请求访问已被URI识别的资源。指定的资源经过服务器端解析后返回响应的内容。<br>请求：</p>\n<pre><code>GET /index.html HTTP/1.1\nHost: www.example.com\nIf-Modified-Since: Mon, 10 Apr 2017 14:17:00 GMT\n</code></pre><p>响应：<br>返回2017年4月10日14点17分00秒后更新过的index.html内容，若没有更新过，则返回304 Not Modified。</p>\n<h3 id=\"POST：传输实体主体\"><a href=\"#POST：传输实体主体\" class=\"headerlink\" title=\"POST：传输实体主体\"></a>POST：传输实体主体</h3><p>尽管GET也可以传输实体主体，但是一般来说GET用于获取资源，而POST则专门用于传输资源或更新数据。</p>\n<p>请求：</p>\n<pre><code>POST /submit HTTP/1.1\nHost: www.example.com\nConTent-Length: 16\n\nuser=dxy&amp;pwd=123\n</code></pre><p>响应：<br>返回submit响应后的处理结果</p>\n<h3 id=\"PUT：传输文件\"><a href=\"#PUT：传输文件\" class=\"headerlink\" title=\"PUT：传输文件\"></a>PUT：传输文件</h3><p>PUT方法用来传输文件，要求请求报文的主体中包含文件内容，然后保存到URI指定的位置。</p>\n<p>但是由于HTTP/1.1的PUT方法没有验证机制，任何人都可以上传文件，所以存在安全性问题。现在一般只用来配合RESTFul API。</p>\n<h3 id=\"DELETE：删除文件\"><a href=\"#DELETE：删除文件\" class=\"headerlink\" title=\"DELETE：删除文件\"></a>DELETE：删除文件</h3><p>DELETE方法与PUT方法正好相反，用于删除指定URI上的文件。现在一般也只用在RESTFul API上。</p>\n<h3 id=\"HEAD：获取报文首部\"><a href=\"#HEAD：获取报文首部\" class=\"headerlink\" title=\"HEAD：获取报文首部\"></a>HEAD：获取报文首部</h3><p>HEAD方法用来获取报文的首部，确认URI的有效性和资源的更新日期。HEAD方法基本和GET方法一样，只是GET方法获取资源内容，而HEAD方法不获取资源内容，仅获取响应报文的首部。</p>\n<h3 id=\"OPTIONS：询问支持的方法\"><a href=\"#OPTIONS：询问支持的方法\" class=\"headerlink\" title=\"OPTIONS：询问支持的方法\"></a>OPTIONS：询问支持的方法</h3><p>OPTIONS方法用来查询针对请求URI指定的资源支持的方法。</p>\n<p>请求：</p>\n<pre><code>OPTIONS * HTTP/1.1\nHost: www.example.com\n</code></pre><p>响应：</p>\n<pre><code>HTTP/1.1 200 OK\nAllow：Get,Post,Head,Options\n</code></pre><h3 id=\"TRACE：追踪路径\"><a href=\"#TRACE：追踪路径\" class=\"headerlink\" title=\"TRACE：追踪路径\"></a>TRACE：追踪路径</h3><p>TRACE方法是让Web服务器端将之前的请求通信环回给客户端的方法。客户端通过TRACE方法可以查询发送出去的请求是怎样被加工修改的。</p>\n<p>由于TRACE方法容易引发XST（Cross-Site Tracing 跨站追踪）攻击，且本身就不常用，这里不作展开。</p>\n<h3 id=\"CONNECT：要求用隧道协议连接代理\"><a href=\"#CONNECT：要求用隧道协议连接代理\" class=\"headerlink\" title=\"CONNECT：要求用隧道协议连接代理\"></a>CONNECT：要求用隧道协议连接代理</h3><p>CONNECT方法要求在与代理服务器通信时建立隧道，实现使用隧道协议进行TCP通信。主要使用SSL（Secure Sockets Layer，安全套接字）和TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。</p>\n<h2 id=\"建立持久连接以节省通信量\"><a href=\"#建立持久连接以节省通信量\" class=\"headerlink\" title=\"建立持久连接以节省通信量\"></a>建立持久连接以节省通信量</h2><p>在HTTP协议的初始版本中，每次发送HTTP协议都会经历一次TCP连接和关闭。随着Web的发展，一个网页会包含多个HTTP请求去加载JS文件、CSS文件、图片文件等等。如果每次HTTP请求都要断开TCP连接的话，就会带来额外的通信量。为此，HTTP/1.1新增了持久化连接（HTTP keep-alive）的方案。</p>\n<p>持久连接的特点是：只要任意一方没有明确需要断开TCP连接，那么客户端和服务器端将一直保持TCP连接，旨在一次TCP连接中进行多次HTTP请求和响应。</p>\n<p>HTTP/1.1中，所有的连接默认都是持久连接。当然这需要客户端和服务器端同时支持。</p>\n<p>持久连接使得多数请求能够以管线化的方式发送，可以让客户端并行发送多个HTTP请求，大大降低Web页面的显示速度。如果没有持久化连接，那么每次发起HTTP请求，下一个HTTP请求都得等待上一个HTTP请求得到响应后才能发送。</p>\n<h2 id=\"使用Cookie进行状态管理\"><a href=\"#使用Cookie进行状态管理\" class=\"headerlink\" title=\"使用Cookie进行状态管理\"></a>使用Cookie进行状态管理</h2><p>一方面，无状态协议能够节省服务器计算资源的开销，另一方面由于无状态的存在使得状态管理成为一个难题。</p>\n<p>为了保留无状态协议同时实现状态管理，引入了Cookie技术，通过在请求和响应的报文中写入Cookie信息来控制客户端的状态。</p>\n<p>第一次请求（没有Cookie信息）：</p>\n<pre><code>GET /reader HTTP/1.1\nHost: www.example.com\n</code></pre><p>响应（服务器生成Cookie信息）：</p>\n<pre><code>HTTP/1.1 200 OK\nDate: Mon, 10 Apr 2017 14:17:00 GMT\nServer: Apache\nSet-Cookie: sid=1342077140226724; path=/; expires=Wed, 10-OCT-12 07:12:20 GMT\nContent-Type: text/plain; charset=UTF-8\n</code></pre><p>之后再发起请求时，会自带Cookie信息：</p>\n<pre><code>GET /other HTTP/1.1\nHost: www.example.com\nCookie: sid=1342077140226724\n</code></pre><p>可见服务器通过Set-Cookie来通知客户端保存Cookie信息，客户端随后针对这个站点的HTTP请求都会在请求头部中加入Cookie字段。如此一来，服务器端在接收到请求时就能根据客户端传来的Cookie中的sid信息，来辨别客户端了，客户端的状态就能够得到保持。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>HTTP协议是通过请求和响应来进行通信的无状态协议。</p>\n<p>其中要注意HTTP请求的基本格式，其组成（请求方法，请求URI，版本协议，可选的首部字段，可选的传输实体）。HTTP响应的基本格式，以及其组成（版本协议，状态码，原因短语，可选的首部字段，资源实体的主体）。</p>\n<p>要熟悉常见的请求方法（GET、POST、PUT、DELETE、OPTIONS、TRACE、CONNECT）。能写出基本的请求报文。</p>\n<p>能说出持久化连接的实现方法及其优点，以及如何通过Cookie解决客户端状态保持的问题。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"HTTP协议\"><a href=\"#HTTP协议\" class=\"headerlink\" title=\"HTTP协议\"></a>HTTP协议</h2><p>HTTP，HyperText Tranfer Protocol，超文本传输协议（超文本转移协议）。</p>\n<p>HTTP协议用于客户端和服务器端之间的通信。访问文本或图像等资源的一端称为服务端（即浏览器），提供资源相应的一端称为服务端（即Web服务器）。</p>\n<p>客户端向服务器端发起一个HTTP请求，服务器端在收到HTTP请求后根据请求报文中的内容进行响应，随后返回一个HTTP响应报文。客户端得到响应后便获取到了想要获取的资源或者相关错误信息（如资源不存在）。</p>\n<h2 id=\"HTTP通过请求和响应的交换达成通信\"><a href=\"#HTTP通过请求和响应的交换达成通信\" class=\"headerlink\" title=\"HTTP通过请求和响应的交换达成通信\"></a>HTTP通过请求和响应的交换达成通信</h2><p>HTTP协议规定，请求从客户端发出，最后服务器端响应该请求并返回。</p>\n<h3 id=\"HTTP请求\"><a href=\"#HTTP请求\" class=\"headerlink\" title=\"HTTP请求\"></a>HTTP请求</h3><p>客户端发送请求：</p>\n<pre><code>GET /index.html HTTP/1.1\nHost: www.example.com\n</code></pre><p>GET表示访问服务器的类型，称为方法（method）。随后的字符串<code>/index.html</code>指明了请求访问的资源对象，叫做请求URI（request-URI）。然后是HTTP/1.1，即HTTP的版本号。</p>\n<p>综上，这段请求的意思：通过GET方法，访问<code>www.example.com</code>这台主机上的<code>/index.html</code>页面资源。</p>\n<p>请求报文由以下几部分组成：</p>\n<ul>\n<li>请求方法</li>\n<li>请求URI</li>\n<li>HTTP版本协议</li>\n<li>可选的请求首部字段</li>\n<li>可选的内容实体</li>\n</ul>\n<p>以下是一个用POST方法发起的HTTP请求：</p>\n<pre><code>POST /user/login HTTP/1.1\nHost: www.example.com\nConnect: keep-alive\nContent-Type: application/x-www-form-urlencode\nContent-Length: 16\n\nuser=dxy&amp;pwd=123\n</code></pre><p>第一部分分别是请求方法（POST)，请求URI（/user/login），版本协议（HTTP/1.1）。接下来是请求首部字段（Host：…）。最后是内容实体（user=dxy&amp;pwd=123）。</p>\n<p>这段请求的意思是：用POST方法，向<code>www.example.com/user/login</code>提交一个表单数据，表单数据为<code>user=dxy&amp;pwd=123</code>。</p>\n<h3 id=\"HTTP响应\"><a href=\"#HTTP响应\" class=\"headerlink\" title=\"HTTP响应\"></a>HTTP响应</h3><p>服务器端发送响应：</p>\n<pre><code>HTTP/1.1 200 OK\nDate: Mon, 10 Apr 2017 14:17:00 GMT\nContent-Length: 3987\nContent-Type: text/html\n\n&lt;html&gt;\n...\n</code></pre><p>第一部分分别是版本协议（HTTP/1.1），响应状态码（200，status code）和原因短语（reason-phrase）。接下来是创建响应的日期时间，和其他首部字段的内容。最后是一行隔开，为资源实体的主体（entity body）。</p>\n<p>响应报文由以下几部分组成：</p>\n<ul>\n<li>HTTP版本协议</li>\n<li>状态码和原因短语</li>\n<li>创建响应的日期和可选的首部字段</li>\n<li>资源实体的主体</li>\n</ul>\n<h2 id=\"HTTP是不保存状态的协议\"><a href=\"#HTTP是不保存状态的协议\" class=\"headerlink\" title=\"HTTP是不保存状态的协议\"></a>HTTP是不保存状态的协议</h2><p>HTTP是一种无状态的协议（stateless）,这意味着HTTP协议不会保存请求和响应时的通信状态，即对请求和响应都不会做持久化处理。</p>\n<p>这就会导致用户在访问一个网站时，其访问的状态无法得到保存，因为每次发起的HTTP请求都是“新”的请求，与之前是否发送过无关。</p>\n<p>为了解决这个问题，可以通过Cookie技术来实现用户状态的保存。</p>\n<h2 id=\"请求URI定位资源\"><a href=\"#请求URI定位资源\" class=\"headerlink\" title=\"请求URI定位资源\"></a>请求URI定位资源</h2><p>HTTP协议使用URI（统一资源标识符）来定位互联网上的资源。当客户端请求访问某个资源时，需要指定该资源的URI作为HTTP请求中的请求URI。指定的方式由以下两种：<br>第一种是在Host首部字段中写明访问的主机地址（域名或IP）</p>\n<pre><code>GET /index.html HTTP/1.1\nHost: www.example.com\n</code></pre><p>第二种是完整的URI地址：</p>\n<pre><code>GET http://www.example.com/index.html HTTP/1.1\n</code></pre><p>如果不是访问特定资源而是对服务器发起请求，可以用*来代替URI。下面这个例子是查询HTTP服务器端支持的HTTP方法种类。</p>\n<pre><code>OPTIONS * HTTP/1.1\n</code></pre><h2 id=\"基本的HTTP请求方法\"><a href=\"#基本的HTTP请求方法\" class=\"headerlink\" title=\"基本的HTTP请求方法\"></a>基本的HTTP请求方法</h2><h3 id=\"GET：获取资源\"><a href=\"#GET：获取资源\" class=\"headerlink\" title=\"GET：获取资源\"></a>GET：获取资源</h3><p>GET方法用来请求访问已被URI识别的资源。指定的资源经过服务器端解析后返回响应的内容。<br>请求：</p>\n<pre><code>GET /index.html HTTP/1.1\nHost: www.example.com\nIf-Modified-Since: Mon, 10 Apr 2017 14:17:00 GMT\n</code></pre><p>响应：<br>返回2017年4月10日14点17分00秒后更新过的index.html内容，若没有更新过，则返回304 Not Modified。</p>\n<h3 id=\"POST：传输实体主体\"><a href=\"#POST：传输实体主体\" class=\"headerlink\" title=\"POST：传输实体主体\"></a>POST：传输实体主体</h3><p>尽管GET也可以传输实体主体，但是一般来说GET用于获取资源，而POST则专门用于传输资源或更新数据。</p>\n<p>请求：</p>\n<pre><code>POST /submit HTTP/1.1\nHost: www.example.com\nConTent-Length: 16\n\nuser=dxy&amp;pwd=123\n</code></pre><p>响应：<br>返回submit响应后的处理结果</p>\n<h3 id=\"PUT：传输文件\"><a href=\"#PUT：传输文件\" class=\"headerlink\" title=\"PUT：传输文件\"></a>PUT：传输文件</h3><p>PUT方法用来传输文件，要求请求报文的主体中包含文件内容，然后保存到URI指定的位置。</p>\n<p>但是由于HTTP/1.1的PUT方法没有验证机制，任何人都可以上传文件，所以存在安全性问题。现在一般只用来配合RESTFul API。</p>\n<h3 id=\"DELETE：删除文件\"><a href=\"#DELETE：删除文件\" class=\"headerlink\" title=\"DELETE：删除文件\"></a>DELETE：删除文件</h3><p>DELETE方法与PUT方法正好相反，用于删除指定URI上的文件。现在一般也只用在RESTFul API上。</p>\n<h3 id=\"HEAD：获取报文首部\"><a href=\"#HEAD：获取报文首部\" class=\"headerlink\" title=\"HEAD：获取报文首部\"></a>HEAD：获取报文首部</h3><p>HEAD方法用来获取报文的首部，确认URI的有效性和资源的更新日期。HEAD方法基本和GET方法一样，只是GET方法获取资源内容，而HEAD方法不获取资源内容，仅获取响应报文的首部。</p>\n<h3 id=\"OPTIONS：询问支持的方法\"><a href=\"#OPTIONS：询问支持的方法\" class=\"headerlink\" title=\"OPTIONS：询问支持的方法\"></a>OPTIONS：询问支持的方法</h3><p>OPTIONS方法用来查询针对请求URI指定的资源支持的方法。</p>\n<p>请求：</p>\n<pre><code>OPTIONS * HTTP/1.1\nHost: www.example.com\n</code></pre><p>响应：</p>\n<pre><code>HTTP/1.1 200 OK\nAllow：Get,Post,Head,Options\n</code></pre><h3 id=\"TRACE：追踪路径\"><a href=\"#TRACE：追踪路径\" class=\"headerlink\" title=\"TRACE：追踪路径\"></a>TRACE：追踪路径</h3><p>TRACE方法是让Web服务器端将之前的请求通信环回给客户端的方法。客户端通过TRACE方法可以查询发送出去的请求是怎样被加工修改的。</p>\n<p>由于TRACE方法容易引发XST（Cross-Site Tracing 跨站追踪）攻击，且本身就不常用，这里不作展开。</p>\n<h3 id=\"CONNECT：要求用隧道协议连接代理\"><a href=\"#CONNECT：要求用隧道协议连接代理\" class=\"headerlink\" title=\"CONNECT：要求用隧道协议连接代理\"></a>CONNECT：要求用隧道协议连接代理</h3><p>CONNECT方法要求在与代理服务器通信时建立隧道，实现使用隧道协议进行TCP通信。主要使用SSL（Secure Sockets Layer，安全套接字）和TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。</p>\n<h2 id=\"建立持久连接以节省通信量\"><a href=\"#建立持久连接以节省通信量\" class=\"headerlink\" title=\"建立持久连接以节省通信量\"></a>建立持久连接以节省通信量</h2><p>在HTTP协议的初始版本中，每次发送HTTP协议都会经历一次TCP连接和关闭。随着Web的发展，一个网页会包含多个HTTP请求去加载JS文件、CSS文件、图片文件等等。如果每次HTTP请求都要断开TCP连接的话，就会带来额外的通信量。为此，HTTP/1.1新增了持久化连接（HTTP keep-alive）的方案。</p>\n<p>持久连接的特点是：只要任意一方没有明确需要断开TCP连接，那么客户端和服务器端将一直保持TCP连接，旨在一次TCP连接中进行多次HTTP请求和响应。</p>\n<p>HTTP/1.1中，所有的连接默认都是持久连接。当然这需要客户端和服务器端同时支持。</p>\n<p>持久连接使得多数请求能够以管线化的方式发送，可以让客户端并行发送多个HTTP请求，大大降低Web页面的显示速度。如果没有持久化连接，那么每次发起HTTP请求，下一个HTTP请求都得等待上一个HTTP请求得到响应后才能发送。</p>\n<h2 id=\"使用Cookie进行状态管理\"><a href=\"#使用Cookie进行状态管理\" class=\"headerlink\" title=\"使用Cookie进行状态管理\"></a>使用Cookie进行状态管理</h2><p>一方面，无状态协议能够节省服务器计算资源的开销，另一方面由于无状态的存在使得状态管理成为一个难题。</p>\n<p>为了保留无状态协议同时实现状态管理，引入了Cookie技术，通过在请求和响应的报文中写入Cookie信息来控制客户端的状态。</p>\n<p>第一次请求（没有Cookie信息）：</p>\n<pre><code>GET /reader HTTP/1.1\nHost: www.example.com\n</code></pre><p>响应（服务器生成Cookie信息）：</p>\n<pre><code>HTTP/1.1 200 OK\nDate: Mon, 10 Apr 2017 14:17:00 GMT\nServer: Apache\nSet-Cookie: sid=1342077140226724; path=/; expires=Wed, 10-OCT-12 07:12:20 GMT\nContent-Type: text/plain; charset=UTF-8\n</code></pre><p>之后再发起请求时，会自带Cookie信息：</p>\n<pre><code>GET /other HTTP/1.1\nHost: www.example.com\nCookie: sid=1342077140226724\n</code></pre><p>可见服务器通过Set-Cookie来通知客户端保存Cookie信息，客户端随后针对这个站点的HTTP请求都会在请求头部中加入Cookie字段。如此一来，服务器端在接收到请求时就能根据客户端传来的Cookie中的sid信息，来辨别客户端了，客户端的状态就能够得到保持。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>HTTP协议是通过请求和响应来进行通信的无状态协议。</p>\n<p>其中要注意HTTP请求的基本格式，其组成（请求方法，请求URI，版本协议，可选的首部字段，可选的传输实体）。HTTP响应的基本格式，以及其组成（版本协议，状态码，原因短语，可选的首部字段，资源实体的主体）。</p>\n<p>要熟悉常见的请求方法（GET、POST、PUT、DELETE、OPTIONS、TRACE、CONNECT）。能写出基本的请求报文。</p>\n<p>能说出持久化连接的实现方法及其优点，以及如何通过Cookie解决客户端状态保持的问题。</p>\n"},{"layout":"post","title":"HTTP基础（2）：常见的状态码","date":"2017-04-12T05:00:00.000Z","_content":"HTTP状态码用于描述客户端向服务器端发送请求后的请求结果。通过状态码，客户端可以知道发出的HTTP是是否被正确处理。\n\n状态码由**三位数字**和**原因短语**组成，第一位指定了**响应类别**。\n\n状态码的类别：\n\n- 1XX：Informational 信息性状态码，表示服务器接收的请求正在被处理\n- 2XX：Success 成功状态码，表示请求被正常处理完毕\n- 3XX：Redirection 重定向状态码，表示客户端需要进行附加操作以完成请求\n- 4XX：Client Error 客户端错误状态码，表示因某种原因服务器无法处理请求\n- 5XX：Server Error 服务器错误状态码，表示服务器处理请求时出错\n\n## 2XX 成功\n\n### 200 OK\n\n表示客户端的请求被服务器端正常处理了。\n\n在这个状态码下，服务器的响应内容则依据请求方法决定。如果请求方法为GET，那么，对应请求资源的实体会一并返回；如果请求方法是HEAD，那么仅返回首部，而对应资源的实体不会被返回。\n\n### 204 No Content\n\n表示客户端的请求被服务器端正常处理，但是响应报文中不含有实体的主体部分。实际上204状态码下也不允许响应报文中有实体的主体部分。\n\n该响应码一般用于客户端向服务器端发送信息，而服务器端不必返回新信息的情况下使用。\n\n### 206 Parical Content\n\n该状态码表示客户端进行了范围请求（请求资源的一部分内容），而服务器成功执行了这部分的GET请求。响应报文中包含由Content-Range指定的实体内容。\n\n## 3XX 重定向\n\n### 301 Moved Permanently\n\n永久性重定向。该状态码表示请求的资源已经分配了新的URI，新的URI在Location首部字段中。\n\n### 302 Found\n\n临时性重定向。该状态码表示请求的资源已经分配了新的URI，希望客户端此次能以新的URI进行访问。\n\n注意302是临时性的重定向，请求的资源在将来还有可能换成别的URI。所以与永久性重定向的区别是，301是让客户端之后都用新的URI访问（相当于搬家，其住址URI不会轻易变更），而302时客户端之后仍然应该访问返回302的页面，以获得请求的资源最新的URI（相当于租房，其住址URI随时会变）。\n\n### 303 See Other\n\n该状态码表示由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源。\n\n303与302基本相似，唯一不同处是明确规定需要用GET方法去访问新的URI。例如当使用POST方法访问CGI（公共网关接口，Common Gateway Interface）程序，随后服务器端希望客户端以GET方法重定向到另一个URI上去时，返回303状态码。\n\n### 304 Not Modified\n\n该状态表示客户端发送附带条件的请求时（在请求头部中包含If-Match、If-Modified-Since、If-None-Match、If-Range、If-Unmodified-Since），服务器端允许请求访问资源，但因发生请求未满足条件，直接返回304。\n\n即表示服务器端的资源没有发生改变，客户端可以继续使用未过期的缓存资源。\n\n注意：304虽然在3XX 重定向类别中，但跟重定向实际上没有太大的关系。\n\n### 307 Temporary Redirect\n\n临时重定向。该状态码与302基本相同，不同的是307会遵照浏览器标准，不会从POST变成GET。\n\n而301、302响应状态码返回时，浏览器一般都会把POST改成GET（尽管301和302标准是禁止这样做的）并删除请求报文的主体，再发起请求。\n\n## 4XX 客户端错误\n\n### 400 Bad Request\n\n该状态码表示请求报文中存在语法错误，需要客户端修改请求内容后再次发送请求。\n\n注意：浏览器会像对待200 OK 一样对待该状态码（即不会像3XX那样子有别的行为）\n\n### 401 Unauthorized\n\n该状态码表示发送的请求需要有通过HTTP认证的认证信息。\n\n第一次返回401时，浏览器会弹出认证用的对话框。\n\n第二次返回401时，即表示用户认证失败。\n\n### 403 Forbidden\n\n该状态码表示对该资源的请求被服务器拒绝了。服务器没有义务给出拒绝的详细理由，但如果想作说明的话可以在实体的主体部分对原因进行描述。\n\n### 404 Not Found\n\n该状态码表示服务器无法找到请求的资源，是最常见的状态码。\n\n## 5XX 服务器端错误\n\n### 500 Internal Server Error\n\n该状态码表示服务器端在处理请求时发生了错误，例如无法连接数据库，或者服务端语言中有语法错误等等。\n\n### 503 Service Unavailable\n\n该状态码表示服务器端暂时处理超负载或正在进行停机维护，现在无法处理请求。\n\n如果事先知道服务器将在何时恢复，则最好写入Retry-After首部字段再返回给客户端。\n\n\n## 小结\n\n### 注意：\n\n状态码只在服务器端正确按照规范处理请求的前提下才有意义，不少服务器端会出现状态码与状态不一致的问题，需要在实际开发中注意。\n\n### 本文提及的常见的状态码\n\n- 200 OK\n- 202 No Content\n- 204 Partical Content\n- 301 Permanently Redirect\n- 302 Found\n- 303 See Other\n- 304 Not Modified\n- 307 Temporary Redirect\n- 400 Bad Request\n- 401 Unauthorized\n- 403 Forbbiden\n- 404 Not Found\n- 500 Interval Server Error\n- 503 Service Unavailable\n\n### 总结：\n\n本文整理了14种常见的状态码，其中包含4个状态类别，2XX，3XX，4XX，5XX，分别代表了成功，重定向，客户端错误和服务器端错误。\n\n2XX中，要注意202与200的区别，前者不含资源实体的主体。\n\n3XX中，要注意304与重定向无关，301和302一个是永久重定向，一个是临时重定向，且在标准中是不能把POST请求改成GET请求的（但是实际浏览器都会这么做）。303是302的相反版本，303要求POST改成GET请求。307是302的严格版，不允许把POST改成GET请求。\n\n4XX中，400和401都是与浏览器有关的，前者是请求有错误后者是没有HTTP认证信息；403和404与服务器端有关，403禁止浏览器访问特定资源，404则是服务器上没有特定的资源。\n\n5XX中，500是服务器端处理请求时出错，一般是数据库连接、代码有语法问题等等。503则是服务器负载过大或在维护，暂时无法提供服务。\n\n","source":"_posts/2017-04-12-HTTP：常见的状态码.markdown","raw":"---\nlayout: post\ntitle:  \"HTTP基础（2）：常见的状态码\"\ndate:   2017-04-12 13:00:00 +0800\ntags: http\n---\nHTTP状态码用于描述客户端向服务器端发送请求后的请求结果。通过状态码，客户端可以知道发出的HTTP是是否被正确处理。\n\n状态码由**三位数字**和**原因短语**组成，第一位指定了**响应类别**。\n\n状态码的类别：\n\n- 1XX：Informational 信息性状态码，表示服务器接收的请求正在被处理\n- 2XX：Success 成功状态码，表示请求被正常处理完毕\n- 3XX：Redirection 重定向状态码，表示客户端需要进行附加操作以完成请求\n- 4XX：Client Error 客户端错误状态码，表示因某种原因服务器无法处理请求\n- 5XX：Server Error 服务器错误状态码，表示服务器处理请求时出错\n\n## 2XX 成功\n\n### 200 OK\n\n表示客户端的请求被服务器端正常处理了。\n\n在这个状态码下，服务器的响应内容则依据请求方法决定。如果请求方法为GET，那么，对应请求资源的实体会一并返回；如果请求方法是HEAD，那么仅返回首部，而对应资源的实体不会被返回。\n\n### 204 No Content\n\n表示客户端的请求被服务器端正常处理，但是响应报文中不含有实体的主体部分。实际上204状态码下也不允许响应报文中有实体的主体部分。\n\n该响应码一般用于客户端向服务器端发送信息，而服务器端不必返回新信息的情况下使用。\n\n### 206 Parical Content\n\n该状态码表示客户端进行了范围请求（请求资源的一部分内容），而服务器成功执行了这部分的GET请求。响应报文中包含由Content-Range指定的实体内容。\n\n## 3XX 重定向\n\n### 301 Moved Permanently\n\n永久性重定向。该状态码表示请求的资源已经分配了新的URI，新的URI在Location首部字段中。\n\n### 302 Found\n\n临时性重定向。该状态码表示请求的资源已经分配了新的URI，希望客户端此次能以新的URI进行访问。\n\n注意302是临时性的重定向，请求的资源在将来还有可能换成别的URI。所以与永久性重定向的区别是，301是让客户端之后都用新的URI访问（相当于搬家，其住址URI不会轻易变更），而302时客户端之后仍然应该访问返回302的页面，以获得请求的资源最新的URI（相当于租房，其住址URI随时会变）。\n\n### 303 See Other\n\n该状态码表示由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源。\n\n303与302基本相似，唯一不同处是明确规定需要用GET方法去访问新的URI。例如当使用POST方法访问CGI（公共网关接口，Common Gateway Interface）程序，随后服务器端希望客户端以GET方法重定向到另一个URI上去时，返回303状态码。\n\n### 304 Not Modified\n\n该状态表示客户端发送附带条件的请求时（在请求头部中包含If-Match、If-Modified-Since、If-None-Match、If-Range、If-Unmodified-Since），服务器端允许请求访问资源，但因发生请求未满足条件，直接返回304。\n\n即表示服务器端的资源没有发生改变，客户端可以继续使用未过期的缓存资源。\n\n注意：304虽然在3XX 重定向类别中，但跟重定向实际上没有太大的关系。\n\n### 307 Temporary Redirect\n\n临时重定向。该状态码与302基本相同，不同的是307会遵照浏览器标准，不会从POST变成GET。\n\n而301、302响应状态码返回时，浏览器一般都会把POST改成GET（尽管301和302标准是禁止这样做的）并删除请求报文的主体，再发起请求。\n\n## 4XX 客户端错误\n\n### 400 Bad Request\n\n该状态码表示请求报文中存在语法错误，需要客户端修改请求内容后再次发送请求。\n\n注意：浏览器会像对待200 OK 一样对待该状态码（即不会像3XX那样子有别的行为）\n\n### 401 Unauthorized\n\n该状态码表示发送的请求需要有通过HTTP认证的认证信息。\n\n第一次返回401时，浏览器会弹出认证用的对话框。\n\n第二次返回401时，即表示用户认证失败。\n\n### 403 Forbidden\n\n该状态码表示对该资源的请求被服务器拒绝了。服务器没有义务给出拒绝的详细理由，但如果想作说明的话可以在实体的主体部分对原因进行描述。\n\n### 404 Not Found\n\n该状态码表示服务器无法找到请求的资源，是最常见的状态码。\n\n## 5XX 服务器端错误\n\n### 500 Internal Server Error\n\n该状态码表示服务器端在处理请求时发生了错误，例如无法连接数据库，或者服务端语言中有语法错误等等。\n\n### 503 Service Unavailable\n\n该状态码表示服务器端暂时处理超负载或正在进行停机维护，现在无法处理请求。\n\n如果事先知道服务器将在何时恢复，则最好写入Retry-After首部字段再返回给客户端。\n\n\n## 小结\n\n### 注意：\n\n状态码只在服务器端正确按照规范处理请求的前提下才有意义，不少服务器端会出现状态码与状态不一致的问题，需要在实际开发中注意。\n\n### 本文提及的常见的状态码\n\n- 200 OK\n- 202 No Content\n- 204 Partical Content\n- 301 Permanently Redirect\n- 302 Found\n- 303 See Other\n- 304 Not Modified\n- 307 Temporary Redirect\n- 400 Bad Request\n- 401 Unauthorized\n- 403 Forbbiden\n- 404 Not Found\n- 500 Interval Server Error\n- 503 Service Unavailable\n\n### 总结：\n\n本文整理了14种常见的状态码，其中包含4个状态类别，2XX，3XX，4XX，5XX，分别代表了成功，重定向，客户端错误和服务器端错误。\n\n2XX中，要注意202与200的区别，前者不含资源实体的主体。\n\n3XX中，要注意304与重定向无关，301和302一个是永久重定向，一个是临时重定向，且在标准中是不能把POST请求改成GET请求的（但是实际浏览器都会这么做）。303是302的相反版本，303要求POST改成GET请求。307是302的严格版，不允许把POST改成GET请求。\n\n4XX中，400和401都是与浏览器有关的，前者是请求有错误后者是没有HTTP认证信息；403和404与服务器端有关，403禁止浏览器访问特定资源，404则是服务器上没有特定的资源。\n\n5XX中，500是服务器端处理请求时出错，一般是数据库连接、代码有语法问题等等。503则是服务器负载过大或在维护，暂时无法提供服务。\n\n","slug":"2017-04-12-HTTP：常见的状态码","published":1,"updated":"2017-08-06T12:14:55.000Z","_id":"cj60bzxkr000g1doryl2l03f4","comments":1,"photos":[],"link":"","content":"<p>HTTP状态码用于描述客户端向服务器端发送请求后的请求结果。通过状态码，客户端可以知道发出的HTTP是是否被正确处理。</p>\n<p>状态码由<strong>三位数字</strong>和<strong>原因短语</strong>组成，第一位指定了<strong>响应类别</strong>。</p>\n<p>状态码的类别：</p>\n<ul>\n<li>1XX：Informational 信息性状态码，表示服务器接收的请求正在被处理</li>\n<li>2XX：Success 成功状态码，表示请求被正常处理完毕</li>\n<li>3XX：Redirection 重定向状态码，表示客户端需要进行附加操作以完成请求</li>\n<li>4XX：Client Error 客户端错误状态码，表示因某种原因服务器无法处理请求</li>\n<li>5XX：Server Error 服务器错误状态码，表示服务器处理请求时出错</li>\n</ul>\n<h2 id=\"2XX-成功\"><a href=\"#2XX-成功\" class=\"headerlink\" title=\"2XX 成功\"></a>2XX 成功</h2><h3 id=\"200-OK\"><a href=\"#200-OK\" class=\"headerlink\" title=\"200 OK\"></a>200 OK</h3><p>表示客户端的请求被服务器端正常处理了。</p>\n<p>在这个状态码下，服务器的响应内容则依据请求方法决定。如果请求方法为GET，那么，对应请求资源的实体会一并返回；如果请求方法是HEAD，那么仅返回首部，而对应资源的实体不会被返回。</p>\n<h3 id=\"204-No-Content\"><a href=\"#204-No-Content\" class=\"headerlink\" title=\"204 No Content\"></a>204 No Content</h3><p>表示客户端的请求被服务器端正常处理，但是响应报文中不含有实体的主体部分。实际上204状态码下也不允许响应报文中有实体的主体部分。</p>\n<p>该响应码一般用于客户端向服务器端发送信息，而服务器端不必返回新信息的情况下使用。</p>\n<h3 id=\"206-Parical-Content\"><a href=\"#206-Parical-Content\" class=\"headerlink\" title=\"206 Parical Content\"></a>206 Parical Content</h3><p>该状态码表示客户端进行了范围请求（请求资源的一部分内容），而服务器成功执行了这部分的GET请求。响应报文中包含由Content-Range指定的实体内容。</p>\n<h2 id=\"3XX-重定向\"><a href=\"#3XX-重定向\" class=\"headerlink\" title=\"3XX 重定向\"></a>3XX 重定向</h2><h3 id=\"301-Moved-Permanently\"><a href=\"#301-Moved-Permanently\" class=\"headerlink\" title=\"301 Moved Permanently\"></a>301 Moved Permanently</h3><p>永久性重定向。该状态码表示请求的资源已经分配了新的URI，新的URI在Location首部字段中。</p>\n<h3 id=\"302-Found\"><a href=\"#302-Found\" class=\"headerlink\" title=\"302 Found\"></a>302 Found</h3><p>临时性重定向。该状态码表示请求的资源已经分配了新的URI，希望客户端此次能以新的URI进行访问。</p>\n<p>注意302是临时性的重定向，请求的资源在将来还有可能换成别的URI。所以与永久性重定向的区别是，301是让客户端之后都用新的URI访问（相当于搬家，其住址URI不会轻易变更），而302时客户端之后仍然应该访问返回302的页面，以获得请求的资源最新的URI（相当于租房，其住址URI随时会变）。</p>\n<h3 id=\"303-See-Other\"><a href=\"#303-See-Other\" class=\"headerlink\" title=\"303 See Other\"></a>303 See Other</h3><p>该状态码表示由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源。</p>\n<p>303与302基本相似，唯一不同处是明确规定需要用GET方法去访问新的URI。例如当使用POST方法访问CGI（公共网关接口，Common Gateway Interface）程序，随后服务器端希望客户端以GET方法重定向到另一个URI上去时，返回303状态码。</p>\n<h3 id=\"304-Not-Modified\"><a href=\"#304-Not-Modified\" class=\"headerlink\" title=\"304 Not Modified\"></a>304 Not Modified</h3><p>该状态表示客户端发送附带条件的请求时（在请求头部中包含If-Match、If-Modified-Since、If-None-Match、If-Range、If-Unmodified-Since），服务器端允许请求访问资源，但因发生请求未满足条件，直接返回304。</p>\n<p>即表示服务器端的资源没有发生改变，客户端可以继续使用未过期的缓存资源。</p>\n<p>注意：304虽然在3XX 重定向类别中，但跟重定向实际上没有太大的关系。</p>\n<h3 id=\"307-Temporary-Redirect\"><a href=\"#307-Temporary-Redirect\" class=\"headerlink\" title=\"307 Temporary Redirect\"></a>307 Temporary Redirect</h3><p>临时重定向。该状态码与302基本相同，不同的是307会遵照浏览器标准，不会从POST变成GET。</p>\n<p>而301、302响应状态码返回时，浏览器一般都会把POST改成GET（尽管301和302标准是禁止这样做的）并删除请求报文的主体，再发起请求。</p>\n<h2 id=\"4XX-客户端错误\"><a href=\"#4XX-客户端错误\" class=\"headerlink\" title=\"4XX 客户端错误\"></a>4XX 客户端错误</h2><h3 id=\"400-Bad-Request\"><a href=\"#400-Bad-Request\" class=\"headerlink\" title=\"400 Bad Request\"></a>400 Bad Request</h3><p>该状态码表示请求报文中存在语法错误，需要客户端修改请求内容后再次发送请求。</p>\n<p>注意：浏览器会像对待200 OK 一样对待该状态码（即不会像3XX那样子有别的行为）</p>\n<h3 id=\"401-Unauthorized\"><a href=\"#401-Unauthorized\" class=\"headerlink\" title=\"401 Unauthorized\"></a>401 Unauthorized</h3><p>该状态码表示发送的请求需要有通过HTTP认证的认证信息。</p>\n<p>第一次返回401时，浏览器会弹出认证用的对话框。</p>\n<p>第二次返回401时，即表示用户认证失败。</p>\n<h3 id=\"403-Forbidden\"><a href=\"#403-Forbidden\" class=\"headerlink\" title=\"403 Forbidden\"></a>403 Forbidden</h3><p>该状态码表示对该资源的请求被服务器拒绝了。服务器没有义务给出拒绝的详细理由，但如果想作说明的话可以在实体的主体部分对原因进行描述。</p>\n<h3 id=\"404-Not-Found\"><a href=\"#404-Not-Found\" class=\"headerlink\" title=\"404 Not Found\"></a>404 Not Found</h3><p>该状态码表示服务器无法找到请求的资源，是最常见的状态码。</p>\n<h2 id=\"5XX-服务器端错误\"><a href=\"#5XX-服务器端错误\" class=\"headerlink\" title=\"5XX 服务器端错误\"></a>5XX 服务器端错误</h2><h3 id=\"500-Internal-Server-Error\"><a href=\"#500-Internal-Server-Error\" class=\"headerlink\" title=\"500 Internal Server Error\"></a>500 Internal Server Error</h3><p>该状态码表示服务器端在处理请求时发生了错误，例如无法连接数据库，或者服务端语言中有语法错误等等。</p>\n<h3 id=\"503-Service-Unavailable\"><a href=\"#503-Service-Unavailable\" class=\"headerlink\" title=\"503 Service Unavailable\"></a>503 Service Unavailable</h3><p>该状态码表示服务器端暂时处理超负载或正在进行停机维护，现在无法处理请求。</p>\n<p>如果事先知道服务器将在何时恢复，则最好写入Retry-After首部字段再返回给客户端。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><h3 id=\"注意：\"><a href=\"#注意：\" class=\"headerlink\" title=\"注意：\"></a>注意：</h3><p>状态码只在服务器端正确按照规范处理请求的前提下才有意义，不少服务器端会出现状态码与状态不一致的问题，需要在实际开发中注意。</p>\n<h3 id=\"本文提及的常见的状态码\"><a href=\"#本文提及的常见的状态码\" class=\"headerlink\" title=\"本文提及的常见的状态码\"></a>本文提及的常见的状态码</h3><ul>\n<li>200 OK</li>\n<li>202 No Content</li>\n<li>204 Partical Content</li>\n<li>301 Permanently Redirect</li>\n<li>302 Found</li>\n<li>303 See Other</li>\n<li>304 Not Modified</li>\n<li>307 Temporary Redirect</li>\n<li>400 Bad Request</li>\n<li>401 Unauthorized</li>\n<li>403 Forbbiden</li>\n<li>404 Not Found</li>\n<li>500 Interval Server Error</li>\n<li>503 Service Unavailable</li>\n</ul>\n<h3 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h3><p>本文整理了14种常见的状态码，其中包含4个状态类别，2XX，3XX，4XX，5XX，分别代表了成功，重定向，客户端错误和服务器端错误。</p>\n<p>2XX中，要注意202与200的区别，前者不含资源实体的主体。</p>\n<p>3XX中，要注意304与重定向无关，301和302一个是永久重定向，一个是临时重定向，且在标准中是不能把POST请求改成GET请求的（但是实际浏览器都会这么做）。303是302的相反版本，303要求POST改成GET请求。307是302的严格版，不允许把POST改成GET请求。</p>\n<p>4XX中，400和401都是与浏览器有关的，前者是请求有错误后者是没有HTTP认证信息；403和404与服务器端有关，403禁止浏览器访问特定资源，404则是服务器上没有特定的资源。</p>\n<p>5XX中，500是服务器端处理请求时出错，一般是数据库连接、代码有语法问题等等。503则是服务器负载过大或在维护，暂时无法提供服务。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>HTTP状态码用于描述客户端向服务器端发送请求后的请求结果。通过状态码，客户端可以知道发出的HTTP是是否被正确处理。</p>\n<p>状态码由<strong>三位数字</strong>和<strong>原因短语</strong>组成，第一位指定了<strong>响应类别</strong>。</p>\n<p>状态码的类别：</p>\n<ul>\n<li>1XX：Informational 信息性状态码，表示服务器接收的请求正在被处理</li>\n<li>2XX：Success 成功状态码，表示请求被正常处理完毕</li>\n<li>3XX：Redirection 重定向状态码，表示客户端需要进行附加操作以完成请求</li>\n<li>4XX：Client Error 客户端错误状态码，表示因某种原因服务器无法处理请求</li>\n<li>5XX：Server Error 服务器错误状态码，表示服务器处理请求时出错</li>\n</ul>\n<h2 id=\"2XX-成功\"><a href=\"#2XX-成功\" class=\"headerlink\" title=\"2XX 成功\"></a>2XX 成功</h2><h3 id=\"200-OK\"><a href=\"#200-OK\" class=\"headerlink\" title=\"200 OK\"></a>200 OK</h3><p>表示客户端的请求被服务器端正常处理了。</p>\n<p>在这个状态码下，服务器的响应内容则依据请求方法决定。如果请求方法为GET，那么，对应请求资源的实体会一并返回；如果请求方法是HEAD，那么仅返回首部，而对应资源的实体不会被返回。</p>\n<h3 id=\"204-No-Content\"><a href=\"#204-No-Content\" class=\"headerlink\" title=\"204 No Content\"></a>204 No Content</h3><p>表示客户端的请求被服务器端正常处理，但是响应报文中不含有实体的主体部分。实际上204状态码下也不允许响应报文中有实体的主体部分。</p>\n<p>该响应码一般用于客户端向服务器端发送信息，而服务器端不必返回新信息的情况下使用。</p>\n<h3 id=\"206-Parical-Content\"><a href=\"#206-Parical-Content\" class=\"headerlink\" title=\"206 Parical Content\"></a>206 Parical Content</h3><p>该状态码表示客户端进行了范围请求（请求资源的一部分内容），而服务器成功执行了这部分的GET请求。响应报文中包含由Content-Range指定的实体内容。</p>\n<h2 id=\"3XX-重定向\"><a href=\"#3XX-重定向\" class=\"headerlink\" title=\"3XX 重定向\"></a>3XX 重定向</h2><h3 id=\"301-Moved-Permanently\"><a href=\"#301-Moved-Permanently\" class=\"headerlink\" title=\"301 Moved Permanently\"></a>301 Moved Permanently</h3><p>永久性重定向。该状态码表示请求的资源已经分配了新的URI，新的URI在Location首部字段中。</p>\n<h3 id=\"302-Found\"><a href=\"#302-Found\" class=\"headerlink\" title=\"302 Found\"></a>302 Found</h3><p>临时性重定向。该状态码表示请求的资源已经分配了新的URI，希望客户端此次能以新的URI进行访问。</p>\n<p>注意302是临时性的重定向，请求的资源在将来还有可能换成别的URI。所以与永久性重定向的区别是，301是让客户端之后都用新的URI访问（相当于搬家，其住址URI不会轻易变更），而302时客户端之后仍然应该访问返回302的页面，以获得请求的资源最新的URI（相当于租房，其住址URI随时会变）。</p>\n<h3 id=\"303-See-Other\"><a href=\"#303-See-Other\" class=\"headerlink\" title=\"303 See Other\"></a>303 See Other</h3><p>该状态码表示由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源。</p>\n<p>303与302基本相似，唯一不同处是明确规定需要用GET方法去访问新的URI。例如当使用POST方法访问CGI（公共网关接口，Common Gateway Interface）程序，随后服务器端希望客户端以GET方法重定向到另一个URI上去时，返回303状态码。</p>\n<h3 id=\"304-Not-Modified\"><a href=\"#304-Not-Modified\" class=\"headerlink\" title=\"304 Not Modified\"></a>304 Not Modified</h3><p>该状态表示客户端发送附带条件的请求时（在请求头部中包含If-Match、If-Modified-Since、If-None-Match、If-Range、If-Unmodified-Since），服务器端允许请求访问资源，但因发生请求未满足条件，直接返回304。</p>\n<p>即表示服务器端的资源没有发生改变，客户端可以继续使用未过期的缓存资源。</p>\n<p>注意：304虽然在3XX 重定向类别中，但跟重定向实际上没有太大的关系。</p>\n<h3 id=\"307-Temporary-Redirect\"><a href=\"#307-Temporary-Redirect\" class=\"headerlink\" title=\"307 Temporary Redirect\"></a>307 Temporary Redirect</h3><p>临时重定向。该状态码与302基本相同，不同的是307会遵照浏览器标准，不会从POST变成GET。</p>\n<p>而301、302响应状态码返回时，浏览器一般都会把POST改成GET（尽管301和302标准是禁止这样做的）并删除请求报文的主体，再发起请求。</p>\n<h2 id=\"4XX-客户端错误\"><a href=\"#4XX-客户端错误\" class=\"headerlink\" title=\"4XX 客户端错误\"></a>4XX 客户端错误</h2><h3 id=\"400-Bad-Request\"><a href=\"#400-Bad-Request\" class=\"headerlink\" title=\"400 Bad Request\"></a>400 Bad Request</h3><p>该状态码表示请求报文中存在语法错误，需要客户端修改请求内容后再次发送请求。</p>\n<p>注意：浏览器会像对待200 OK 一样对待该状态码（即不会像3XX那样子有别的行为）</p>\n<h3 id=\"401-Unauthorized\"><a href=\"#401-Unauthorized\" class=\"headerlink\" title=\"401 Unauthorized\"></a>401 Unauthorized</h3><p>该状态码表示发送的请求需要有通过HTTP认证的认证信息。</p>\n<p>第一次返回401时，浏览器会弹出认证用的对话框。</p>\n<p>第二次返回401时，即表示用户认证失败。</p>\n<h3 id=\"403-Forbidden\"><a href=\"#403-Forbidden\" class=\"headerlink\" title=\"403 Forbidden\"></a>403 Forbidden</h3><p>该状态码表示对该资源的请求被服务器拒绝了。服务器没有义务给出拒绝的详细理由，但如果想作说明的话可以在实体的主体部分对原因进行描述。</p>\n<h3 id=\"404-Not-Found\"><a href=\"#404-Not-Found\" class=\"headerlink\" title=\"404 Not Found\"></a>404 Not Found</h3><p>该状态码表示服务器无法找到请求的资源，是最常见的状态码。</p>\n<h2 id=\"5XX-服务器端错误\"><a href=\"#5XX-服务器端错误\" class=\"headerlink\" title=\"5XX 服务器端错误\"></a>5XX 服务器端错误</h2><h3 id=\"500-Internal-Server-Error\"><a href=\"#500-Internal-Server-Error\" class=\"headerlink\" title=\"500 Internal Server Error\"></a>500 Internal Server Error</h3><p>该状态码表示服务器端在处理请求时发生了错误，例如无法连接数据库，或者服务端语言中有语法错误等等。</p>\n<h3 id=\"503-Service-Unavailable\"><a href=\"#503-Service-Unavailable\" class=\"headerlink\" title=\"503 Service Unavailable\"></a>503 Service Unavailable</h3><p>该状态码表示服务器端暂时处理超负载或正在进行停机维护，现在无法处理请求。</p>\n<p>如果事先知道服务器将在何时恢复，则最好写入Retry-After首部字段再返回给客户端。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><h3 id=\"注意：\"><a href=\"#注意：\" class=\"headerlink\" title=\"注意：\"></a>注意：</h3><p>状态码只在服务器端正确按照规范处理请求的前提下才有意义，不少服务器端会出现状态码与状态不一致的问题，需要在实际开发中注意。</p>\n<h3 id=\"本文提及的常见的状态码\"><a href=\"#本文提及的常见的状态码\" class=\"headerlink\" title=\"本文提及的常见的状态码\"></a>本文提及的常见的状态码</h3><ul>\n<li>200 OK</li>\n<li>202 No Content</li>\n<li>204 Partical Content</li>\n<li>301 Permanently Redirect</li>\n<li>302 Found</li>\n<li>303 See Other</li>\n<li>304 Not Modified</li>\n<li>307 Temporary Redirect</li>\n<li>400 Bad Request</li>\n<li>401 Unauthorized</li>\n<li>403 Forbbiden</li>\n<li>404 Not Found</li>\n<li>500 Interval Server Error</li>\n<li>503 Service Unavailable</li>\n</ul>\n<h3 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h3><p>本文整理了14种常见的状态码，其中包含4个状态类别，2XX，3XX，4XX，5XX，分别代表了成功，重定向，客户端错误和服务器端错误。</p>\n<p>2XX中，要注意202与200的区别，前者不含资源实体的主体。</p>\n<p>3XX中，要注意304与重定向无关，301和302一个是永久重定向，一个是临时重定向，且在标准中是不能把POST请求改成GET请求的（但是实际浏览器都会这么做）。303是302的相反版本，303要求POST改成GET请求。307是302的严格版，不允许把POST改成GET请求。</p>\n<p>4XX中，400和401都是与浏览器有关的，前者是请求有错误后者是没有HTTP认证信息；403和404与服务器端有关，403禁止浏览器访问特定资源，404则是服务器上没有特定的资源。</p>\n<p>5XX中，500是服务器端处理请求时出错，一般是数据库连接、代码有语法问题等等。503则是服务器负载过大或在维护，暂时无法提供服务。</p>\n"},{"layout":"post","title":"JavaScript：基本数据类型整理","date":"2017-04-11T08:21:00.000Z","_content":"- Undefined\n- Null\n- Boolean\n- String\n- Number\n\n## Undefined\n\nUndefined类型只有一个undefined值。\n\n用var声明但未赋值的变量，其值为undefined。\n\n    var a;\n    alert(a); //undefined\n\n使用一个未经声明的变量，typeof检测为undefined，但使用时会报错。\n\n    alert(a); //Error\n\n访问一个对象中不存在的属性时，其值为undefined，不会报错。\n\n    var o = {a:1};\n    alert(o.b); //undefined\n\n故undefined不能与typeof结合使用来判断一个变量是否被声明。\n\n    var a;\n    alert(typeof a); //undefined\n    alert(typeof b); //undefined ，变量b并没有被声明\n\n## Null\n\nNull表示一个空对象指针，typeof null会返回object。\n\n    var o = null;\n    alert(typeof o); //object\n\nnull可以作为空对象的占位符，故如果定义的变量将来用于存放对象，那么最好将该变量初始化为null，这样通过typeof可以判断相应的变量是否保存了一个对象的引用。\n\n    var o = null;\n    //...\n    if(o == null){\n        //do something\n    }\n\nundefined是派生自null的，故下面相等性测试返回的是true\n\n    alert(undefined == null); //true\n\n注意：undefined与null很大的一个区别在于，无论什么情况下，undefined一般都不会被用作显式地初始化变量，而null则推荐用来作为空对象指针。\n\n## Boolean\n\nECMAScript中，所有类型的值都有与Boolean类型对应的值，我们可以通过转型函数Boolean()来进行转换。\n\n- String类型，非空字符串均返回true，空字符串返回false\n- Number类型，非零数字值均返回true，0和NaN返回false\n- Object类型，任何非空对象均返回true，null返回false\n- Undefined类型，恒为false\n\n这个转换在流控制语句中如if语句中，会将if()中的变量自动转换成对应的Boolean值，以下代码是相等的：\n\n    var foo = \"bar\";\n    \n    if(foo){\n        //do something\n    }\n    \n    //上下两段代码是相同的\n    \n    if(Boolean(foo)){\n        //do something\n    }\n\n## Number\n\nNumber类型使用IEEE754格式来表示整数和浮点数，浮点数值的最高精度是17位小数，故在计算时会产生舍入误差的问题。所以永远不要测试某个特定的浮点数值。\n\n    var a = 0.1;\n    var b = 0.2;\n    alert(a+b == 0.3) //false，0.1+0.2会变成0.30000000000000004\n\n### 数值范围\n\n- 正无穷：+Infinity\n- 能够表示的最大正数：Number.MAX_VALUE\n- 能够表示的最小正数：Number.MIN_VALUE\n- 0\n- 能够表示的最大负数：-Number.MIN_VALUE\n- 能够表示的最小负数：-Number.MAX_VALUE\n- 负无穷：-Infinity\n\n### NaN\n\nNaN，Not a Number，用于表示一个本来要返回数值的操作数未返回数值的情况，此时不抛出错误，也不会影响其他代码的执行。\n\n除了类型转换时会出现NaN之外，0/0也会返回NaN。\n\n特点：\n\n- NaN与任何数值操作均为NaN\n- NaN与任何值都不相等，包括NaN自身\n\n可以用isNaN()函数来判断一个值是否“不是数值”，isNaN()在接收到一个参数后，会尝试将这个值转换为数值。\n\n    isNaN(NaN); //true\n    isNaN(10); //false\n    isNaN(\"10\"); //false，字符串\"10\"可以转换成数字10\n    isNaN(\"blue\"); //true，字符串\"blue\"不能被转换成数字\n    isNaN(true); //false，布尔值true可以被转换成数字1\n    isNaN(false); //false，布尔值false可以被转换成数字0\n\n### 数值转换\n\n- Number()，转型函数\n- parseInt()，全局函数\n- parseFloat()，全局函数\n\n#### Number()\n\n- Boolean，true 1，false 0\n- Null，null 0\n- Undefined，undefined NaN\n- String，字符串只包含数字时（包括+/-，整数/浮点数） 对应数字，空字符串\"\" 0\n- Object，先valueOf()若NaN则toString()，转换规则跟上述一致\n\n\n#### parseInt()\n\nparseInt接收两个参数，第一个是待转换的值，第二个是基数（二进制、八进制、十进制、十六进制），其他进制不常用，以下仅讨论十进制。\n\n与Number()的几个区别是，\n\n 1. Number()接收任意类型的参数，而parseInt()只接收String，非String一律为NaN。\n 2. parseInt()会对传入的字符串从左到右进行遍历，从第一个数字或正负号开始，到第一个非数字结束，字符串中不存在数字就一定会是NaN，忽略其他非数字的字符；Number()中如果字符串存在非数字字符就会是NaN。\n 3. 空字符串Number()转换成0，parseInt()转换成NaN。\n 4. parseInt()只会转换成整数\n\n示例：\n\n    var n0 = true;\n    alert(Number(n0)); //1\n    alert(parseInt(n0,10)); //NaN\n    \n    var n1 = \"1234blue\";\n    alert(Number(n1)); //NaN\n    alert(parseInt(n1,10)); //1234\n\n    var n2 = \"\";\n    alert(Number(n2)); //0\n    alert(parseInt(n2,10)); //NaN\n    \n    var n3 = \"22.5\";\n    alert(Number(n3)); //22.5\n    alert(parseInt(n3,10)); //22\n\n#### parseFloat()\n\nparseFloat()与parseInt()的解析机制基本相同，以下为两个比较主要的区别：\n\n 1. parseFloat()没有第二个参数，只解析十进制\n 2. parseFloat()识别小数点，遇到第二个小数点停止解析\n\n## String\n\nString类型用于表示由零或多个16位Unicode字符组成的字符序列，即字符串。\n\n用双引号表示的字符串与用单引号表示的字符串完全相同。\n\n### 字符字面量\n\n即转义序列，用于表示非打印字符或其他用途的字符。常见的有：\n\n- \\n 换行\n- \\t 制表\n- \\r 回车\n- \\b 退格\n- \\xnn 以十六进制代码nn表示一个字符（n为0~F）\n- \\unnnn 以十六进制代码nnnn表示的一个Unicode字符（其中n为0~f)\n\n注意：\\unnnn类型的字符虽然在代码中占6个字符，但是在length属性中只占1个字符。\n\n但是如果字符串中包含双字节字符，那么length属性可能不会精确地返回字符串中的字符数目。\n\n### 字符串的特点\n\n字符串是不可变的，一旦创建，它们的值就不能改变。要改变的话，则会先销毁原来的字符串，再用一个包含新值的字符串填充该变量。\n\n    var lang = \"Java\";\n    lang = lang + \"Script\";\n\n 1. 首先创建一个10字符的新字符串\n 2. 接着填充\"Java\"和\"Script\"\n 3. 将新字符串赋值给lang\n 4. 删除\"Java\"和\"Script\"\n\n### 转换为字符串\n\n转换为字符串有两种方法，分别是toString()和String()。\n\n还有一种是用加号操作符，这里先不作讨论。\n\n#### toString()\n\n几乎每个值都有toString()方法，返回响应值的字符串表现。\n\n- Number，即数字本身，还可以传递一个参数以指定基数\n- Boolean，即\"true\"或\"false\"\n- String，即字符串本身\n\n示例：\n\n    var num = 10;\n    alert(num.toString()); //10，默认十进制\n    alert(num.toString(2)); //1010，二进制\n    alert(num.toString(16)); //a,十六进制\n\nNull和Undefined没有toString方法。\n\n#### String()\n\n就像Number()和parseInt()的关系一样，String()转型函数能够接收任意类型的值作为参数，但是区别在于Number()和parseInt()之间相对平等，而String()更像是toString()的超集。\n\n- 如果传入的值有toString()方法，则调用该方法\n- Null类型，返回\"null\"\n- Undefined类型，返回\"undefined\"\n\n不过String()在转换数值时就不能指定基数了。\n\n## 小结\n\nJavaScript基本数据类型有5种，分别是Null，Undefined，Boolean，Number和String。其中，Undefined派生自Null，故null==undefined返回true。\n\nBoolean只有true和false两个值，注意Boolean()转型函数的转换规则，以及与if()等流程控制语句的关系。\n\nNumber类型不区分整数和浮点数，要注意其数值范围以及精度的问题，要当心0.1+0.2不等于0.3的判断问题。还有对NaN的理解，注意NaN与任何值都不相等的特性。此外，Number()转型函数，parseInt()和parseFloat()各有机制上的共通点和不同处，要做好区别。\n\nString类型，包含字符字面量，转义字符，字符串的特点以及字符串的转换，重点理解如何使用toString()和String()来进行字符串转换。\n\n\n","source":"_posts/2017-04-11-JavaScript：基本数据类型整理.markdown","raw":"---\nlayout: post\ntitle:  \"JavaScript：基本数据类型整理\"\ndate:   2017-04-11 16:21:00 +0800\ntags: javascript\n---\n- Undefined\n- Null\n- Boolean\n- String\n- Number\n\n## Undefined\n\nUndefined类型只有一个undefined值。\n\n用var声明但未赋值的变量，其值为undefined。\n\n    var a;\n    alert(a); //undefined\n\n使用一个未经声明的变量，typeof检测为undefined，但使用时会报错。\n\n    alert(a); //Error\n\n访问一个对象中不存在的属性时，其值为undefined，不会报错。\n\n    var o = {a:1};\n    alert(o.b); //undefined\n\n故undefined不能与typeof结合使用来判断一个变量是否被声明。\n\n    var a;\n    alert(typeof a); //undefined\n    alert(typeof b); //undefined ，变量b并没有被声明\n\n## Null\n\nNull表示一个空对象指针，typeof null会返回object。\n\n    var o = null;\n    alert(typeof o); //object\n\nnull可以作为空对象的占位符，故如果定义的变量将来用于存放对象，那么最好将该变量初始化为null，这样通过typeof可以判断相应的变量是否保存了一个对象的引用。\n\n    var o = null;\n    //...\n    if(o == null){\n        //do something\n    }\n\nundefined是派生自null的，故下面相等性测试返回的是true\n\n    alert(undefined == null); //true\n\n注意：undefined与null很大的一个区别在于，无论什么情况下，undefined一般都不会被用作显式地初始化变量，而null则推荐用来作为空对象指针。\n\n## Boolean\n\nECMAScript中，所有类型的值都有与Boolean类型对应的值，我们可以通过转型函数Boolean()来进行转换。\n\n- String类型，非空字符串均返回true，空字符串返回false\n- Number类型，非零数字值均返回true，0和NaN返回false\n- Object类型，任何非空对象均返回true，null返回false\n- Undefined类型，恒为false\n\n这个转换在流控制语句中如if语句中，会将if()中的变量自动转换成对应的Boolean值，以下代码是相等的：\n\n    var foo = \"bar\";\n    \n    if(foo){\n        //do something\n    }\n    \n    //上下两段代码是相同的\n    \n    if(Boolean(foo)){\n        //do something\n    }\n\n## Number\n\nNumber类型使用IEEE754格式来表示整数和浮点数，浮点数值的最高精度是17位小数，故在计算时会产生舍入误差的问题。所以永远不要测试某个特定的浮点数值。\n\n    var a = 0.1;\n    var b = 0.2;\n    alert(a+b == 0.3) //false，0.1+0.2会变成0.30000000000000004\n\n### 数值范围\n\n- 正无穷：+Infinity\n- 能够表示的最大正数：Number.MAX_VALUE\n- 能够表示的最小正数：Number.MIN_VALUE\n- 0\n- 能够表示的最大负数：-Number.MIN_VALUE\n- 能够表示的最小负数：-Number.MAX_VALUE\n- 负无穷：-Infinity\n\n### NaN\n\nNaN，Not a Number，用于表示一个本来要返回数值的操作数未返回数值的情况，此时不抛出错误，也不会影响其他代码的执行。\n\n除了类型转换时会出现NaN之外，0/0也会返回NaN。\n\n特点：\n\n- NaN与任何数值操作均为NaN\n- NaN与任何值都不相等，包括NaN自身\n\n可以用isNaN()函数来判断一个值是否“不是数值”，isNaN()在接收到一个参数后，会尝试将这个值转换为数值。\n\n    isNaN(NaN); //true\n    isNaN(10); //false\n    isNaN(\"10\"); //false，字符串\"10\"可以转换成数字10\n    isNaN(\"blue\"); //true，字符串\"blue\"不能被转换成数字\n    isNaN(true); //false，布尔值true可以被转换成数字1\n    isNaN(false); //false，布尔值false可以被转换成数字0\n\n### 数值转换\n\n- Number()，转型函数\n- parseInt()，全局函数\n- parseFloat()，全局函数\n\n#### Number()\n\n- Boolean，true 1，false 0\n- Null，null 0\n- Undefined，undefined NaN\n- String，字符串只包含数字时（包括+/-，整数/浮点数） 对应数字，空字符串\"\" 0\n- Object，先valueOf()若NaN则toString()，转换规则跟上述一致\n\n\n#### parseInt()\n\nparseInt接收两个参数，第一个是待转换的值，第二个是基数（二进制、八进制、十进制、十六进制），其他进制不常用，以下仅讨论十进制。\n\n与Number()的几个区别是，\n\n 1. Number()接收任意类型的参数，而parseInt()只接收String，非String一律为NaN。\n 2. parseInt()会对传入的字符串从左到右进行遍历，从第一个数字或正负号开始，到第一个非数字结束，字符串中不存在数字就一定会是NaN，忽略其他非数字的字符；Number()中如果字符串存在非数字字符就会是NaN。\n 3. 空字符串Number()转换成0，parseInt()转换成NaN。\n 4. parseInt()只会转换成整数\n\n示例：\n\n    var n0 = true;\n    alert(Number(n0)); //1\n    alert(parseInt(n0,10)); //NaN\n    \n    var n1 = \"1234blue\";\n    alert(Number(n1)); //NaN\n    alert(parseInt(n1,10)); //1234\n\n    var n2 = \"\";\n    alert(Number(n2)); //0\n    alert(parseInt(n2,10)); //NaN\n    \n    var n3 = \"22.5\";\n    alert(Number(n3)); //22.5\n    alert(parseInt(n3,10)); //22\n\n#### parseFloat()\n\nparseFloat()与parseInt()的解析机制基本相同，以下为两个比较主要的区别：\n\n 1. parseFloat()没有第二个参数，只解析十进制\n 2. parseFloat()识别小数点，遇到第二个小数点停止解析\n\n## String\n\nString类型用于表示由零或多个16位Unicode字符组成的字符序列，即字符串。\n\n用双引号表示的字符串与用单引号表示的字符串完全相同。\n\n### 字符字面量\n\n即转义序列，用于表示非打印字符或其他用途的字符。常见的有：\n\n- \\n 换行\n- \\t 制表\n- \\r 回车\n- \\b 退格\n- \\xnn 以十六进制代码nn表示一个字符（n为0~F）\n- \\unnnn 以十六进制代码nnnn表示的一个Unicode字符（其中n为0~f)\n\n注意：\\unnnn类型的字符虽然在代码中占6个字符，但是在length属性中只占1个字符。\n\n但是如果字符串中包含双字节字符，那么length属性可能不会精确地返回字符串中的字符数目。\n\n### 字符串的特点\n\n字符串是不可变的，一旦创建，它们的值就不能改变。要改变的话，则会先销毁原来的字符串，再用一个包含新值的字符串填充该变量。\n\n    var lang = \"Java\";\n    lang = lang + \"Script\";\n\n 1. 首先创建一个10字符的新字符串\n 2. 接着填充\"Java\"和\"Script\"\n 3. 将新字符串赋值给lang\n 4. 删除\"Java\"和\"Script\"\n\n### 转换为字符串\n\n转换为字符串有两种方法，分别是toString()和String()。\n\n还有一种是用加号操作符，这里先不作讨论。\n\n#### toString()\n\n几乎每个值都有toString()方法，返回响应值的字符串表现。\n\n- Number，即数字本身，还可以传递一个参数以指定基数\n- Boolean，即\"true\"或\"false\"\n- String，即字符串本身\n\n示例：\n\n    var num = 10;\n    alert(num.toString()); //10，默认十进制\n    alert(num.toString(2)); //1010，二进制\n    alert(num.toString(16)); //a,十六进制\n\nNull和Undefined没有toString方法。\n\n#### String()\n\n就像Number()和parseInt()的关系一样，String()转型函数能够接收任意类型的值作为参数，但是区别在于Number()和parseInt()之间相对平等，而String()更像是toString()的超集。\n\n- 如果传入的值有toString()方法，则调用该方法\n- Null类型，返回\"null\"\n- Undefined类型，返回\"undefined\"\n\n不过String()在转换数值时就不能指定基数了。\n\n## 小结\n\nJavaScript基本数据类型有5种，分别是Null，Undefined，Boolean，Number和String。其中，Undefined派生自Null，故null==undefined返回true。\n\nBoolean只有true和false两个值，注意Boolean()转型函数的转换规则，以及与if()等流程控制语句的关系。\n\nNumber类型不区分整数和浮点数，要注意其数值范围以及精度的问题，要当心0.1+0.2不等于0.3的判断问题。还有对NaN的理解，注意NaN与任何值都不相等的特性。此外，Number()转型函数，parseInt()和parseFloat()各有机制上的共通点和不同处，要做好区别。\n\nString类型，包含字符字面量，转义字符，字符串的特点以及字符串的转换，重点理解如何使用toString()和String()来进行字符串转换。\n\n\n","slug":"2017-04-11-JavaScript：基本数据类型整理","published":1,"updated":"2017-08-06T12:14:51.000Z","_id":"cj60bzxks000j1dorj0r53adw","comments":1,"photos":[],"link":"","content":"<ul>\n<li>Undefined</li>\n<li>Null</li>\n<li>Boolean</li>\n<li>String</li>\n<li>Number</li>\n</ul>\n<h2 id=\"Undefined\"><a href=\"#Undefined\" class=\"headerlink\" title=\"Undefined\"></a>Undefined</h2><p>Undefined类型只有一个undefined值。</p>\n<p>用var声明但未赋值的变量，其值为undefined。</p>\n<pre><code>var a;\nalert(a); //undefined\n</code></pre><p>使用一个未经声明的变量，typeof检测为undefined，但使用时会报错。</p>\n<pre><code>alert(a); //Error\n</code></pre><p>访问一个对象中不存在的属性时，其值为undefined，不会报错。</p>\n<pre><code>var o = {a:1};\nalert(o.b); //undefined\n</code></pre><p>故undefined不能与typeof结合使用来判断一个变量是否被声明。</p>\n<pre><code>var a;\nalert(typeof a); //undefined\nalert(typeof b); //undefined ，变量b并没有被声明\n</code></pre><h2 id=\"Null\"><a href=\"#Null\" class=\"headerlink\" title=\"Null\"></a>Null</h2><p>Null表示一个空对象指针，typeof null会返回object。</p>\n<pre><code>var o = null;\nalert(typeof o); //object\n</code></pre><p>null可以作为空对象的占位符，故如果定义的变量将来用于存放对象，那么最好将该变量初始化为null，这样通过typeof可以判断相应的变量是否保存了一个对象的引用。</p>\n<pre><code>var o = null;\n//...\nif(o == null){\n    //do something\n}\n</code></pre><p>undefined是派生自null的，故下面相等性测试返回的是true</p>\n<pre><code>alert(undefined == null); //true\n</code></pre><p>注意：undefined与null很大的一个区别在于，无论什么情况下，undefined一般都不会被用作显式地初始化变量，而null则推荐用来作为空对象指针。</p>\n<h2 id=\"Boolean\"><a href=\"#Boolean\" class=\"headerlink\" title=\"Boolean\"></a>Boolean</h2><p>ECMAScript中，所有类型的值都有与Boolean类型对应的值，我们可以通过转型函数Boolean()来进行转换。</p>\n<ul>\n<li>String类型，非空字符串均返回true，空字符串返回false</li>\n<li>Number类型，非零数字值均返回true，0和NaN返回false</li>\n<li>Object类型，任何非空对象均返回true，null返回false</li>\n<li>Undefined类型，恒为false</li>\n</ul>\n<p>这个转换在流控制语句中如if语句中，会将if()中的变量自动转换成对应的Boolean值，以下代码是相等的：</p>\n<pre><code>var foo = &quot;bar&quot;;\n\nif(foo){\n    //do something\n}\n\n//上下两段代码是相同的\n\nif(Boolean(foo)){\n    //do something\n}\n</code></pre><h2 id=\"Number\"><a href=\"#Number\" class=\"headerlink\" title=\"Number\"></a>Number</h2><p>Number类型使用IEEE754格式来表示整数和浮点数，浮点数值的最高精度是17位小数，故在计算时会产生舍入误差的问题。所以永远不要测试某个特定的浮点数值。</p>\n<pre><code>var a = 0.1;\nvar b = 0.2;\nalert(a+b == 0.3) //false，0.1+0.2会变成0.30000000000000004\n</code></pre><h3 id=\"数值范围\"><a href=\"#数值范围\" class=\"headerlink\" title=\"数值范围\"></a>数值范围</h3><ul>\n<li>正无穷：+Infinity</li>\n<li>能够表示的最大正数：Number.MAX_VALUE</li>\n<li>能够表示的最小正数：Number.MIN_VALUE</li>\n<li>0</li>\n<li>能够表示的最大负数：-Number.MIN_VALUE</li>\n<li>能够表示的最小负数：-Number.MAX_VALUE</li>\n<li>负无穷：-Infinity</li>\n</ul>\n<h3 id=\"NaN\"><a href=\"#NaN\" class=\"headerlink\" title=\"NaN\"></a>NaN</h3><p>NaN，Not a Number，用于表示一个本来要返回数值的操作数未返回数值的情况，此时不抛出错误，也不会影响其他代码的执行。</p>\n<p>除了类型转换时会出现NaN之外，0/0也会返回NaN。</p>\n<p>特点：</p>\n<ul>\n<li>NaN与任何数值操作均为NaN</li>\n<li>NaN与任何值都不相等，包括NaN自身</li>\n</ul>\n<p>可以用isNaN()函数来判断一个值是否“不是数值”，isNaN()在接收到一个参数后，会尝试将这个值转换为数值。</p>\n<pre><code>isNaN(NaN); //true\nisNaN(10); //false\nisNaN(&quot;10&quot;); //false，字符串&quot;10&quot;可以转换成数字10\nisNaN(&quot;blue&quot;); //true，字符串&quot;blue&quot;不能被转换成数字\nisNaN(true); //false，布尔值true可以被转换成数字1\nisNaN(false); //false，布尔值false可以被转换成数字0\n</code></pre><h3 id=\"数值转换\"><a href=\"#数值转换\" class=\"headerlink\" title=\"数值转换\"></a>数值转换</h3><ul>\n<li>Number()，转型函数</li>\n<li>parseInt()，全局函数</li>\n<li>parseFloat()，全局函数</li>\n</ul>\n<h4 id=\"Number-1\"><a href=\"#Number-1\" class=\"headerlink\" title=\"Number()\"></a>Number()</h4><ul>\n<li>Boolean，true 1，false 0</li>\n<li>Null，null 0</li>\n<li>Undefined，undefined NaN</li>\n<li>String，字符串只包含数字时（包括+/-，整数/浮点数） 对应数字，空字符串”” 0</li>\n<li>Object，先valueOf()若NaN则toString()，转换规则跟上述一致</li>\n</ul>\n<h4 id=\"parseInt\"><a href=\"#parseInt\" class=\"headerlink\" title=\"parseInt()\"></a>parseInt()</h4><p>parseInt接收两个参数，第一个是待转换的值，第二个是基数（二进制、八进制、十进制、十六进制），其他进制不常用，以下仅讨论十进制。</p>\n<p>与Number()的几个区别是，</p>\n<ol>\n<li>Number()接收任意类型的参数，而parseInt()只接收String，非String一律为NaN。</li>\n<li>parseInt()会对传入的字符串从左到右进行遍历，从第一个数字或正负号开始，到第一个非数字结束，字符串中不存在数字就一定会是NaN，忽略其他非数字的字符；Number()中如果字符串存在非数字字符就会是NaN。</li>\n<li>空字符串Number()转换成0，parseInt()转换成NaN。</li>\n<li>parseInt()只会转换成整数</li>\n</ol>\n<p>示例：</p>\n<pre><code>var n0 = true;\nalert(Number(n0)); //1\nalert(parseInt(n0,10)); //NaN\n\nvar n1 = &quot;1234blue&quot;;\nalert(Number(n1)); //NaN\nalert(parseInt(n1,10)); //1234\n\nvar n2 = &quot;&quot;;\nalert(Number(n2)); //0\nalert(parseInt(n2,10)); //NaN\n\nvar n3 = &quot;22.5&quot;;\nalert(Number(n3)); //22.5\nalert(parseInt(n3,10)); //22\n</code></pre><h4 id=\"parseFloat\"><a href=\"#parseFloat\" class=\"headerlink\" title=\"parseFloat()\"></a>parseFloat()</h4><p>parseFloat()与parseInt()的解析机制基本相同，以下为两个比较主要的区别：</p>\n<ol>\n<li>parseFloat()没有第二个参数，只解析十进制</li>\n<li>parseFloat()识别小数点，遇到第二个小数点停止解析</li>\n</ol>\n<h2 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h2><p>String类型用于表示由零或多个16位Unicode字符组成的字符序列，即字符串。</p>\n<p>用双引号表示的字符串与用单引号表示的字符串完全相同。</p>\n<h3 id=\"字符字面量\"><a href=\"#字符字面量\" class=\"headerlink\" title=\"字符字面量\"></a>字符字面量</h3><p>即转义序列，用于表示非打印字符或其他用途的字符。常见的有：</p>\n<ul>\n<li>\\n 换行</li>\n<li>\\t 制表</li>\n<li>\\r 回车</li>\n<li>\\b 退格</li>\n<li>\\xnn 以十六进制代码nn表示一个字符（n为0~F）</li>\n<li>\\unnnn 以十六进制代码nnnn表示的一个Unicode字符（其中n为0~f)</li>\n</ul>\n<p>注意：\\unnnn类型的字符虽然在代码中占6个字符，但是在length属性中只占1个字符。</p>\n<p>但是如果字符串中包含双字节字符，那么length属性可能不会精确地返回字符串中的字符数目。</p>\n<h3 id=\"字符串的特点\"><a href=\"#字符串的特点\" class=\"headerlink\" title=\"字符串的特点\"></a>字符串的特点</h3><p>字符串是不可变的，一旦创建，它们的值就不能改变。要改变的话，则会先销毁原来的字符串，再用一个包含新值的字符串填充该变量。</p>\n<pre><code>var lang = &quot;Java&quot;;\nlang = lang + &quot;Script&quot;;\n</code></pre><ol>\n<li>首先创建一个10字符的新字符串</li>\n<li>接着填充”Java”和”Script”</li>\n<li>将新字符串赋值给lang</li>\n<li>删除”Java”和”Script”</li>\n</ol>\n<h3 id=\"转换为字符串\"><a href=\"#转换为字符串\" class=\"headerlink\" title=\"转换为字符串\"></a>转换为字符串</h3><p>转换为字符串有两种方法，分别是toString()和String()。</p>\n<p>还有一种是用加号操作符，这里先不作讨论。</p>\n<h4 id=\"toString-NaN\"><a href=\"#toString-NaN\" class=\"headerlink\" title=\"toString()\"></a>toString()</h4><p>几乎每个值都有toString()方法，返回响应值的字符串表现。</p>\n<ul>\n<li>Number，即数字本身，还可以传递一个参数以指定基数</li>\n<li>Boolean，即”true”或”false”</li>\n<li>String，即字符串本身</li>\n</ul>\n<p>示例：</p>\n<pre><code>var num = 10;\nalert(num.toString()); //10，默认十进制\nalert(num.toString(2)); //1010，二进制\nalert(num.toString(16)); //a,十六进制\n</code></pre><p>Null和Undefined没有toString方法。</p>\n<h4 id=\"String-1\"><a href=\"#String-1\" class=\"headerlink\" title=\"String()\"></a>String()</h4><p>就像Number()和parseInt()的关系一样，String()转型函数能够接收任意类型的值作为参数，但是区别在于Number()和parseInt()之间相对平等，而String()更像是toString()的超集。</p>\n<ul>\n<li>如果传入的值有toString()方法，则调用该方法</li>\n<li>Null类型，返回”null”</li>\n<li>Undefined类型，返回”undefined”</li>\n</ul>\n<p>不过String()在转换数值时就不能指定基数了。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>JavaScript基本数据类型有5种，分别是Null，Undefined，Boolean，Number和String。其中，Undefined派生自Null，故null==undefined返回true。</p>\n<p>Boolean只有true和false两个值，注意Boolean()转型函数的转换规则，以及与if()等流程控制语句的关系。</p>\n<p>Number类型不区分整数和浮点数，要注意其数值范围以及精度的问题，要当心0.1+0.2不等于0.3的判断问题。还有对NaN的理解，注意NaN与任何值都不相等的特性。此外，Number()转型函数，parseInt()和parseFloat()各有机制上的共通点和不同处，要做好区别。</p>\n<p>String类型，包含字符字面量，转义字符，字符串的特点以及字符串的转换，重点理解如何使用toString()和String()来进行字符串转换。</p>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>Undefined</li>\n<li>Null</li>\n<li>Boolean</li>\n<li>String</li>\n<li>Number</li>\n</ul>\n<h2 id=\"Undefined\"><a href=\"#Undefined\" class=\"headerlink\" title=\"Undefined\"></a>Undefined</h2><p>Undefined类型只有一个undefined值。</p>\n<p>用var声明但未赋值的变量，其值为undefined。</p>\n<pre><code>var a;\nalert(a); //undefined\n</code></pre><p>使用一个未经声明的变量，typeof检测为undefined，但使用时会报错。</p>\n<pre><code>alert(a); //Error\n</code></pre><p>访问一个对象中不存在的属性时，其值为undefined，不会报错。</p>\n<pre><code>var o = {a:1};\nalert(o.b); //undefined\n</code></pre><p>故undefined不能与typeof结合使用来判断一个变量是否被声明。</p>\n<pre><code>var a;\nalert(typeof a); //undefined\nalert(typeof b); //undefined ，变量b并没有被声明\n</code></pre><h2 id=\"Null\"><a href=\"#Null\" class=\"headerlink\" title=\"Null\"></a>Null</h2><p>Null表示一个空对象指针，typeof null会返回object。</p>\n<pre><code>var o = null;\nalert(typeof o); //object\n</code></pre><p>null可以作为空对象的占位符，故如果定义的变量将来用于存放对象，那么最好将该变量初始化为null，这样通过typeof可以判断相应的变量是否保存了一个对象的引用。</p>\n<pre><code>var o = null;\n//...\nif(o == null){\n    //do something\n}\n</code></pre><p>undefined是派生自null的，故下面相等性测试返回的是true</p>\n<pre><code>alert(undefined == null); //true\n</code></pre><p>注意：undefined与null很大的一个区别在于，无论什么情况下，undefined一般都不会被用作显式地初始化变量，而null则推荐用来作为空对象指针。</p>\n<h2 id=\"Boolean\"><a href=\"#Boolean\" class=\"headerlink\" title=\"Boolean\"></a>Boolean</h2><p>ECMAScript中，所有类型的值都有与Boolean类型对应的值，我们可以通过转型函数Boolean()来进行转换。</p>\n<ul>\n<li>String类型，非空字符串均返回true，空字符串返回false</li>\n<li>Number类型，非零数字值均返回true，0和NaN返回false</li>\n<li>Object类型，任何非空对象均返回true，null返回false</li>\n<li>Undefined类型，恒为false</li>\n</ul>\n<p>这个转换在流控制语句中如if语句中，会将if()中的变量自动转换成对应的Boolean值，以下代码是相等的：</p>\n<pre><code>var foo = &quot;bar&quot;;\n\nif(foo){\n    //do something\n}\n\n//上下两段代码是相同的\n\nif(Boolean(foo)){\n    //do something\n}\n</code></pre><h2 id=\"Number\"><a href=\"#Number\" class=\"headerlink\" title=\"Number\"></a>Number</h2><p>Number类型使用IEEE754格式来表示整数和浮点数，浮点数值的最高精度是17位小数，故在计算时会产生舍入误差的问题。所以永远不要测试某个特定的浮点数值。</p>\n<pre><code>var a = 0.1;\nvar b = 0.2;\nalert(a+b == 0.3) //false，0.1+0.2会变成0.30000000000000004\n</code></pre><h3 id=\"数值范围\"><a href=\"#数值范围\" class=\"headerlink\" title=\"数值范围\"></a>数值范围</h3><ul>\n<li>正无穷：+Infinity</li>\n<li>能够表示的最大正数：Number.MAX_VALUE</li>\n<li>能够表示的最小正数：Number.MIN_VALUE</li>\n<li>0</li>\n<li>能够表示的最大负数：-Number.MIN_VALUE</li>\n<li>能够表示的最小负数：-Number.MAX_VALUE</li>\n<li>负无穷：-Infinity</li>\n</ul>\n<h3 id=\"NaN\"><a href=\"#NaN\" class=\"headerlink\" title=\"NaN\"></a>NaN</h3><p>NaN，Not a Number，用于表示一个本来要返回数值的操作数未返回数值的情况，此时不抛出错误，也不会影响其他代码的执行。</p>\n<p>除了类型转换时会出现NaN之外，0/0也会返回NaN。</p>\n<p>特点：</p>\n<ul>\n<li>NaN与任何数值操作均为NaN</li>\n<li>NaN与任何值都不相等，包括NaN自身</li>\n</ul>\n<p>可以用isNaN()函数来判断一个值是否“不是数值”，isNaN()在接收到一个参数后，会尝试将这个值转换为数值。</p>\n<pre><code>isNaN(NaN); //true\nisNaN(10); //false\nisNaN(&quot;10&quot;); //false，字符串&quot;10&quot;可以转换成数字10\nisNaN(&quot;blue&quot;); //true，字符串&quot;blue&quot;不能被转换成数字\nisNaN(true); //false，布尔值true可以被转换成数字1\nisNaN(false); //false，布尔值false可以被转换成数字0\n</code></pre><h3 id=\"数值转换\"><a href=\"#数值转换\" class=\"headerlink\" title=\"数值转换\"></a>数值转换</h3><ul>\n<li>Number()，转型函数</li>\n<li>parseInt()，全局函数</li>\n<li>parseFloat()，全局函数</li>\n</ul>\n<h4 id=\"Number-1\"><a href=\"#Number-1\" class=\"headerlink\" title=\"Number()\"></a>Number()</h4><ul>\n<li>Boolean，true 1，false 0</li>\n<li>Null，null 0</li>\n<li>Undefined，undefined NaN</li>\n<li>String，字符串只包含数字时（包括+/-，整数/浮点数） 对应数字，空字符串”” 0</li>\n<li>Object，先valueOf()若NaN则toString()，转换规则跟上述一致</li>\n</ul>\n<h4 id=\"parseInt\"><a href=\"#parseInt\" class=\"headerlink\" title=\"parseInt()\"></a>parseInt()</h4><p>parseInt接收两个参数，第一个是待转换的值，第二个是基数（二进制、八进制、十进制、十六进制），其他进制不常用，以下仅讨论十进制。</p>\n<p>与Number()的几个区别是，</p>\n<ol>\n<li>Number()接收任意类型的参数，而parseInt()只接收String，非String一律为NaN。</li>\n<li>parseInt()会对传入的字符串从左到右进行遍历，从第一个数字或正负号开始，到第一个非数字结束，字符串中不存在数字就一定会是NaN，忽略其他非数字的字符；Number()中如果字符串存在非数字字符就会是NaN。</li>\n<li>空字符串Number()转换成0，parseInt()转换成NaN。</li>\n<li>parseInt()只会转换成整数</li>\n</ol>\n<p>示例：</p>\n<pre><code>var n0 = true;\nalert(Number(n0)); //1\nalert(parseInt(n0,10)); //NaN\n\nvar n1 = &quot;1234blue&quot;;\nalert(Number(n1)); //NaN\nalert(parseInt(n1,10)); //1234\n\nvar n2 = &quot;&quot;;\nalert(Number(n2)); //0\nalert(parseInt(n2,10)); //NaN\n\nvar n3 = &quot;22.5&quot;;\nalert(Number(n3)); //22.5\nalert(parseInt(n3,10)); //22\n</code></pre><h4 id=\"parseFloat\"><a href=\"#parseFloat\" class=\"headerlink\" title=\"parseFloat()\"></a>parseFloat()</h4><p>parseFloat()与parseInt()的解析机制基本相同，以下为两个比较主要的区别：</p>\n<ol>\n<li>parseFloat()没有第二个参数，只解析十进制</li>\n<li>parseFloat()识别小数点，遇到第二个小数点停止解析</li>\n</ol>\n<h2 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h2><p>String类型用于表示由零或多个16位Unicode字符组成的字符序列，即字符串。</p>\n<p>用双引号表示的字符串与用单引号表示的字符串完全相同。</p>\n<h3 id=\"字符字面量\"><a href=\"#字符字面量\" class=\"headerlink\" title=\"字符字面量\"></a>字符字面量</h3><p>即转义序列，用于表示非打印字符或其他用途的字符。常见的有：</p>\n<ul>\n<li>\\n 换行</li>\n<li>\\t 制表</li>\n<li>\\r 回车</li>\n<li>\\b 退格</li>\n<li>\\xnn 以十六进制代码nn表示一个字符（n为0~F）</li>\n<li>\\unnnn 以十六进制代码nnnn表示的一个Unicode字符（其中n为0~f)</li>\n</ul>\n<p>注意：\\unnnn类型的字符虽然在代码中占6个字符，但是在length属性中只占1个字符。</p>\n<p>但是如果字符串中包含双字节字符，那么length属性可能不会精确地返回字符串中的字符数目。</p>\n<h3 id=\"字符串的特点\"><a href=\"#字符串的特点\" class=\"headerlink\" title=\"字符串的特点\"></a>字符串的特点</h3><p>字符串是不可变的，一旦创建，它们的值就不能改变。要改变的话，则会先销毁原来的字符串，再用一个包含新值的字符串填充该变量。</p>\n<pre><code>var lang = &quot;Java&quot;;\nlang = lang + &quot;Script&quot;;\n</code></pre><ol>\n<li>首先创建一个10字符的新字符串</li>\n<li>接着填充”Java”和”Script”</li>\n<li>将新字符串赋值给lang</li>\n<li>删除”Java”和”Script”</li>\n</ol>\n<h3 id=\"转换为字符串\"><a href=\"#转换为字符串\" class=\"headerlink\" title=\"转换为字符串\"></a>转换为字符串</h3><p>转换为字符串有两种方法，分别是toString()和String()。</p>\n<p>还有一种是用加号操作符，这里先不作讨论。</p>\n<h4 id=\"toString-NaN\"><a href=\"#toString-NaN\" class=\"headerlink\" title=\"toString()\"></a>toString()</h4><p>几乎每个值都有toString()方法，返回响应值的字符串表现。</p>\n<ul>\n<li>Number，即数字本身，还可以传递一个参数以指定基数</li>\n<li>Boolean，即”true”或”false”</li>\n<li>String，即字符串本身</li>\n</ul>\n<p>示例：</p>\n<pre><code>var num = 10;\nalert(num.toString()); //10，默认十进制\nalert(num.toString(2)); //1010，二进制\nalert(num.toString(16)); //a,十六进制\n</code></pre><p>Null和Undefined没有toString方法。</p>\n<h4 id=\"String-1\"><a href=\"#String-1\" class=\"headerlink\" title=\"String()\"></a>String()</h4><p>就像Number()和parseInt()的关系一样，String()转型函数能够接收任意类型的值作为参数，但是区别在于Number()和parseInt()之间相对平等，而String()更像是toString()的超集。</p>\n<ul>\n<li>如果传入的值有toString()方法，则调用该方法</li>\n<li>Null类型，返回”null”</li>\n<li>Undefined类型，返回”undefined”</li>\n</ul>\n<p>不过String()在转换数值时就不能指定基数了。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>JavaScript基本数据类型有5种，分别是Null，Undefined，Boolean，Number和String。其中，Undefined派生自Null，故null==undefined返回true。</p>\n<p>Boolean只有true和false两个值，注意Boolean()转型函数的转换规则，以及与if()等流程控制语句的关系。</p>\n<p>Number类型不区分整数和浮点数，要注意其数值范围以及精度的问题，要当心0.1+0.2不等于0.3的判断问题。还有对NaN的理解，注意NaN与任何值都不相等的特性。此外，Number()转型函数，parseInt()和parseFloat()各有机制上的共通点和不同处，要做好区别。</p>\n<p>String类型，包含字符字面量，转义字符，字符串的特点以及字符串的转换，重点理解如何使用toString()和String()来进行字符串转换。</p>\n"},{"layout":"post","title":"React：基本环境搭建简明步骤","date":"2017-04-14T14:34:00.000Z","_content":"超简的步骤整理。待完善。\n\n- Babel\n- ESLint\n- webpack\n\n## Babel\n\n`babel`是一个多用途的JavaScript编译器，用它的目的有二：一是支持ES6语法，二是支持`React`的一些特性（JSX）语法等。\n\n### 安装\n\n在这里我们是跟`webpack`一起用的，所以需要的是`babel-core`核心模块和`babel-lodaer`，如果需要单独使用`babel`则安装`babel-cli`。\n\n    $ npm i babel-core babel-loader --save-dev\n\n接下来安装babel presets\n\n    $ npm i babel-preset-es2015 babel-preset-react --save-dev\n    \n### 配置\n\n在根目录下新建一个`.babelrc`文件，并加入以下配置\n\n    {\n        \"presets\": [\"es2015\", \"react\"]\n    }\n\n## ESLint\n\nESLint是一个代码检查工具，用于检查和统一代码规范。\n\n### 安装\n\n    $ npm i eslint eslint-loader --save-dev\n\n### 配置\n\n    $ eslint --init\n\n接下来根据你的需求进行选择即可，非常方便。最终可选择生成一个`.eslint.json`文件。我的配置如下：\n\n    {\n        \"env\": {\n            \"browser\": true,\n            \"commonjs\": true,\n            \"es6\": true,\n            \"node\": true\n        },\n        \"extends\": \"eslint:recommended\",\n        \"parserOptions\": {\n            \"ecmaFeatures\": {\n                \"experimentalObjectRestSpread\": true,\n                \"jsx\": true\n            },\n            \"sourceType\": \"module\"\n        },\n        \"plugins\": [\n            \"react\"\n        ],\n        \"rules\": {\n            \"linebreak-style\": [\n                \"error\",\n                \"unix\"\n            ],\n            \"quotes\": [\n                \"error\",\n                \"single\"\n            ],\n            \"semi\": [\n                \"error\",\n                \"always\"\n            ]\n        }\n    }\n\n更多的配置可参照[ESLint](http://eslint.org)\n\n## webpack\n\n`webpack`是当前非常流行的模块打包工具，上述的`Babel`和`ESLint`都可以作为`loader`在`webpack`中被使用。\n\n注意：本文使用的是`webpack 2`，`webpack 1`和`webpack 2`在配置上有诸多不同之处，请务必留心。\n\n[链接：webpack 1和2的区别](https://webpack.js.org/guides/migrating/)\n\n### 安装\n\n    $ npm i webpack webpack-dev-server --save-dev\n    \n### 插件\n\n用于自动生成HTML页面，并引入正确的JavaScript文件依赖。\n\n    $ npm i html-webpack-plugin --save-dev\n\n### loader\n\n处理CSS文件需要用到的两个loader。\n\n    $ npm i css-loader style-loader\n\n### 配置\n\n在根目录下新建一个`app`目录，同时再创建一个`webpack.config.js`文件。\n\n    var path = require('path');\n    var HtmlWebpackPlugin = require('html-webpack-plugin');\n    \n    var ROOT_PATH = path.resolve(__dirname);\n    var APP_PATH = path.resolve(ROOT_PATH, 'app');\n    var BUILD_PATH = path.resolve(ROOT_PATH, 'build');\n    \n    module.exports = {\n        entry: {\n            app: path.resolve(APP_PATH, 'app.jsx')\n        },\n        output: {\n            path: BUILD_PATH,\n            filename: 'bundle.js'\n        },\n        devtool: 'eval-source-map',\n        devServer: {\n            historyApiFallback: true,\n            hot: true,\n            inline: true,\n        },\n        module: {\n            rules: [{\n                test: /\\.jsx?$/,\n                enforce: 'pre',\n                loaders: ['eslint-loader'],\n                include: APP_PATH\n            }, {\n                test: /\\.css$/,\n                loaders: ['style-loader', 'css-loader']\n            }, {\n                test: /\\.jsx?$/,\n                loader: ['babel-loader'],\n                include: APP_PATH\n            }],\n        },\n        plugins: [\n            new HtmlWebpackPlugin({\n                title: 'react-dev'\n            })\n        ],\n        resolve: {\n            extensions: ['.js', '.jsx']\n        }\n    };\n\n## 最后\n\n添加两条命令到`package.json`里。\n\n    \"scripts\": {\n        \"build\":\"webpack\",\n        \"dev\":\"webpack-dev-server --hot\"\n    }\n\n通过在Terminal中输入 `npm run build` 或 `npm run dev` 执行。","source":"_posts/2017-04-14-React：基本环境搭建简明步骤.markdown","raw":"---\nlayout: post\ntitle:  \"React：基本环境搭建简明步骤\"\ndate:   2017-04-14 22:34:00 +0800\ntags: react\n---\n超简的步骤整理。待完善。\n\n- Babel\n- ESLint\n- webpack\n\n## Babel\n\n`babel`是一个多用途的JavaScript编译器，用它的目的有二：一是支持ES6语法，二是支持`React`的一些特性（JSX）语法等。\n\n### 安装\n\n在这里我们是跟`webpack`一起用的，所以需要的是`babel-core`核心模块和`babel-lodaer`，如果需要单独使用`babel`则安装`babel-cli`。\n\n    $ npm i babel-core babel-loader --save-dev\n\n接下来安装babel presets\n\n    $ npm i babel-preset-es2015 babel-preset-react --save-dev\n    \n### 配置\n\n在根目录下新建一个`.babelrc`文件，并加入以下配置\n\n    {\n        \"presets\": [\"es2015\", \"react\"]\n    }\n\n## ESLint\n\nESLint是一个代码检查工具，用于检查和统一代码规范。\n\n### 安装\n\n    $ npm i eslint eslint-loader --save-dev\n\n### 配置\n\n    $ eslint --init\n\n接下来根据你的需求进行选择即可，非常方便。最终可选择生成一个`.eslint.json`文件。我的配置如下：\n\n    {\n        \"env\": {\n            \"browser\": true,\n            \"commonjs\": true,\n            \"es6\": true,\n            \"node\": true\n        },\n        \"extends\": \"eslint:recommended\",\n        \"parserOptions\": {\n            \"ecmaFeatures\": {\n                \"experimentalObjectRestSpread\": true,\n                \"jsx\": true\n            },\n            \"sourceType\": \"module\"\n        },\n        \"plugins\": [\n            \"react\"\n        ],\n        \"rules\": {\n            \"linebreak-style\": [\n                \"error\",\n                \"unix\"\n            ],\n            \"quotes\": [\n                \"error\",\n                \"single\"\n            ],\n            \"semi\": [\n                \"error\",\n                \"always\"\n            ]\n        }\n    }\n\n更多的配置可参照[ESLint](http://eslint.org)\n\n## webpack\n\n`webpack`是当前非常流行的模块打包工具，上述的`Babel`和`ESLint`都可以作为`loader`在`webpack`中被使用。\n\n注意：本文使用的是`webpack 2`，`webpack 1`和`webpack 2`在配置上有诸多不同之处，请务必留心。\n\n[链接：webpack 1和2的区别](https://webpack.js.org/guides/migrating/)\n\n### 安装\n\n    $ npm i webpack webpack-dev-server --save-dev\n    \n### 插件\n\n用于自动生成HTML页面，并引入正确的JavaScript文件依赖。\n\n    $ npm i html-webpack-plugin --save-dev\n\n### loader\n\n处理CSS文件需要用到的两个loader。\n\n    $ npm i css-loader style-loader\n\n### 配置\n\n在根目录下新建一个`app`目录，同时再创建一个`webpack.config.js`文件。\n\n    var path = require('path');\n    var HtmlWebpackPlugin = require('html-webpack-plugin');\n    \n    var ROOT_PATH = path.resolve(__dirname);\n    var APP_PATH = path.resolve(ROOT_PATH, 'app');\n    var BUILD_PATH = path.resolve(ROOT_PATH, 'build');\n    \n    module.exports = {\n        entry: {\n            app: path.resolve(APP_PATH, 'app.jsx')\n        },\n        output: {\n            path: BUILD_PATH,\n            filename: 'bundle.js'\n        },\n        devtool: 'eval-source-map',\n        devServer: {\n            historyApiFallback: true,\n            hot: true,\n            inline: true,\n        },\n        module: {\n            rules: [{\n                test: /\\.jsx?$/,\n                enforce: 'pre',\n                loaders: ['eslint-loader'],\n                include: APP_PATH\n            }, {\n                test: /\\.css$/,\n                loaders: ['style-loader', 'css-loader']\n            }, {\n                test: /\\.jsx?$/,\n                loader: ['babel-loader'],\n                include: APP_PATH\n            }],\n        },\n        plugins: [\n            new HtmlWebpackPlugin({\n                title: 'react-dev'\n            })\n        ],\n        resolve: {\n            extensions: ['.js', '.jsx']\n        }\n    };\n\n## 最后\n\n添加两条命令到`package.json`里。\n\n    \"scripts\": {\n        \"build\":\"webpack\",\n        \"dev\":\"webpack-dev-server --hot\"\n    }\n\n通过在Terminal中输入 `npm run build` 或 `npm run dev` 执行。","slug":"2017-04-14-React：基本环境搭建简明步骤","published":1,"updated":"2017-08-06T12:14:59.000Z","_id":"cj60bzxku000k1dorpwvnuqje","comments":1,"photos":[],"link":"","content":"<p>超简的步骤整理。待完善。</p>\n<ul>\n<li>Babel</li>\n<li>ESLint</li>\n<li>webpack</li>\n</ul>\n<h2 id=\"Babel\"><a href=\"#Babel\" class=\"headerlink\" title=\"Babel\"></a>Babel</h2><p><code>babel</code>是一个多用途的JavaScript编译器，用它的目的有二：一是支持ES6语法，二是支持<code>React</code>的一些特性（JSX）语法等。</p>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>在这里我们是跟<code>webpack</code>一起用的，所以需要的是<code>babel-core</code>核心模块和<code>babel-lodaer</code>，如果需要单独使用<code>babel</code>则安装<code>babel-cli</code>。</p>\n<pre><code>$ npm i babel-core babel-loader --save-dev\n</code></pre><p>接下来安装babel presets</p>\n<pre><code>$ npm i babel-preset-es2015 babel-preset-react --save-dev\n</code></pre><h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><p>在根目录下新建一个<code>.babelrc</code>文件，并加入以下配置</p>\n<pre><code>{\n    &quot;presets&quot;: [&quot;es2015&quot;, &quot;react&quot;]\n}\n</code></pre><h2 id=\"ESLint\"><a href=\"#ESLint\" class=\"headerlink\" title=\"ESLint\"></a>ESLint</h2><p>ESLint是一个代码检查工具，用于检查和统一代码规范。</p>\n<h3 id=\"安装-1\"><a href=\"#安装-1\" class=\"headerlink\" title=\"安装\"></a>安装</h3><pre><code>$ npm i eslint eslint-loader --save-dev\n</code></pre><h3 id=\"配置-1\"><a href=\"#配置-1\" class=\"headerlink\" title=\"配置\"></a>配置</h3><pre><code>$ eslint --init\n</code></pre><p>接下来根据你的需求进行选择即可，非常方便。最终可选择生成一个<code>.eslint.json</code>文件。我的配置如下：</p>\n<pre><code>{\n    &quot;env&quot;: {\n        &quot;browser&quot;: true,\n        &quot;commonjs&quot;: true,\n        &quot;es6&quot;: true,\n        &quot;node&quot;: true\n    },\n    &quot;extends&quot;: &quot;eslint:recommended&quot;,\n    &quot;parserOptions&quot;: {\n        &quot;ecmaFeatures&quot;: {\n            &quot;experimentalObjectRestSpread&quot;: true,\n            &quot;jsx&quot;: true\n        },\n        &quot;sourceType&quot;: &quot;module&quot;\n    },\n    &quot;plugins&quot;: [\n        &quot;react&quot;\n    ],\n    &quot;rules&quot;: {\n        &quot;linebreak-style&quot;: [\n            &quot;error&quot;,\n            &quot;unix&quot;\n        ],\n        &quot;quotes&quot;: [\n            &quot;error&quot;,\n            &quot;single&quot;\n        ],\n        &quot;semi&quot;: [\n            &quot;error&quot;,\n            &quot;always&quot;\n        ]\n    }\n}\n</code></pre><p>更多的配置可参照<a href=\"http://eslint.org\" target=\"_blank\" rel=\"external\">ESLint</a></p>\n<h2 id=\"webpack\"><a href=\"#webpack\" class=\"headerlink\" title=\"webpack\"></a>webpack</h2><p><code>webpack</code>是当前非常流行的模块打包工具，上述的<code>Babel</code>和<code>ESLint</code>都可以作为<code>loader</code>在<code>webpack</code>中被使用。</p>\n<p>注意：本文使用的是<code>webpack 2</code>，<code>webpack 1</code>和<code>webpack 2</code>在配置上有诸多不同之处，请务必留心。</p>\n<p><a href=\"https://webpack.js.org/guides/migrating/\" target=\"_blank\" rel=\"external\">链接：webpack 1和2的区别</a></p>\n<h3 id=\"安装-2\"><a href=\"#安装-2\" class=\"headerlink\" title=\"安装\"></a>安装</h3><pre><code>$ npm i webpack webpack-dev-server --save-dev\n</code></pre><h3 id=\"插件\"><a href=\"#插件\" class=\"headerlink\" title=\"插件\"></a>插件</h3><p>用于自动生成HTML页面，并引入正确的JavaScript文件依赖。</p>\n<pre><code>$ npm i html-webpack-plugin --save-dev\n</code></pre><h3 id=\"loader\"><a href=\"#loader\" class=\"headerlink\" title=\"loader\"></a>loader</h3><p>处理CSS文件需要用到的两个loader。</p>\n<pre><code>$ npm i css-loader style-loader\n</code></pre><h3 id=\"配置-2\"><a href=\"#配置-2\" class=\"headerlink\" title=\"配置\"></a>配置</h3><p>在根目录下新建一个<code>app</code>目录，同时再创建一个<code>webpack.config.js</code>文件。</p>\n<pre><code>var path = require(&apos;path&apos;);\nvar HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);\n\nvar ROOT_PATH = path.resolve(__dirname);\nvar APP_PATH = path.resolve(ROOT_PATH, &apos;app&apos;);\nvar BUILD_PATH = path.resolve(ROOT_PATH, &apos;build&apos;);\n\nmodule.exports = {\n    entry: {\n        app: path.resolve(APP_PATH, &apos;app.jsx&apos;)\n    },\n    output: {\n        path: BUILD_PATH,\n        filename: &apos;bundle.js&apos;\n    },\n    devtool: &apos;eval-source-map&apos;,\n    devServer: {\n        historyApiFallback: true,\n        hot: true,\n        inline: true,\n    },\n    module: {\n        rules: [{\n            test: /\\.jsx?$/,\n            enforce: &apos;pre&apos;,\n            loaders: [&apos;eslint-loader&apos;],\n            include: APP_PATH\n        }, {\n            test: /\\.css$/,\n            loaders: [&apos;style-loader&apos;, &apos;css-loader&apos;]\n        }, {\n            test: /\\.jsx?$/,\n            loader: [&apos;babel-loader&apos;],\n            include: APP_PATH\n        }],\n    },\n    plugins: [\n        new HtmlWebpackPlugin({\n            title: &apos;react-dev&apos;\n        })\n    ],\n    resolve: {\n        extensions: [&apos;.js&apos;, &apos;.jsx&apos;]\n    }\n};\n</code></pre><h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>添加两条命令到<code>package.json</code>里。</p>\n<pre><code>&quot;scripts&quot;: {\n    &quot;build&quot;:&quot;webpack&quot;,\n    &quot;dev&quot;:&quot;webpack-dev-server --hot&quot;\n}\n</code></pre><p>通过在Terminal中输入 <code>npm run build</code> 或 <code>npm run dev</code> 执行。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>超简的步骤整理。待完善。</p>\n<ul>\n<li>Babel</li>\n<li>ESLint</li>\n<li>webpack</li>\n</ul>\n<h2 id=\"Babel\"><a href=\"#Babel\" class=\"headerlink\" title=\"Babel\"></a>Babel</h2><p><code>babel</code>是一个多用途的JavaScript编译器，用它的目的有二：一是支持ES6语法，二是支持<code>React</code>的一些特性（JSX）语法等。</p>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>在这里我们是跟<code>webpack</code>一起用的，所以需要的是<code>babel-core</code>核心模块和<code>babel-lodaer</code>，如果需要单独使用<code>babel</code>则安装<code>babel-cli</code>。</p>\n<pre><code>$ npm i babel-core babel-loader --save-dev\n</code></pre><p>接下来安装babel presets</p>\n<pre><code>$ npm i babel-preset-es2015 babel-preset-react --save-dev\n</code></pre><h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><p>在根目录下新建一个<code>.babelrc</code>文件，并加入以下配置</p>\n<pre><code>{\n    &quot;presets&quot;: [&quot;es2015&quot;, &quot;react&quot;]\n}\n</code></pre><h2 id=\"ESLint\"><a href=\"#ESLint\" class=\"headerlink\" title=\"ESLint\"></a>ESLint</h2><p>ESLint是一个代码检查工具，用于检查和统一代码规范。</p>\n<h3 id=\"安装-1\"><a href=\"#安装-1\" class=\"headerlink\" title=\"安装\"></a>安装</h3><pre><code>$ npm i eslint eslint-loader --save-dev\n</code></pre><h3 id=\"配置-1\"><a href=\"#配置-1\" class=\"headerlink\" title=\"配置\"></a>配置</h3><pre><code>$ eslint --init\n</code></pre><p>接下来根据你的需求进行选择即可，非常方便。最终可选择生成一个<code>.eslint.json</code>文件。我的配置如下：</p>\n<pre><code>{\n    &quot;env&quot;: {\n        &quot;browser&quot;: true,\n        &quot;commonjs&quot;: true,\n        &quot;es6&quot;: true,\n        &quot;node&quot;: true\n    },\n    &quot;extends&quot;: &quot;eslint:recommended&quot;,\n    &quot;parserOptions&quot;: {\n        &quot;ecmaFeatures&quot;: {\n            &quot;experimentalObjectRestSpread&quot;: true,\n            &quot;jsx&quot;: true\n        },\n        &quot;sourceType&quot;: &quot;module&quot;\n    },\n    &quot;plugins&quot;: [\n        &quot;react&quot;\n    ],\n    &quot;rules&quot;: {\n        &quot;linebreak-style&quot;: [\n            &quot;error&quot;,\n            &quot;unix&quot;\n        ],\n        &quot;quotes&quot;: [\n            &quot;error&quot;,\n            &quot;single&quot;\n        ],\n        &quot;semi&quot;: [\n            &quot;error&quot;,\n            &quot;always&quot;\n        ]\n    }\n}\n</code></pre><p>更多的配置可参照<a href=\"http://eslint.org\" target=\"_blank\" rel=\"external\">ESLint</a></p>\n<h2 id=\"webpack\"><a href=\"#webpack\" class=\"headerlink\" title=\"webpack\"></a>webpack</h2><p><code>webpack</code>是当前非常流行的模块打包工具，上述的<code>Babel</code>和<code>ESLint</code>都可以作为<code>loader</code>在<code>webpack</code>中被使用。</p>\n<p>注意：本文使用的是<code>webpack 2</code>，<code>webpack 1</code>和<code>webpack 2</code>在配置上有诸多不同之处，请务必留心。</p>\n<p><a href=\"https://webpack.js.org/guides/migrating/\" target=\"_blank\" rel=\"external\">链接：webpack 1和2的区别</a></p>\n<h3 id=\"安装-2\"><a href=\"#安装-2\" class=\"headerlink\" title=\"安装\"></a>安装</h3><pre><code>$ npm i webpack webpack-dev-server --save-dev\n</code></pre><h3 id=\"插件\"><a href=\"#插件\" class=\"headerlink\" title=\"插件\"></a>插件</h3><p>用于自动生成HTML页面，并引入正确的JavaScript文件依赖。</p>\n<pre><code>$ npm i html-webpack-plugin --save-dev\n</code></pre><h3 id=\"loader\"><a href=\"#loader\" class=\"headerlink\" title=\"loader\"></a>loader</h3><p>处理CSS文件需要用到的两个loader。</p>\n<pre><code>$ npm i css-loader style-loader\n</code></pre><h3 id=\"配置-2\"><a href=\"#配置-2\" class=\"headerlink\" title=\"配置\"></a>配置</h3><p>在根目录下新建一个<code>app</code>目录，同时再创建一个<code>webpack.config.js</code>文件。</p>\n<pre><code>var path = require(&apos;path&apos;);\nvar HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);\n\nvar ROOT_PATH = path.resolve(__dirname);\nvar APP_PATH = path.resolve(ROOT_PATH, &apos;app&apos;);\nvar BUILD_PATH = path.resolve(ROOT_PATH, &apos;build&apos;);\n\nmodule.exports = {\n    entry: {\n        app: path.resolve(APP_PATH, &apos;app.jsx&apos;)\n    },\n    output: {\n        path: BUILD_PATH,\n        filename: &apos;bundle.js&apos;\n    },\n    devtool: &apos;eval-source-map&apos;,\n    devServer: {\n        historyApiFallback: true,\n        hot: true,\n        inline: true,\n    },\n    module: {\n        rules: [{\n            test: /\\.jsx?$/,\n            enforce: &apos;pre&apos;,\n            loaders: [&apos;eslint-loader&apos;],\n            include: APP_PATH\n        }, {\n            test: /\\.css$/,\n            loaders: [&apos;style-loader&apos;, &apos;css-loader&apos;]\n        }, {\n            test: /\\.jsx?$/,\n            loader: [&apos;babel-loader&apos;],\n            include: APP_PATH\n        }],\n    },\n    plugins: [\n        new HtmlWebpackPlugin({\n            title: &apos;react-dev&apos;\n        })\n    ],\n    resolve: {\n        extensions: [&apos;.js&apos;, &apos;.jsx&apos;]\n    }\n};\n</code></pre><h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>添加两条命令到<code>package.json</code>里。</p>\n<pre><code>&quot;scripts&quot;: {\n    &quot;build&quot;:&quot;webpack&quot;,\n    &quot;dev&quot;:&quot;webpack-dev-server --hot&quot;\n}\n</code></pre><p>通过在Terminal中输入 <code>npm run build</code> 或 <code>npm run dev</code> 执行。</p>\n"},{"layout":"post","title":"前端：跨域方法小记","date":"2017-04-24T12:00:00.000Z","_content":"\n## 产生背景\n\n为了防止跨站请求伪造（CSRF，Cross-site request forgery）攻击，浏览器引入了同源策略（SOP，Same-Origin Policy）来提高安全性。\n\n同源策略指的是，只要在同一域名（domain或ip）、同一端口、同一协议下才能互相获取资源。\n\n一个域名A的网页可以获取域名B的静态资源（如CSS文件、图片等），但是不能直接发起AJAX（Asynchronous JavaScript and XML）请求。\n\n## JS跨域\n\n### JSONP\n\n原理：通过动态插入JS脚本的方式来实现跨域。\n\n该方法适合跨域获取JSON类型的数据。缺点是只支持GET方式。\n\n### document.domain\n\n原理：通过修改两个同一一级域名不同二级域名页面（如example.com与a.example）的`document.domain`来实现跨域。`document.domain`只能修改为自身或者高一级的父域名。\n\n该方法适用于同父域名下的跨域问题。\n\n### window.name\n\n原理：window对象的name属性有一个特征，即在一个窗口（window）的生命周期下，窗口载入的所有页面都共享一个`window.name`，故我们可以通过插入一个外部页面的iframe，通过JS修改`window.name`，再将`window.location`改为同源的页面，来访问`window.name`的值进行跨域。\n\n该方法的缺点是需要额外的同源页面，同时不同浏览器对window.name的大小也有一定的限制。\n\n### window.postMessage\n\n原理：`window.postMessage(message, targetOrigin)`，是HTML5新引进的特性，可以用来向同源或者不同源的window对象发送消息。插入一个iframe，获取`iframe.contentWindow`，然后使用`postMessage`发送消息，在iframe预先设置`onmessage`的处理函数，即可获取跨域的数据。\n\n该方法适用于处理多页面通信以及与iframe之间的消息传递。\n\n## 服务端\n\n### 反向代理\n\n原理：通过将外部资源映射成内部的地址，再通过代理服务器去获取真实的资源，然后返回给浏览器，避免在浏览器端进行跨域操作。\n\n> 反向代理，代理的是服务器，客户端只需要知道代理服务器上的资源URL地址即可，而不关心资源的真正URL。例如负载均衡就会用到反向代理。\n>\n> 正向代理，则是代理客户端，客户端需要知道资源的实际URL，通过告诉代理服务器真正的资源URL所在的位置，让代理服务器去获取后返还给客户端。例如翻墙工具就是正向代理。\n\n### CORS\n\n浏览器发送一个带有`Origin`首部字段的HTTP请求，表明请求的来源。服务器的响应头中包含`Access-Control-Allow-Origin`表明允许哪些域名的请求。一旦不匹配则拒绝访问。通常设置为`Access-Control-Allow-Origin: *`可以允许任意域名跨域请求该服务器上的资源。\n\n","source":"_posts/2017-04-24-前端：跨域方法小记.md","raw":"---\nlayout: post\ntitle:  \"前端：跨域方法小记\"\ndate:   2017-04-24 20:00:00 +0800\ntags: fe\n---\n\n## 产生背景\n\n为了防止跨站请求伪造（CSRF，Cross-site request forgery）攻击，浏览器引入了同源策略（SOP，Same-Origin Policy）来提高安全性。\n\n同源策略指的是，只要在同一域名（domain或ip）、同一端口、同一协议下才能互相获取资源。\n\n一个域名A的网页可以获取域名B的静态资源（如CSS文件、图片等），但是不能直接发起AJAX（Asynchronous JavaScript and XML）请求。\n\n## JS跨域\n\n### JSONP\n\n原理：通过动态插入JS脚本的方式来实现跨域。\n\n该方法适合跨域获取JSON类型的数据。缺点是只支持GET方式。\n\n### document.domain\n\n原理：通过修改两个同一一级域名不同二级域名页面（如example.com与a.example）的`document.domain`来实现跨域。`document.domain`只能修改为自身或者高一级的父域名。\n\n该方法适用于同父域名下的跨域问题。\n\n### window.name\n\n原理：window对象的name属性有一个特征，即在一个窗口（window）的生命周期下，窗口载入的所有页面都共享一个`window.name`，故我们可以通过插入一个外部页面的iframe，通过JS修改`window.name`，再将`window.location`改为同源的页面，来访问`window.name`的值进行跨域。\n\n该方法的缺点是需要额外的同源页面，同时不同浏览器对window.name的大小也有一定的限制。\n\n### window.postMessage\n\n原理：`window.postMessage(message, targetOrigin)`，是HTML5新引进的特性，可以用来向同源或者不同源的window对象发送消息。插入一个iframe，获取`iframe.contentWindow`，然后使用`postMessage`发送消息，在iframe预先设置`onmessage`的处理函数，即可获取跨域的数据。\n\n该方法适用于处理多页面通信以及与iframe之间的消息传递。\n\n## 服务端\n\n### 反向代理\n\n原理：通过将外部资源映射成内部的地址，再通过代理服务器去获取真实的资源，然后返回给浏览器，避免在浏览器端进行跨域操作。\n\n> 反向代理，代理的是服务器，客户端只需要知道代理服务器上的资源URL地址即可，而不关心资源的真正URL。例如负载均衡就会用到反向代理。\n>\n> 正向代理，则是代理客户端，客户端需要知道资源的实际URL，通过告诉代理服务器真正的资源URL所在的位置，让代理服务器去获取后返还给客户端。例如翻墙工具就是正向代理。\n\n### CORS\n\n浏览器发送一个带有`Origin`首部字段的HTTP请求，表明请求的来源。服务器的响应头中包含`Access-Control-Allow-Origin`表明允许哪些域名的请求。一旦不匹配则拒绝访问。通常设置为`Access-Control-Allow-Origin: *`可以允许任意域名跨域请求该服务器上的资源。\n\n","slug":"2017-04-24-前端：跨域方法小记","published":1,"updated":"2017-08-06T12:15:02.000Z","_id":"cj60bzxkx000n1dorkxmsgb10","comments":1,"photos":[],"link":"","content":"<h2 id=\"产生背景\"><a href=\"#产生背景\" class=\"headerlink\" title=\"产生背景\"></a>产生背景</h2><p>为了防止跨站请求伪造（CSRF，Cross-site request forgery）攻击，浏览器引入了同源策略（SOP，Same-Origin Policy）来提高安全性。</p>\n<p>同源策略指的是，只要在同一域名（domain或ip）、同一端口、同一协议下才能互相获取资源。</p>\n<p>一个域名A的网页可以获取域名B的静态资源（如CSS文件、图片等），但是不能直接发起AJAX（Asynchronous JavaScript and XML）请求。</p>\n<h2 id=\"JS跨域\"><a href=\"#JS跨域\" class=\"headerlink\" title=\"JS跨域\"></a>JS跨域</h2><h3 id=\"JSONP\"><a href=\"#JSONP\" class=\"headerlink\" title=\"JSONP\"></a>JSONP</h3><p>原理：通过动态插入JS脚本的方式来实现跨域。</p>\n<p>该方法适合跨域获取JSON类型的数据。缺点是只支持GET方式。</p>\n<h3 id=\"document-domain\"><a href=\"#document-domain\" class=\"headerlink\" title=\"document.domain\"></a>document.domain</h3><p>原理：通过修改两个同一一级域名不同二级域名页面（如example.com与a.example）的<code>document.domain</code>来实现跨域。<code>document.domain</code>只能修改为自身或者高一级的父域名。</p>\n<p>该方法适用于同父域名下的跨域问题。</p>\n<h3 id=\"window-name\"><a href=\"#window-name\" class=\"headerlink\" title=\"window.name\"></a>window.name</h3><p>原理：window对象的name属性有一个特征，即在一个窗口（window）的生命周期下，窗口载入的所有页面都共享一个<code>window.name</code>，故我们可以通过插入一个外部页面的iframe，通过JS修改<code>window.name</code>，再将<code>window.location</code>改为同源的页面，来访问<code>window.name</code>的值进行跨域。</p>\n<p>该方法的缺点是需要额外的同源页面，同时不同浏览器对window.name的大小也有一定的限制。</p>\n<h3 id=\"window-postMessage\"><a href=\"#window-postMessage\" class=\"headerlink\" title=\"window.postMessage\"></a>window.postMessage</h3><p>原理：<code>window.postMessage(message, targetOrigin)</code>，是HTML5新引进的特性，可以用来向同源或者不同源的window对象发送消息。插入一个iframe，获取<code>iframe.contentWindow</code>，然后使用<code>postMessage</code>发送消息，在iframe预先设置<code>onmessage</code>的处理函数，即可获取跨域的数据。</p>\n<p>该方法适用于处理多页面通信以及与iframe之间的消息传递。</p>\n<h2 id=\"服务端\"><a href=\"#服务端\" class=\"headerlink\" title=\"服务端\"></a>服务端</h2><h3 id=\"反向代理\"><a href=\"#反向代理\" class=\"headerlink\" title=\"反向代理\"></a>反向代理</h3><p>原理：通过将外部资源映射成内部的地址，再通过代理服务器去获取真实的资源，然后返回给浏览器，避免在浏览器端进行跨域操作。</p>\n<blockquote>\n<p>反向代理，代理的是服务器，客户端只需要知道代理服务器上的资源URL地址即可，而不关心资源的真正URL。例如负载均衡就会用到反向代理。</p>\n<p>正向代理，则是代理客户端，客户端需要知道资源的实际URL，通过告诉代理服务器真正的资源URL所在的位置，让代理服务器去获取后返还给客户端。例如翻墙工具就是正向代理。</p>\n</blockquote>\n<h3 id=\"CORS\"><a href=\"#CORS\" class=\"headerlink\" title=\"CORS\"></a>CORS</h3><p>浏览器发送一个带有<code>Origin</code>首部字段的HTTP请求，表明请求的来源。服务器的响应头中包含<code>Access-Control-Allow-Origin</code>表明允许哪些域名的请求。一旦不匹配则拒绝访问。通常设置为<code>Access-Control-Allow-Origin: *</code>可以允许任意域名跨域请求该服务器上的资源。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"产生背景\"><a href=\"#产生背景\" class=\"headerlink\" title=\"产生背景\"></a>产生背景</h2><p>为了防止跨站请求伪造（CSRF，Cross-site request forgery）攻击，浏览器引入了同源策略（SOP，Same-Origin Policy）来提高安全性。</p>\n<p>同源策略指的是，只要在同一域名（domain或ip）、同一端口、同一协议下才能互相获取资源。</p>\n<p>一个域名A的网页可以获取域名B的静态资源（如CSS文件、图片等），但是不能直接发起AJAX（Asynchronous JavaScript and XML）请求。</p>\n<h2 id=\"JS跨域\"><a href=\"#JS跨域\" class=\"headerlink\" title=\"JS跨域\"></a>JS跨域</h2><h3 id=\"JSONP\"><a href=\"#JSONP\" class=\"headerlink\" title=\"JSONP\"></a>JSONP</h3><p>原理：通过动态插入JS脚本的方式来实现跨域。</p>\n<p>该方法适合跨域获取JSON类型的数据。缺点是只支持GET方式。</p>\n<h3 id=\"document-domain\"><a href=\"#document-domain\" class=\"headerlink\" title=\"document.domain\"></a>document.domain</h3><p>原理：通过修改两个同一一级域名不同二级域名页面（如example.com与a.example）的<code>document.domain</code>来实现跨域。<code>document.domain</code>只能修改为自身或者高一级的父域名。</p>\n<p>该方法适用于同父域名下的跨域问题。</p>\n<h3 id=\"window-name\"><a href=\"#window-name\" class=\"headerlink\" title=\"window.name\"></a>window.name</h3><p>原理：window对象的name属性有一个特征，即在一个窗口（window）的生命周期下，窗口载入的所有页面都共享一个<code>window.name</code>，故我们可以通过插入一个外部页面的iframe，通过JS修改<code>window.name</code>，再将<code>window.location</code>改为同源的页面，来访问<code>window.name</code>的值进行跨域。</p>\n<p>该方法的缺点是需要额外的同源页面，同时不同浏览器对window.name的大小也有一定的限制。</p>\n<h3 id=\"window-postMessage\"><a href=\"#window-postMessage\" class=\"headerlink\" title=\"window.postMessage\"></a>window.postMessage</h3><p>原理：<code>window.postMessage(message, targetOrigin)</code>，是HTML5新引进的特性，可以用来向同源或者不同源的window对象发送消息。插入一个iframe，获取<code>iframe.contentWindow</code>，然后使用<code>postMessage</code>发送消息，在iframe预先设置<code>onmessage</code>的处理函数，即可获取跨域的数据。</p>\n<p>该方法适用于处理多页面通信以及与iframe之间的消息传递。</p>\n<h2 id=\"服务端\"><a href=\"#服务端\" class=\"headerlink\" title=\"服务端\"></a>服务端</h2><h3 id=\"反向代理\"><a href=\"#反向代理\" class=\"headerlink\" title=\"反向代理\"></a>反向代理</h3><p>原理：通过将外部资源映射成内部的地址，再通过代理服务器去获取真实的资源，然后返回给浏览器，避免在浏览器端进行跨域操作。</p>\n<blockquote>\n<p>反向代理，代理的是服务器，客户端只需要知道代理服务器上的资源URL地址即可，而不关心资源的真正URL。例如负载均衡就会用到反向代理。</p>\n<p>正向代理，则是代理客户端，客户端需要知道资源的实际URL，通过告诉代理服务器真正的资源URL所在的位置，让代理服务器去获取后返还给客户端。例如翻墙工具就是正向代理。</p>\n</blockquote>\n<h3 id=\"CORS\"><a href=\"#CORS\" class=\"headerlink\" title=\"CORS\"></a>CORS</h3><p>浏览器发送一个带有<code>Origin</code>首部字段的HTTP请求，表明请求的来源。服务器的响应头中包含<code>Access-Control-Allow-Origin</code>表明允许哪些域名的请求。一旦不匹配则拒绝访问。通常设置为<code>Access-Control-Allow-Origin: *</code>可以允许任意域名跨域请求该服务器上的资源。</p>\n"},{"layout":"post","title":"jQuery：事件监听用法","date":"2017-04-26T12:00:00.000Z","_content":"## 常见事件类型\n\n* Form events: 如 submit\n* Focus events: 如 blur, focus, change\n* Input devices events: 如 keyup, keypress, mouseover, mousemove, mouseleave\n* View events: 如 scroll, resize\n\n## 事件监听三要素\n\n* the target element to listen to，监听对象\n* the event we want to react to，监听事件\n* the actions to take in response，回调函数\n\n## 基础示例\n\n```\n$('div.foo button').on('click',function(){\n    $(this).remove();\n})\n```\n\n## 更多用法\n\n```\n// 传递事件对象\n$('div.foo button).on('click',function(event){\n    $(event.target).remove(); // event.target 事件目标的页面元素\n})\n```\n\n```\n// 阻止默认行为\n$('div.foo a).on('click',function(event){\n    event.preventDefault();\n    console.log('the link you clicked will not work');\n})\n```\n\n### event\n\n* event.keyCode，用来了解按下的是哪个键\n* event.pageX, event.pageY，用来了解点击发生的坐标位置\n* event.type，用来了解发生的事件\n\n## 简易写法\n\n```\n$('div.foo').click(function(){...});\n$('div.foo').hover(function(){...});\n\n//等等\n```\n\n需要注意的是，`.hover()`监听了两个事件`mouseenter`和`mouseleave`，并且并不是所有事件都有简易的写法。\n\n更多简易写法参考：[jQuery: Events](http://api.jquery.com/category/events/)\n\n## 事件代理\n\n```\n<div class=\"foo\">\n    <ul>\n        <li> 1 </li>\n        <li> 2 </li>\n        ...\n        <li> 1000 </li>\n    </ul>\n</div>\n```\n\n假设有如上这样一个DOM片段，如果用以下方式进行事件监听，则会产生过多的监听器，导致性能问题。\n\n```\n$('div.foo li').on('click',function(event){\n    console.log(event.target);\n})\n```\n\n此时可以使用父元素事件代理（event delegation）的方式来处理，只用了一个监听器。\n\n```\n$('div.foo').on('click','li',function(event){\n    console.log(event.target);\n})\n```\n\n## 参考\n\n[MDN: Events Catagory](https://developer.mozilla.org/en-US/docs/Web/Events#Categories)\n\n[jQuery: Event Object](https://api.jquery.com/category/events/event-object/)\n\n[jQuery: event.targer](https://api.jquery.com/event.target/)\n\n[W3C: Dom Level-3 Event](https://www.w3.org/TR/DOM-Level-3-Events/)\n\n[jQuery: Event Delegation](https://learn.jquery.com/events/event-delegation/)\n\n","source":"_posts/2017-04-26-jQuery：事件监听用法.md","raw":"---\nlayout: post\ntitle:  \"jQuery：事件监听用法\"\ndate:   2017-04-26 20:00:00 +0800\ntags: jquery\n---\n## 常见事件类型\n\n* Form events: 如 submit\n* Focus events: 如 blur, focus, change\n* Input devices events: 如 keyup, keypress, mouseover, mousemove, mouseleave\n* View events: 如 scroll, resize\n\n## 事件监听三要素\n\n* the target element to listen to，监听对象\n* the event we want to react to，监听事件\n* the actions to take in response，回调函数\n\n## 基础示例\n\n```\n$('div.foo button').on('click',function(){\n    $(this).remove();\n})\n```\n\n## 更多用法\n\n```\n// 传递事件对象\n$('div.foo button).on('click',function(event){\n    $(event.target).remove(); // event.target 事件目标的页面元素\n})\n```\n\n```\n// 阻止默认行为\n$('div.foo a).on('click',function(event){\n    event.preventDefault();\n    console.log('the link you clicked will not work');\n})\n```\n\n### event\n\n* event.keyCode，用来了解按下的是哪个键\n* event.pageX, event.pageY，用来了解点击发生的坐标位置\n* event.type，用来了解发生的事件\n\n## 简易写法\n\n```\n$('div.foo').click(function(){...});\n$('div.foo').hover(function(){...});\n\n//等等\n```\n\n需要注意的是，`.hover()`监听了两个事件`mouseenter`和`mouseleave`，并且并不是所有事件都有简易的写法。\n\n更多简易写法参考：[jQuery: Events](http://api.jquery.com/category/events/)\n\n## 事件代理\n\n```\n<div class=\"foo\">\n    <ul>\n        <li> 1 </li>\n        <li> 2 </li>\n        ...\n        <li> 1000 </li>\n    </ul>\n</div>\n```\n\n假设有如上这样一个DOM片段，如果用以下方式进行事件监听，则会产生过多的监听器，导致性能问题。\n\n```\n$('div.foo li').on('click',function(event){\n    console.log(event.target);\n})\n```\n\n此时可以使用父元素事件代理（event delegation）的方式来处理，只用了一个监听器。\n\n```\n$('div.foo').on('click','li',function(event){\n    console.log(event.target);\n})\n```\n\n## 参考\n\n[MDN: Events Catagory](https://developer.mozilla.org/en-US/docs/Web/Events#Categories)\n\n[jQuery: Event Object](https://api.jquery.com/category/events/event-object/)\n\n[jQuery: event.targer](https://api.jquery.com/event.target/)\n\n[W3C: Dom Level-3 Event](https://www.w3.org/TR/DOM-Level-3-Events/)\n\n[jQuery: Event Delegation](https://learn.jquery.com/events/event-delegation/)\n\n","slug":"2017-04-26-jQuery：事件监听用法","published":1,"updated":"2017-08-06T12:15:08.000Z","_id":"cj60bzxky000o1dorelka49s1","comments":1,"photos":[],"link":"","content":"<h2 id=\"常见事件类型\"><a href=\"#常见事件类型\" class=\"headerlink\" title=\"常见事件类型\"></a>常见事件类型</h2><ul>\n<li>Form events: 如 submit</li>\n<li>Focus events: 如 blur, focus, change</li>\n<li>Input devices events: 如 keyup, keypress, mouseover, mousemove, mouseleave</li>\n<li>View events: 如 scroll, resize</li>\n</ul>\n<h2 id=\"事件监听三要素\"><a href=\"#事件监听三要素\" class=\"headerlink\" title=\"事件监听三要素\"></a>事件监听三要素</h2><ul>\n<li>the target element to listen to，监听对象</li>\n<li>the event we want to react to，监听事件</li>\n<li>the actions to take in response，回调函数</li>\n</ul>\n<h2 id=\"基础示例\"><a href=\"#基础示例\" class=\"headerlink\" title=\"基础示例\"></a>基础示例</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$(&apos;div.foo button&apos;).on(&apos;click&apos;,function()&#123;</div><div class=\"line\">    $(this).remove();</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h2 id=\"更多用法\"><a href=\"#更多用法\" class=\"headerlink\" title=\"更多用法\"></a>更多用法</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 传递事件对象</div><div class=\"line\">$(&apos;div.foo button).on(&apos;click&apos;,function(event)&#123;</div><div class=\"line\">    $(event.target).remove(); // event.target 事件目标的页面元素</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 阻止默认行为</div><div class=\"line\">$(&apos;div.foo a).on(&apos;click&apos;,function(event)&#123;</div><div class=\"line\">    event.preventDefault();</div><div class=\"line\">    console.log(&apos;the link you clicked will not work&apos;);</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h3 id=\"event\"><a href=\"#event\" class=\"headerlink\" title=\"event\"></a>event</h3><ul>\n<li>event.keyCode，用来了解按下的是哪个键</li>\n<li>event.pageX, event.pageY，用来了解点击发生的坐标位置</li>\n<li>event.type，用来了解发生的事件</li>\n</ul>\n<h2 id=\"简易写法\"><a href=\"#简易写法\" class=\"headerlink\" title=\"简易写法\"></a>简易写法</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">$(&apos;div.foo&apos;).click(function()&#123;...&#125;);</div><div class=\"line\">$(&apos;div.foo&apos;).hover(function()&#123;...&#125;);</div><div class=\"line\"></div><div class=\"line\">//等等</div></pre></td></tr></table></figure>\n<p>需要注意的是，<code>.hover()</code>监听了两个事件<code>mouseenter</code>和<code>mouseleave</code>，并且并不是所有事件都有简易的写法。</p>\n<p>更多简易写法参考：<a href=\"http://api.jquery.com/category/events/\" target=\"_blank\" rel=\"external\">jQuery: Events</a></p>\n<h2 id=\"事件代理\"><a href=\"#事件代理\" class=\"headerlink\" title=\"事件代理\"></a>事件代理</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div class=&quot;foo&quot;&gt;</div><div class=\"line\">    &lt;ul&gt;</div><div class=\"line\">        &lt;li&gt; 1 &lt;/li&gt;</div><div class=\"line\">        &lt;li&gt; 2 &lt;/li&gt;</div><div class=\"line\">        ...</div><div class=\"line\">        &lt;li&gt; 1000 &lt;/li&gt;</div><div class=\"line\">    &lt;/ul&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<p>假设有如上这样一个DOM片段，如果用以下方式进行事件监听，则会产生过多的监听器，导致性能问题。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$(&apos;div.foo li&apos;).on(&apos;click&apos;,function(event)&#123;</div><div class=\"line\">    console.log(event.target);</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>此时可以使用父元素事件代理（event delegation）的方式来处理，只用了一个监听器。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$(&apos;div.foo&apos;).on(&apos;click&apos;,&apos;li&apos;,function(event)&#123;</div><div class=\"line\">    console.log(event.target);</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://developer.mozilla.org/en-US/docs/Web/Events#Categories\" target=\"_blank\" rel=\"external\">MDN: Events Catagory</a></p>\n<p><a href=\"https://api.jquery.com/category/events/event-object/\" target=\"_blank\" rel=\"external\">jQuery: Event Object</a></p>\n<p><a href=\"https://api.jquery.com/event.target/\" target=\"_blank\" rel=\"external\">jQuery: event.targer</a></p>\n<p><a href=\"https://www.w3.org/TR/DOM-Level-3-Events/\" target=\"_blank\" rel=\"external\">W3C: Dom Level-3 Event</a></p>\n<p><a href=\"https://learn.jquery.com/events/event-delegation/\" target=\"_blank\" rel=\"external\">jQuery: Event Delegation</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"常见事件类型\"><a href=\"#常见事件类型\" class=\"headerlink\" title=\"常见事件类型\"></a>常见事件类型</h2><ul>\n<li>Form events: 如 submit</li>\n<li>Focus events: 如 blur, focus, change</li>\n<li>Input devices events: 如 keyup, keypress, mouseover, mousemove, mouseleave</li>\n<li>View events: 如 scroll, resize</li>\n</ul>\n<h2 id=\"事件监听三要素\"><a href=\"#事件监听三要素\" class=\"headerlink\" title=\"事件监听三要素\"></a>事件监听三要素</h2><ul>\n<li>the target element to listen to，监听对象</li>\n<li>the event we want to react to，监听事件</li>\n<li>the actions to take in response，回调函数</li>\n</ul>\n<h2 id=\"基础示例\"><a href=\"#基础示例\" class=\"headerlink\" title=\"基础示例\"></a>基础示例</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$(&apos;div.foo button&apos;).on(&apos;click&apos;,function()&#123;</div><div class=\"line\">    $(this).remove();</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h2 id=\"更多用法\"><a href=\"#更多用法\" class=\"headerlink\" title=\"更多用法\"></a>更多用法</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 传递事件对象</div><div class=\"line\">$(&apos;div.foo button).on(&apos;click&apos;,function(event)&#123;</div><div class=\"line\">    $(event.target).remove(); // event.target 事件目标的页面元素</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 阻止默认行为</div><div class=\"line\">$(&apos;div.foo a).on(&apos;click&apos;,function(event)&#123;</div><div class=\"line\">    event.preventDefault();</div><div class=\"line\">    console.log(&apos;the link you clicked will not work&apos;);</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h3 id=\"event\"><a href=\"#event\" class=\"headerlink\" title=\"event\"></a>event</h3><ul>\n<li>event.keyCode，用来了解按下的是哪个键</li>\n<li>event.pageX, event.pageY，用来了解点击发生的坐标位置</li>\n<li>event.type，用来了解发生的事件</li>\n</ul>\n<h2 id=\"简易写法\"><a href=\"#简易写法\" class=\"headerlink\" title=\"简易写法\"></a>简易写法</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">$(&apos;div.foo&apos;).click(function()&#123;...&#125;);</div><div class=\"line\">$(&apos;div.foo&apos;).hover(function()&#123;...&#125;);</div><div class=\"line\"></div><div class=\"line\">//等等</div></pre></td></tr></table></figure>\n<p>需要注意的是，<code>.hover()</code>监听了两个事件<code>mouseenter</code>和<code>mouseleave</code>，并且并不是所有事件都有简易的写法。</p>\n<p>更多简易写法参考：<a href=\"http://api.jquery.com/category/events/\" target=\"_blank\" rel=\"external\">jQuery: Events</a></p>\n<h2 id=\"事件代理\"><a href=\"#事件代理\" class=\"headerlink\" title=\"事件代理\"></a>事件代理</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div class=&quot;foo&quot;&gt;</div><div class=\"line\">    &lt;ul&gt;</div><div class=\"line\">        &lt;li&gt; 1 &lt;/li&gt;</div><div class=\"line\">        &lt;li&gt; 2 &lt;/li&gt;</div><div class=\"line\">        ...</div><div class=\"line\">        &lt;li&gt; 1000 &lt;/li&gt;</div><div class=\"line\">    &lt;/ul&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<p>假设有如上这样一个DOM片段，如果用以下方式进行事件监听，则会产生过多的监听器，导致性能问题。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$(&apos;div.foo li&apos;).on(&apos;click&apos;,function(event)&#123;</div><div class=\"line\">    console.log(event.target);</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>此时可以使用父元素事件代理（event delegation）的方式来处理，只用了一个监听器。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$(&apos;div.foo&apos;).on(&apos;click&apos;,&apos;li&apos;,function(event)&#123;</div><div class=\"line\">    console.log(event.target);</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://developer.mozilla.org/en-US/docs/Web/Events#Categories\" target=\"_blank\" rel=\"external\">MDN: Events Catagory</a></p>\n<p><a href=\"https://api.jquery.com/category/events/event-object/\" target=\"_blank\" rel=\"external\">jQuery: Event Object</a></p>\n<p><a href=\"https://api.jquery.com/event.target/\" target=\"_blank\" rel=\"external\">jQuery: event.targer</a></p>\n<p><a href=\"https://www.w3.org/TR/DOM-Level-3-Events/\" target=\"_blank\" rel=\"external\">W3C: Dom Level-3 Event</a></p>\n<p><a href=\"https://learn.jquery.com/events/event-delegation/\" target=\"_blank\" rel=\"external\">jQuery: Event Delegation</a></p>\n"},{"layout":"post","title":"jQuery：基础 DOM 操作方法","date":"2017-04-26T12:00:00.000Z","_content":"\n## 元素选择\n\n### 获取元素\n\n```\n// $(selector)\n$('div.foo');\n\n// $(element)\n$('div.foo').on('click',function(){\n    $(this).slideUp();\n})\n```\n\n### 遍历元素\n\n```\n// 父元素\n$('div.foo').parent();\n\n// 祖先元素\n$('div.foo').parents();\n\n// 子元素\n$('div.foo').children();\n\n// 后代元素\n$('div.foo').find();\n\n// 兄弟元素\n$('div.foo').sibling();\n```\n\n## DOM操作\n\n### 添加or删除class\n\n```\n$('div.foo').toggleClass('bar');\n```\n\n### 修改or获取属性\n\n```\n$('div.foo a').attr('href','#1');\n$('div.foo a').attr('href'); // #1\n```\n\n### 修改or获取CSS\n\n```\n$('div.foo').css('font-size','20px');\n$('div.foo').css('font-size'); // 20px\n```\n\n### 获取内容\n\n```\n$('div.foo').html(); // 完整的HTML代码\n$('div.foo').text(); // 去掉HTML标签后的文本\n$('div.foo input').val(); // 获取输入的值\n```\n\n### 移除\n\n```\n$('div.foo').remove();\n```\n\n### 添加child元素\n\n```\n$('div.foo').append('<p>last child</p>'>\n$('div.foo').prepend('<p>first child</p>'>\n```\n\n### 添加sibling元素\n\n```\n$('div.foo').after('<div>sibling after div.foo</div>');\n$('div.foo').before('<div>sibling before div.foo</div>');\n\n$('<div>sibling after div.foo</div>').insertAfter($('div.foo'));\n$('<div>sibling before div.foo</div>').insertBefore($('div.foo'));\n```\n\n### 遍历\n\n```\n$('p').each(function(){\n   var len = $(this).text().length;\n   alert(len); // 输出每个p标签的文字长度\n})\n```\n\n## DOM加载完成后执行\n\n```\n$(function(){\n    alert('the document is ready');\n\n    //do something\n})\n\n$(document).ready(function(){\n    alert('the document is ready');\n\n    //do something\n})\n```\n\n\n\n","source":"_posts/2017-04-26-jQuery：基础 DOM 操作方法.md","raw":"---\nlayout: post\ntitle:  \"jQuery：基础 DOM 操作方法\"\ndate:   2017-04-26 20:00:00 +0800\ntags: jquery\n---\n\n## 元素选择\n\n### 获取元素\n\n```\n// $(selector)\n$('div.foo');\n\n// $(element)\n$('div.foo').on('click',function(){\n    $(this).slideUp();\n})\n```\n\n### 遍历元素\n\n```\n// 父元素\n$('div.foo').parent();\n\n// 祖先元素\n$('div.foo').parents();\n\n// 子元素\n$('div.foo').children();\n\n// 后代元素\n$('div.foo').find();\n\n// 兄弟元素\n$('div.foo').sibling();\n```\n\n## DOM操作\n\n### 添加or删除class\n\n```\n$('div.foo').toggleClass('bar');\n```\n\n### 修改or获取属性\n\n```\n$('div.foo a').attr('href','#1');\n$('div.foo a').attr('href'); // #1\n```\n\n### 修改or获取CSS\n\n```\n$('div.foo').css('font-size','20px');\n$('div.foo').css('font-size'); // 20px\n```\n\n### 获取内容\n\n```\n$('div.foo').html(); // 完整的HTML代码\n$('div.foo').text(); // 去掉HTML标签后的文本\n$('div.foo input').val(); // 获取输入的值\n```\n\n### 移除\n\n```\n$('div.foo').remove();\n```\n\n### 添加child元素\n\n```\n$('div.foo').append('<p>last child</p>'>\n$('div.foo').prepend('<p>first child</p>'>\n```\n\n### 添加sibling元素\n\n```\n$('div.foo').after('<div>sibling after div.foo</div>');\n$('div.foo').before('<div>sibling before div.foo</div>');\n\n$('<div>sibling after div.foo</div>').insertAfter($('div.foo'));\n$('<div>sibling before div.foo</div>').insertBefore($('div.foo'));\n```\n\n### 遍历\n\n```\n$('p').each(function(){\n   var len = $(this).text().length;\n   alert(len); // 输出每个p标签的文字长度\n})\n```\n\n## DOM加载完成后执行\n\n```\n$(function(){\n    alert('the document is ready');\n\n    //do something\n})\n\n$(document).ready(function(){\n    alert('the document is ready');\n\n    //do something\n})\n```\n\n\n\n","slug":"2017-04-26-jQuery：基础 DOM 操作方法","published":1,"updated":"2017-08-06T12:15:05.000Z","_id":"cj60bzxkz000r1dorw8bzxypq","comments":1,"photos":[],"link":"","content":"<h2 id=\"元素选择\"><a href=\"#元素选择\" class=\"headerlink\" title=\"元素选择\"></a>元素选择</h2><h3 id=\"获取元素\"><a href=\"#获取元素\" class=\"headerlink\" title=\"获取元素\"></a>获取元素</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">// $(selector)</div><div class=\"line\">$(&apos;div.foo&apos;);</div><div class=\"line\"></div><div class=\"line\">// $(element)</div><div class=\"line\">$(&apos;div.foo&apos;).on(&apos;click&apos;,function()&#123;</div><div class=\"line\">    $(this).slideUp();</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h3 id=\"遍历元素\"><a href=\"#遍历元素\" class=\"headerlink\" title=\"遍历元素\"></a>遍历元素</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 父元素</div><div class=\"line\">$(&apos;div.foo&apos;).parent();</div><div class=\"line\"></div><div class=\"line\">// 祖先元素</div><div class=\"line\">$(&apos;div.foo&apos;).parents();</div><div class=\"line\"></div><div class=\"line\">// 子元素</div><div class=\"line\">$(&apos;div.foo&apos;).children();</div><div class=\"line\"></div><div class=\"line\">// 后代元素</div><div class=\"line\">$(&apos;div.foo&apos;).find();</div><div class=\"line\"></div><div class=\"line\">// 兄弟元素</div><div class=\"line\">$(&apos;div.foo&apos;).sibling();</div></pre></td></tr></table></figure>\n<h2 id=\"DOM操作\"><a href=\"#DOM操作\" class=\"headerlink\" title=\"DOM操作\"></a>DOM操作</h2><h3 id=\"添加or删除class\"><a href=\"#添加or删除class\" class=\"headerlink\" title=\"添加or删除class\"></a>添加or删除class</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$(&apos;div.foo&apos;).toggleClass(&apos;bar&apos;);</div></pre></td></tr></table></figure>\n<h3 id=\"修改or获取属性\"><a href=\"#修改or获取属性\" class=\"headerlink\" title=\"修改or获取属性\"></a>修改or获取属性</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$(&apos;div.foo a&apos;).attr(&apos;href&apos;,&apos;#1&apos;);</div><div class=\"line\">$(&apos;div.foo a&apos;).attr(&apos;href&apos;); // #1</div></pre></td></tr></table></figure>\n<h3 id=\"修改or获取CSS\"><a href=\"#修改or获取CSS\" class=\"headerlink\" title=\"修改or获取CSS\"></a>修改or获取CSS</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$(&apos;div.foo&apos;).css(&apos;font-size&apos;,&apos;20px&apos;);</div><div class=\"line\">$(&apos;div.foo&apos;).css(&apos;font-size&apos;); // 20px</div></pre></td></tr></table></figure>\n<h3 id=\"获取内容\"><a href=\"#获取内容\" class=\"headerlink\" title=\"获取内容\"></a>获取内容</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$(&apos;div.foo&apos;).html(); // 完整的HTML代码</div><div class=\"line\">$(&apos;div.foo&apos;).text(); // 去掉HTML标签后的文本</div><div class=\"line\">$(&apos;div.foo input&apos;).val(); // 获取输入的值</div></pre></td></tr></table></figure>\n<h3 id=\"移除\"><a href=\"#移除\" class=\"headerlink\" title=\"移除\"></a>移除</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$(&apos;div.foo&apos;).remove();</div></pre></td></tr></table></figure>\n<h3 id=\"添加child元素\"><a href=\"#添加child元素\" class=\"headerlink\" title=\"添加child元素\"></a>添加child元素</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$(&apos;div.foo&apos;).append(&apos;&lt;p&gt;last child&lt;/p&gt;&apos;&gt;</div><div class=\"line\">$(&apos;div.foo&apos;).prepend(&apos;&lt;p&gt;first child&lt;/p&gt;&apos;&gt;</div></pre></td></tr></table></figure>\n<h3 id=\"添加sibling元素\"><a href=\"#添加sibling元素\" class=\"headerlink\" title=\"添加sibling元素\"></a>添加sibling元素</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">$(&apos;div.foo&apos;).after(&apos;&lt;div&gt;sibling after div.foo&lt;/div&gt;&apos;);</div><div class=\"line\">$(&apos;div.foo&apos;).before(&apos;&lt;div&gt;sibling before div.foo&lt;/div&gt;&apos;);</div><div class=\"line\"></div><div class=\"line\">$(&apos;&lt;div&gt;sibling after div.foo&lt;/div&gt;&apos;).insertAfter($(&apos;div.foo&apos;));</div><div class=\"line\">$(&apos;&lt;div&gt;sibling before div.foo&lt;/div&gt;&apos;).insertBefore($(&apos;div.foo&apos;));</div></pre></td></tr></table></figure>\n<h3 id=\"遍历\"><a href=\"#遍历\" class=\"headerlink\" title=\"遍历\"></a>遍历</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">$(&apos;p&apos;).each(function()&#123;</div><div class=\"line\">   var len = $(this).text().length;</div><div class=\"line\">   alert(len); // 输出每个p标签的文字长度</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h2 id=\"DOM加载完成后执行\"><a href=\"#DOM加载完成后执行\" class=\"headerlink\" title=\"DOM加载完成后执行\"></a>DOM加载完成后执行</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">$(function()&#123;</div><div class=\"line\">    alert(&apos;the document is ready&apos;);</div><div class=\"line\"></div><div class=\"line\">    //do something</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">$(document).ready(function()&#123;</div><div class=\"line\">    alert(&apos;the document is ready&apos;);</div><div class=\"line\"></div><div class=\"line\">    //do something</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"元素选择\"><a href=\"#元素选择\" class=\"headerlink\" title=\"元素选择\"></a>元素选择</h2><h3 id=\"获取元素\"><a href=\"#获取元素\" class=\"headerlink\" title=\"获取元素\"></a>获取元素</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">// $(selector)</div><div class=\"line\">$(&apos;div.foo&apos;);</div><div class=\"line\"></div><div class=\"line\">// $(element)</div><div class=\"line\">$(&apos;div.foo&apos;).on(&apos;click&apos;,function()&#123;</div><div class=\"line\">    $(this).slideUp();</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h3 id=\"遍历元素\"><a href=\"#遍历元素\" class=\"headerlink\" title=\"遍历元素\"></a>遍历元素</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 父元素</div><div class=\"line\">$(&apos;div.foo&apos;).parent();</div><div class=\"line\"></div><div class=\"line\">// 祖先元素</div><div class=\"line\">$(&apos;div.foo&apos;).parents();</div><div class=\"line\"></div><div class=\"line\">// 子元素</div><div class=\"line\">$(&apos;div.foo&apos;).children();</div><div class=\"line\"></div><div class=\"line\">// 后代元素</div><div class=\"line\">$(&apos;div.foo&apos;).find();</div><div class=\"line\"></div><div class=\"line\">// 兄弟元素</div><div class=\"line\">$(&apos;div.foo&apos;).sibling();</div></pre></td></tr></table></figure>\n<h2 id=\"DOM操作\"><a href=\"#DOM操作\" class=\"headerlink\" title=\"DOM操作\"></a>DOM操作</h2><h3 id=\"添加or删除class\"><a href=\"#添加or删除class\" class=\"headerlink\" title=\"添加or删除class\"></a>添加or删除class</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$(&apos;div.foo&apos;).toggleClass(&apos;bar&apos;);</div></pre></td></tr></table></figure>\n<h3 id=\"修改or获取属性\"><a href=\"#修改or获取属性\" class=\"headerlink\" title=\"修改or获取属性\"></a>修改or获取属性</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$(&apos;div.foo a&apos;).attr(&apos;href&apos;,&apos;#1&apos;);</div><div class=\"line\">$(&apos;div.foo a&apos;).attr(&apos;href&apos;); // #1</div></pre></td></tr></table></figure>\n<h3 id=\"修改or获取CSS\"><a href=\"#修改or获取CSS\" class=\"headerlink\" title=\"修改or获取CSS\"></a>修改or获取CSS</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$(&apos;div.foo&apos;).css(&apos;font-size&apos;,&apos;20px&apos;);</div><div class=\"line\">$(&apos;div.foo&apos;).css(&apos;font-size&apos;); // 20px</div></pre></td></tr></table></figure>\n<h3 id=\"获取内容\"><a href=\"#获取内容\" class=\"headerlink\" title=\"获取内容\"></a>获取内容</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$(&apos;div.foo&apos;).html(); // 完整的HTML代码</div><div class=\"line\">$(&apos;div.foo&apos;).text(); // 去掉HTML标签后的文本</div><div class=\"line\">$(&apos;div.foo input&apos;).val(); // 获取输入的值</div></pre></td></tr></table></figure>\n<h3 id=\"移除\"><a href=\"#移除\" class=\"headerlink\" title=\"移除\"></a>移除</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$(&apos;div.foo&apos;).remove();</div></pre></td></tr></table></figure>\n<h3 id=\"添加child元素\"><a href=\"#添加child元素\" class=\"headerlink\" title=\"添加child元素\"></a>添加child元素</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$(&apos;div.foo&apos;).append(&apos;&lt;p&gt;last child&lt;/p&gt;&apos;&gt;</div><div class=\"line\">$(&apos;div.foo&apos;).prepend(&apos;&lt;p&gt;first child&lt;/p&gt;&apos;&gt;</div></pre></td></tr></table></figure>\n<h3 id=\"添加sibling元素\"><a href=\"#添加sibling元素\" class=\"headerlink\" title=\"添加sibling元素\"></a>添加sibling元素</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">$(&apos;div.foo&apos;).after(&apos;&lt;div&gt;sibling after div.foo&lt;/div&gt;&apos;);</div><div class=\"line\">$(&apos;div.foo&apos;).before(&apos;&lt;div&gt;sibling before div.foo&lt;/div&gt;&apos;);</div><div class=\"line\"></div><div class=\"line\">$(&apos;&lt;div&gt;sibling after div.foo&lt;/div&gt;&apos;).insertAfter($(&apos;div.foo&apos;));</div><div class=\"line\">$(&apos;&lt;div&gt;sibling before div.foo&lt;/div&gt;&apos;).insertBefore($(&apos;div.foo&apos;));</div></pre></td></tr></table></figure>\n<h3 id=\"遍历\"><a href=\"#遍历\" class=\"headerlink\" title=\"遍历\"></a>遍历</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">$(&apos;p&apos;).each(function()&#123;</div><div class=\"line\">   var len = $(this).text().length;</div><div class=\"line\">   alert(len); // 输出每个p标签的文字长度</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h2 id=\"DOM加载完成后执行\"><a href=\"#DOM加载完成后执行\" class=\"headerlink\" title=\"DOM加载完成后执行\"></a>DOM加载完成后执行</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">$(function()&#123;</div><div class=\"line\">    alert(&apos;the document is ready&apos;);</div><div class=\"line\"></div><div class=\"line\">    //do something</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">$(document).ready(function()&#123;</div><div class=\"line\">    alert(&apos;the document is ready&apos;);</div><div class=\"line\"></div><div class=\"line\">    //do something</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n"},{"layout":"post","title":"JavaScript：作用域、闭包 和 this","date":"2017-04-27T12:00:00.000Z","_content":"\n## 作用域（Scope）\n\n在JavaScript中，函数的一对花括号中会产生一个新的作用域。这个作用域只有函数内部能够访问。\n\n```\nvar a = 1;\nvar fn = function(){\n    var b = 2;\n    console.log(b);\n}\n\nconsole.log(a); // 1\nfn(); // 2\nconsole.log(b); // Error\n```\n\n需要注意的是，if、while、for语句的语句块也是一对花括号构成，但是这对花括号并没有形成新的作用域。\n\n```\nvar a = 1;\n\nif(a){\n    var b = 2;\n    console.log(b); // 2\n}\n\nconsole.log(a); // 1\nconsole.log(b); // 2，可以获取if(){}中的变量b\n```\n\nwhile、for语句同理。\n\n### 执行上下文（Excution context）\n\n执行上下文是内存中存储的作用域结构，也叫内存作用域。根据执行上下文，我们可以知道哪些变量是可以被访问的，而哪些变量是在作用域之外的。![](/assets/javascript-excution-context.png)需要注意的是，函数在没有被执行之前，我们只需要记下”函数的位置“即可，到真正被调用的时候，再去计算里面的值，此时就需要注意作用域的问题了。\n\n## 闭包（Closure）\n\n由于每个函数可以访问包围它的作用域中的变量，所以闭包指的就是，在外部作用域已经返回之后还能访问该作用域的任意函数。\n\n简单来说，就是能访问函数内部作用域的函数。\n\n```\nfunction closure(){\n    var a = 1;\n    \n    return function(){\n        console.log(a);\n    }\n}\n\nclosure()(); // 1\n```\n\n返回的匿名函数可以访问closure的作用域，故能够获取变量a的值。此时，这个返回的匿名函数就是一个闭包。\n\n闭包能够访问一个函数内部的私有变量，这个私有变量是外部作用域永远无法访问的。\n\n透彻理解解释器执行代码时的工作方式，以及变量作用域和闭包，对JS面向对象编程是至关重要的。\n\n## this\n\n> 对this最好的理解，是把它看做函数被调用时传入的参数。\n\n在函数没有被调用前，我们永远无法得知this指向哪一个对象。\n\n```\nvar fn = function(one, two){\n    console.log(one, two);\n}\nvar r={}, g={}, b={}, y={};\n\nr.method = fn;\n\nr.method(); // this=r, one=undefined, two=undefined\nfn(g,b);  // Global, g, b\nfn.call(r, g, b); // r, g, b\nr.method.call(y, g, b); // y, g, b\n\nsetTimeout(fn, 1000); // this的值不确定，undefined, undefined\nsetTimeout(r.method, 1000); // this的值不确定（跟r无关），undefined,undefined\nsetTimeout(function(){\n    r.method(); // r, undefined, undefined \n    },1000); \n\nconsole.log(one); // Referrence Error\nconsole.log(this); // Global\nnew r.method(g, b); // {}, g, b\n```\n\n上面的代码例子中注意`setTimeout(r.method, 1000)`和`new r.method(g ,b)`。\n\n### 注意点1：其实是同一个function对象\n\n实际上`r.method`和`fn`指向的是同一个function对象，只是两者在执行时，传入的是不同的`this`参数。\n\n所以以下两个语句是相等的\n\n```\nsetTimeout(r.method, 1000);\n\nsetTimeout(fn, 1000);\n```\n\n### 注意点2：new关键字的作用\n\n`new`关键字执行了以下几步：\n\n* 创建一个空对象\n* 把函数的this指向这个空对象\n* 执行这个函数\n* 返回创建的对象\n\n所以下面三条语句实际上是相等的。\n\n```\nnew r.method(g, b);\n\nr.method.call({},g,b);\n\nfn.call({},g,b);\n```\n\n全程，其实跟`r`一点关系都没有。\n\n","source":"_posts/2017-04-27-JavaScript：作用域、闭包 和 this.md","raw":"---\nlayout: post\ntitle:  \"JavaScript：作用域、闭包 和 this\"\ndate:   2017-04-27 20:00:00 +0800\ntags: javascript\n---\n\n## 作用域（Scope）\n\n在JavaScript中，函数的一对花括号中会产生一个新的作用域。这个作用域只有函数内部能够访问。\n\n```\nvar a = 1;\nvar fn = function(){\n    var b = 2;\n    console.log(b);\n}\n\nconsole.log(a); // 1\nfn(); // 2\nconsole.log(b); // Error\n```\n\n需要注意的是，if、while、for语句的语句块也是一对花括号构成，但是这对花括号并没有形成新的作用域。\n\n```\nvar a = 1;\n\nif(a){\n    var b = 2;\n    console.log(b); // 2\n}\n\nconsole.log(a); // 1\nconsole.log(b); // 2，可以获取if(){}中的变量b\n```\n\nwhile、for语句同理。\n\n### 执行上下文（Excution context）\n\n执行上下文是内存中存储的作用域结构，也叫内存作用域。根据执行上下文，我们可以知道哪些变量是可以被访问的，而哪些变量是在作用域之外的。![](/assets/javascript-excution-context.png)需要注意的是，函数在没有被执行之前，我们只需要记下”函数的位置“即可，到真正被调用的时候，再去计算里面的值，此时就需要注意作用域的问题了。\n\n## 闭包（Closure）\n\n由于每个函数可以访问包围它的作用域中的变量，所以闭包指的就是，在外部作用域已经返回之后还能访问该作用域的任意函数。\n\n简单来说，就是能访问函数内部作用域的函数。\n\n```\nfunction closure(){\n    var a = 1;\n    \n    return function(){\n        console.log(a);\n    }\n}\n\nclosure()(); // 1\n```\n\n返回的匿名函数可以访问closure的作用域，故能够获取变量a的值。此时，这个返回的匿名函数就是一个闭包。\n\n闭包能够访问一个函数内部的私有变量，这个私有变量是外部作用域永远无法访问的。\n\n透彻理解解释器执行代码时的工作方式，以及变量作用域和闭包，对JS面向对象编程是至关重要的。\n\n## this\n\n> 对this最好的理解，是把它看做函数被调用时传入的参数。\n\n在函数没有被调用前，我们永远无法得知this指向哪一个对象。\n\n```\nvar fn = function(one, two){\n    console.log(one, two);\n}\nvar r={}, g={}, b={}, y={};\n\nr.method = fn;\n\nr.method(); // this=r, one=undefined, two=undefined\nfn(g,b);  // Global, g, b\nfn.call(r, g, b); // r, g, b\nr.method.call(y, g, b); // y, g, b\n\nsetTimeout(fn, 1000); // this的值不确定，undefined, undefined\nsetTimeout(r.method, 1000); // this的值不确定（跟r无关），undefined,undefined\nsetTimeout(function(){\n    r.method(); // r, undefined, undefined \n    },1000); \n\nconsole.log(one); // Referrence Error\nconsole.log(this); // Global\nnew r.method(g, b); // {}, g, b\n```\n\n上面的代码例子中注意`setTimeout(r.method, 1000)`和`new r.method(g ,b)`。\n\n### 注意点1：其实是同一个function对象\n\n实际上`r.method`和`fn`指向的是同一个function对象，只是两者在执行时，传入的是不同的`this`参数。\n\n所以以下两个语句是相等的\n\n```\nsetTimeout(r.method, 1000);\n\nsetTimeout(fn, 1000);\n```\n\n### 注意点2：new关键字的作用\n\n`new`关键字执行了以下几步：\n\n* 创建一个空对象\n* 把函数的this指向这个空对象\n* 执行这个函数\n* 返回创建的对象\n\n所以下面三条语句实际上是相等的。\n\n```\nnew r.method(g, b);\n\nr.method.call({},g,b);\n\nfn.call({},g,b);\n```\n\n全程，其实跟`r`一点关系都没有。\n\n","slug":"2017-04-27-JavaScript：作用域、闭包 和 this","published":1,"updated":"2017-08-06T12:15:12.000Z","_id":"cj60bzxl1000t1dor8n3l34hk","comments":1,"photos":[],"link":"","content":"<h2 id=\"作用域（Scope）\"><a href=\"#作用域（Scope）\" class=\"headerlink\" title=\"作用域（Scope）\"></a>作用域（Scope）</h2><p>在JavaScript中，函数的一对花括号中会产生一个新的作用域。这个作用域只有函数内部能够访问。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">var a = 1;</div><div class=\"line\">var fn = function()&#123;</div><div class=\"line\">    var b = 2;</div><div class=\"line\">    console.log(b);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">console.log(a); // 1</div><div class=\"line\">fn(); // 2</div><div class=\"line\">console.log(b); // Error</div></pre></td></tr></table></figure>\n<p>需要注意的是，if、while、for语句的语句块也是一对花括号构成，但是这对花括号并没有形成新的作用域。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">var a = 1;</div><div class=\"line\"></div><div class=\"line\">if(a)&#123;</div><div class=\"line\">    var b = 2;</div><div class=\"line\">    console.log(b); // 2</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">console.log(a); // 1</div><div class=\"line\">console.log(b); // 2，可以获取if()&#123;&#125;中的变量b</div></pre></td></tr></table></figure>\n<p>while、for语句同理。</p>\n<h3 id=\"执行上下文（Excution-context）\"><a href=\"#执行上下文（Excution-context）\" class=\"headerlink\" title=\"执行上下文（Excution context）\"></a>执行上下文（Excution context）</h3><p>执行上下文是内存中存储的作用域结构，也叫内存作用域。根据执行上下文，我们可以知道哪些变量是可以被访问的，而哪些变量是在作用域之外的。<img src=\"/assets/javascript-excution-context.png\" alt=\"\">需要注意的是，函数在没有被执行之前，我们只需要记下”函数的位置“即可，到真正被调用的时候，再去计算里面的值，此时就需要注意作用域的问题了。</p>\n<h2 id=\"闭包（Closure）\"><a href=\"#闭包（Closure）\" class=\"headerlink\" title=\"闭包（Closure）\"></a>闭包（Closure）</h2><p>由于每个函数可以访问包围它的作用域中的变量，所以闭包指的就是，在外部作用域已经返回之后还能访问该作用域的任意函数。</p>\n<p>简单来说，就是能访问函数内部作用域的函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">function closure()&#123;</div><div class=\"line\">    var a = 1;</div><div class=\"line\">    </div><div class=\"line\">    return function()&#123;</div><div class=\"line\">        console.log(a);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">closure()(); // 1</div></pre></td></tr></table></figure>\n<p>返回的匿名函数可以访问closure的作用域，故能够获取变量a的值。此时，这个返回的匿名函数就是一个闭包。</p>\n<p>闭包能够访问一个函数内部的私有变量，这个私有变量是外部作用域永远无法访问的。</p>\n<p>透彻理解解释器执行代码时的工作方式，以及变量作用域和闭包，对JS面向对象编程是至关重要的。</p>\n<h2 id=\"this\"><a href=\"#this\" class=\"headerlink\" title=\"this\"></a>this</h2><blockquote>\n<p>对this最好的理解，是把它看做函数被调用时传入的参数。</p>\n</blockquote>\n<p>在函数没有被调用前，我们永远无法得知this指向哪一个对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">var fn = function(one, two)&#123;</div><div class=\"line\">    console.log(one, two);</div><div class=\"line\">&#125;</div><div class=\"line\">var r=&#123;&#125;, g=&#123;&#125;, b=&#123;&#125;, y=&#123;&#125;;</div><div class=\"line\"></div><div class=\"line\">r.method = fn;</div><div class=\"line\"></div><div class=\"line\">r.method(); // this=r, one=undefined, two=undefined</div><div class=\"line\">fn(g,b);  // Global, g, b</div><div class=\"line\">fn.call(r, g, b); // r, g, b</div><div class=\"line\">r.method.call(y, g, b); // y, g, b</div><div class=\"line\"></div><div class=\"line\">setTimeout(fn, 1000); // this的值不确定，undefined, undefined</div><div class=\"line\">setTimeout(r.method, 1000); // this的值不确定（跟r无关），undefined,undefined</div><div class=\"line\">setTimeout(function()&#123;</div><div class=\"line\">    r.method(); // r, undefined, undefined </div><div class=\"line\">    &#125;,1000); </div><div class=\"line\"></div><div class=\"line\">console.log(one); // Referrence Error</div><div class=\"line\">console.log(this); // Global</div><div class=\"line\">new r.method(g, b); // &#123;&#125;, g, b</div></pre></td></tr></table></figure>\n<p>上面的代码例子中注意<code>setTimeout(r.method, 1000)</code>和<code>new r.method(g ,b)</code>。</p>\n<h3 id=\"注意点1：其实是同一个function对象\"><a href=\"#注意点1：其实是同一个function对象\" class=\"headerlink\" title=\"注意点1：其实是同一个function对象\"></a>注意点1：其实是同一个function对象</h3><p>实际上<code>r.method</code>和<code>fn</code>指向的是同一个function对象，只是两者在执行时，传入的是不同的<code>this</code>参数。</p>\n<p>所以以下两个语句是相等的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">setTimeout(r.method, 1000);</div><div class=\"line\"></div><div class=\"line\">setTimeout(fn, 1000);</div></pre></td></tr></table></figure>\n<h3 id=\"注意点2：new关键字的作用\"><a href=\"#注意点2：new关键字的作用\" class=\"headerlink\" title=\"注意点2：new关键字的作用\"></a>注意点2：new关键字的作用</h3><p><code>new</code>关键字执行了以下几步：</p>\n<ul>\n<li>创建一个空对象</li>\n<li>把函数的this指向这个空对象</li>\n<li>执行这个函数</li>\n<li>返回创建的对象</li>\n</ul>\n<p>所以下面三条语句实际上是相等的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">new r.method(g, b);</div><div class=\"line\"></div><div class=\"line\">r.method.call(&#123;&#125;,g,b);</div><div class=\"line\"></div><div class=\"line\">fn.call(&#123;&#125;,g,b);</div></pre></td></tr></table></figure>\n<p>全程，其实跟<code>r</code>一点关系都没有。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"作用域（Scope）\"><a href=\"#作用域（Scope）\" class=\"headerlink\" title=\"作用域（Scope）\"></a>作用域（Scope）</h2><p>在JavaScript中，函数的一对花括号中会产生一个新的作用域。这个作用域只有函数内部能够访问。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">var a = 1;</div><div class=\"line\">var fn = function()&#123;</div><div class=\"line\">    var b = 2;</div><div class=\"line\">    console.log(b);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">console.log(a); // 1</div><div class=\"line\">fn(); // 2</div><div class=\"line\">console.log(b); // Error</div></pre></td></tr></table></figure>\n<p>需要注意的是，if、while、for语句的语句块也是一对花括号构成，但是这对花括号并没有形成新的作用域。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">var a = 1;</div><div class=\"line\"></div><div class=\"line\">if(a)&#123;</div><div class=\"line\">    var b = 2;</div><div class=\"line\">    console.log(b); // 2</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">console.log(a); // 1</div><div class=\"line\">console.log(b); // 2，可以获取if()&#123;&#125;中的变量b</div></pre></td></tr></table></figure>\n<p>while、for语句同理。</p>\n<h3 id=\"执行上下文（Excution-context）\"><a href=\"#执行上下文（Excution-context）\" class=\"headerlink\" title=\"执行上下文（Excution context）\"></a>执行上下文（Excution context）</h3><p>执行上下文是内存中存储的作用域结构，也叫内存作用域。根据执行上下文，我们可以知道哪些变量是可以被访问的，而哪些变量是在作用域之外的。<img src=\"/assets/javascript-excution-context.png\" alt=\"\">需要注意的是，函数在没有被执行之前，我们只需要记下”函数的位置“即可，到真正被调用的时候，再去计算里面的值，此时就需要注意作用域的问题了。</p>\n<h2 id=\"闭包（Closure）\"><a href=\"#闭包（Closure）\" class=\"headerlink\" title=\"闭包（Closure）\"></a>闭包（Closure）</h2><p>由于每个函数可以访问包围它的作用域中的变量，所以闭包指的就是，在外部作用域已经返回之后还能访问该作用域的任意函数。</p>\n<p>简单来说，就是能访问函数内部作用域的函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">function closure()&#123;</div><div class=\"line\">    var a = 1;</div><div class=\"line\">    </div><div class=\"line\">    return function()&#123;</div><div class=\"line\">        console.log(a);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">closure()(); // 1</div></pre></td></tr></table></figure>\n<p>返回的匿名函数可以访问closure的作用域，故能够获取变量a的值。此时，这个返回的匿名函数就是一个闭包。</p>\n<p>闭包能够访问一个函数内部的私有变量，这个私有变量是外部作用域永远无法访问的。</p>\n<p>透彻理解解释器执行代码时的工作方式，以及变量作用域和闭包，对JS面向对象编程是至关重要的。</p>\n<h2 id=\"this\"><a href=\"#this\" class=\"headerlink\" title=\"this\"></a>this</h2><blockquote>\n<p>对this最好的理解，是把它看做函数被调用时传入的参数。</p>\n</blockquote>\n<p>在函数没有被调用前，我们永远无法得知this指向哪一个对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">var fn = function(one, two)&#123;</div><div class=\"line\">    console.log(one, two);</div><div class=\"line\">&#125;</div><div class=\"line\">var r=&#123;&#125;, g=&#123;&#125;, b=&#123;&#125;, y=&#123;&#125;;</div><div class=\"line\"></div><div class=\"line\">r.method = fn;</div><div class=\"line\"></div><div class=\"line\">r.method(); // this=r, one=undefined, two=undefined</div><div class=\"line\">fn(g,b);  // Global, g, b</div><div class=\"line\">fn.call(r, g, b); // r, g, b</div><div class=\"line\">r.method.call(y, g, b); // y, g, b</div><div class=\"line\"></div><div class=\"line\">setTimeout(fn, 1000); // this的值不确定，undefined, undefined</div><div class=\"line\">setTimeout(r.method, 1000); // this的值不确定（跟r无关），undefined,undefined</div><div class=\"line\">setTimeout(function()&#123;</div><div class=\"line\">    r.method(); // r, undefined, undefined </div><div class=\"line\">    &#125;,1000); </div><div class=\"line\"></div><div class=\"line\">console.log(one); // Referrence Error</div><div class=\"line\">console.log(this); // Global</div><div class=\"line\">new r.method(g, b); // &#123;&#125;, g, b</div></pre></td></tr></table></figure>\n<p>上面的代码例子中注意<code>setTimeout(r.method, 1000)</code>和<code>new r.method(g ,b)</code>。</p>\n<h3 id=\"注意点1：其实是同一个function对象\"><a href=\"#注意点1：其实是同一个function对象\" class=\"headerlink\" title=\"注意点1：其实是同一个function对象\"></a>注意点1：其实是同一个function对象</h3><p>实际上<code>r.method</code>和<code>fn</code>指向的是同一个function对象，只是两者在执行时，传入的是不同的<code>this</code>参数。</p>\n<p>所以以下两个语句是相等的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">setTimeout(r.method, 1000);</div><div class=\"line\"></div><div class=\"line\">setTimeout(fn, 1000);</div></pre></td></tr></table></figure>\n<h3 id=\"注意点2：new关键字的作用\"><a href=\"#注意点2：new关键字的作用\" class=\"headerlink\" title=\"注意点2：new关键字的作用\"></a>注意点2：new关键字的作用</h3><p><code>new</code>关键字执行了以下几步：</p>\n<ul>\n<li>创建一个空对象</li>\n<li>把函数的this指向这个空对象</li>\n<li>执行这个函数</li>\n<li>返回创建的对象</li>\n</ul>\n<p>所以下面三条语句实际上是相等的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">new r.method(g, b);</div><div class=\"line\"></div><div class=\"line\">r.method.call(&#123;&#125;,g,b);</div><div class=\"line\"></div><div class=\"line\">fn.call(&#123;&#125;,g,b);</div></pre></td></tr></table></figure>\n<p>全程，其实跟<code>r</code>一点关系都没有。</p>\n"},{"layout":"post","title":"JavaScript：从代码复用到面向对象","date":"2017-05-03T12:00:00.000Z","_content":"\n## 代码复用的问题\n\n```\nvar foo = {color:'red'};\nvar bar = {color:'green'};\n```\n\n这段代码中我们生成了两个属性相似的对象，每次生成一个类似的对象都需要重新写一遍代码。\n\n## 装饰器函数\n\n### 添加属性\n\n```\n// lib.js\nvar fn = function(obj,color){\n    obj.color = color;\n    return obj;\n}\n\n// app.js\nvar foo = fn({},'red');\nvar bar = fn({},'green');\n```\n\n我们可以通过一个装饰器函数，来解决生成类似对象的问题。\n\n装饰器函数的作用，就是给某个已拥有某些功能的对象添加属性。这里我们传入了一个空的对象，通过fn函数来对这个空对象进行”装饰“（添加属性）。\n\n### 添加方法\n\n#### 浪费内存\n\n```\n// lib.js\nvar fn = function(obj,color){\n    obj.color = color;\n    obj.printColor = function(){\n        console.log(this.color);\n    }\n\n    return obj;\n}\n\n// app.js\nvar foo = fn({},'red');\nfoo.printColor(); // red\nvar bar = fn({},'green');\nbar.printColor(); // green\n```\n\n上述添加方法的方式，优点是具有良好的封装性，但是最大的问题是每次调用装饰器函数都会在内存中生成一个新的`printColor函数`。在对象比较多的情况下，就容易浪费内存。\n\n#### 更多的缺点\n\n```\n// lib.js\nvar fn = function(obj,color){\n    obj.color = color;\n    obj.printColor = printColor;\n    return obj;\n}\n\nvar printColor = function(){\n    console.log(this.printColor);\n}\n\n// app.js\nvar foo = fn({},'red');\nfoo.printColor(); // red\nvar bar = fn({},'green');\nbar.printColor(); // green\n```\n\n上述添加方法的方式，尽管解决了内存占用的问题，但是失去了良好的封装性。\n\n除此之外，如果添加的方法比较多，每次都需要在fn中对函数进行绑定，效率很低。\n\n```\n// lib.js\nvar fn = function(obj,color){\n    obj.color = color;\n    obj.method_1 = method_1;\n    obj.method_2 = method_2;\n    // ...\n    obj.method_1000 = method_3;\n\n    return obj;\n}\n\nvar method_1 = function(){ //... };\nvar method_2 = function(){ //... };\n// ...\nvar method_1000 = function(){ //... };\n```\n\n#### 把方法都装在一起\n\n在把方法都装进`methods`中，通过遍历的方式可以把任意数量的方法绑定到`obj`上。\n\n```\n// lib.js\nvar fn = function(obj,color){\n    obj.color = color;\n\n    extend(obj,methods); // extend()代表把methods中的属性复制到obj中，注意它并不是原生的函数\n\n    return obj;\n}\n\nvar methods = {\n    method_1:function(){ //... },\n    method_2:function(){ //... },\n    // ...\n    method_1000:function(){ //... }\n};\n```\n\n#### 借助Function对象的属性\n\n`methods`与`fn`之间没有一个非常明显的联系，为此我们可以利用`Function对象`的属性来解决。\n\n```\n// lib.js\nvar fn = function(obj,color){\n    obj.color = color;\n\n    extend(obj, fn.methods);\n\n    return obj;\n}\n\nfn.methods = {\n    method_1:function(){ //... },\n    method_2:function(){ //... },\n    // ...\n    method_1000:function(){ //... }\n}\n```\n\n#### 直接在function内部创建对象\n\n```\n// lib.js\n\nvar fn = function(color){\n    var obj = {};\n    obj.color = color;\n\n    extend(obj, fn.methods);\n\n    return obj;\n}\n```\n\n## 原型委托\n\n```\n// lib.js\nvar fn = function(color){\n    var obj = Object.create(fn.methods);\n    obj.color = color;\n\n    return obj;\n}\n\nfn.methods = { //... };\n```\n\n### 使用prototype属性\n\n```\n// lib.js\nvar fn = function(color){\n    var obj = Object.create(fn.prototype);\n    obj.color = color;\n\n    return obj;\n}\nfn.prototype.printColor = function(){\n    console.log(this.color);\n}\n```\n\n此时`fn`就是一个“构造函数”，每一个函数对象被创建时都会有一个`prototype`属性，这个属性跟之前的`fn.methods`其实并没有太大的区别，唯一的区别在于`prototype.constructor`指向了函数对象本身。\n\n在我们讨论“实例的原型”和“构造函数的原型”时要注意：“实例的原型”实际上就是`instance.prototype`，在实例中没有的属性会被委托到原型中进行查找。而“构造函数的原型”，实际上是“创建一个对象，并且把这个对象委托给原型进行函数共享”。\n\n### 关系验证\n\n```\n// app.js\nvar foo = fn('red');\nvar bar = fn('green');\n\nconsole.log(foo instanceof fn); // true\n// instanceof 操作符 实际上执行的就是下面的操作\nconsole.log(foo.constructor == fn.prototype.construector); // true\n```\n\n### new 关键字\n\n在fn中，创建一个对象、原型委托和返回对象是一定会做的一件事情，我们可以通过`new关键字`来简化。\n\n```\n// lib.js\nvar fn = function(color){\n    this.color = color;\n}\n```\n\n在使用`new关键字`进行调用时（构造模式），解释器会自动插入两行代码：\n\n```\n// lib.js\nvar fn = function(color){\n    this = Object.create(fn.prototype); // 将新对象委托给原型对象\n\n    this.color;\n\n    return this; // 返回这个新对象\n}\n```\n\n使用构造模式即使用`new关键字`调用fn函数才能被真正称作“构造函数”。\n\n### 子类继承\n\n```\nvar Human = function(name){\n    this.name = name;\n}\n\nHuman.prototype.sayName = function(){\n    console.log(this.name);\n}\n\nvar Man = function(name){\n    Human.call(this, name);\n    this.sex = 'male';\n}\nMan.prototype = Object.create(Human.prototype);\nMan.prototype.constructor = Man;\n\nvar frank = new Man('frank');\n\nfrank.sayName(); // frank\nconsole.log(frank instanceof Man); // true\nconsole.log(frank instanceof Human); // true\n```\n\n务必注意`Man`继承`Human`时调用的`Human`方法，其使用`call`方法指定了`this`绑定的对象。`this`在JavaScript中可以作为一个传入的参数来看待，在使用`obj.method()`时，`method`中的`this`指向`obj`，而使用`new method()`时，`this`指向新构造的空对象。\n\n此外，`Man.prototype`对象的原型委托给了`Human.prototype`形成了原型链`。`这里还需要注意要重新指定`Man.prototype.constructor`赋值`Man`。\n\n","source":"_posts/2017-05-03-JavaScript：从代码复用到面向对象.md","raw":"---\nlayout: post\ntitle:  \"JavaScript：从代码复用到面向对象\"\ndate:   2017-05-03 20:00:00 +0800\ntags: javascript\n---\n\n## 代码复用的问题\n\n```\nvar foo = {color:'red'};\nvar bar = {color:'green'};\n```\n\n这段代码中我们生成了两个属性相似的对象，每次生成一个类似的对象都需要重新写一遍代码。\n\n## 装饰器函数\n\n### 添加属性\n\n```\n// lib.js\nvar fn = function(obj,color){\n    obj.color = color;\n    return obj;\n}\n\n// app.js\nvar foo = fn({},'red');\nvar bar = fn({},'green');\n```\n\n我们可以通过一个装饰器函数，来解决生成类似对象的问题。\n\n装饰器函数的作用，就是给某个已拥有某些功能的对象添加属性。这里我们传入了一个空的对象，通过fn函数来对这个空对象进行”装饰“（添加属性）。\n\n### 添加方法\n\n#### 浪费内存\n\n```\n// lib.js\nvar fn = function(obj,color){\n    obj.color = color;\n    obj.printColor = function(){\n        console.log(this.color);\n    }\n\n    return obj;\n}\n\n// app.js\nvar foo = fn({},'red');\nfoo.printColor(); // red\nvar bar = fn({},'green');\nbar.printColor(); // green\n```\n\n上述添加方法的方式，优点是具有良好的封装性，但是最大的问题是每次调用装饰器函数都会在内存中生成一个新的`printColor函数`。在对象比较多的情况下，就容易浪费内存。\n\n#### 更多的缺点\n\n```\n// lib.js\nvar fn = function(obj,color){\n    obj.color = color;\n    obj.printColor = printColor;\n    return obj;\n}\n\nvar printColor = function(){\n    console.log(this.printColor);\n}\n\n// app.js\nvar foo = fn({},'red');\nfoo.printColor(); // red\nvar bar = fn({},'green');\nbar.printColor(); // green\n```\n\n上述添加方法的方式，尽管解决了内存占用的问题，但是失去了良好的封装性。\n\n除此之外，如果添加的方法比较多，每次都需要在fn中对函数进行绑定，效率很低。\n\n```\n// lib.js\nvar fn = function(obj,color){\n    obj.color = color;\n    obj.method_1 = method_1;\n    obj.method_2 = method_2;\n    // ...\n    obj.method_1000 = method_3;\n\n    return obj;\n}\n\nvar method_1 = function(){ //... };\nvar method_2 = function(){ //... };\n// ...\nvar method_1000 = function(){ //... };\n```\n\n#### 把方法都装在一起\n\n在把方法都装进`methods`中，通过遍历的方式可以把任意数量的方法绑定到`obj`上。\n\n```\n// lib.js\nvar fn = function(obj,color){\n    obj.color = color;\n\n    extend(obj,methods); // extend()代表把methods中的属性复制到obj中，注意它并不是原生的函数\n\n    return obj;\n}\n\nvar methods = {\n    method_1:function(){ //... },\n    method_2:function(){ //... },\n    // ...\n    method_1000:function(){ //... }\n};\n```\n\n#### 借助Function对象的属性\n\n`methods`与`fn`之间没有一个非常明显的联系，为此我们可以利用`Function对象`的属性来解决。\n\n```\n// lib.js\nvar fn = function(obj,color){\n    obj.color = color;\n\n    extend(obj, fn.methods);\n\n    return obj;\n}\n\nfn.methods = {\n    method_1:function(){ //... },\n    method_2:function(){ //... },\n    // ...\n    method_1000:function(){ //... }\n}\n```\n\n#### 直接在function内部创建对象\n\n```\n// lib.js\n\nvar fn = function(color){\n    var obj = {};\n    obj.color = color;\n\n    extend(obj, fn.methods);\n\n    return obj;\n}\n```\n\n## 原型委托\n\n```\n// lib.js\nvar fn = function(color){\n    var obj = Object.create(fn.methods);\n    obj.color = color;\n\n    return obj;\n}\n\nfn.methods = { //... };\n```\n\n### 使用prototype属性\n\n```\n// lib.js\nvar fn = function(color){\n    var obj = Object.create(fn.prototype);\n    obj.color = color;\n\n    return obj;\n}\nfn.prototype.printColor = function(){\n    console.log(this.color);\n}\n```\n\n此时`fn`就是一个“构造函数”，每一个函数对象被创建时都会有一个`prototype`属性，这个属性跟之前的`fn.methods`其实并没有太大的区别，唯一的区别在于`prototype.constructor`指向了函数对象本身。\n\n在我们讨论“实例的原型”和“构造函数的原型”时要注意：“实例的原型”实际上就是`instance.prototype`，在实例中没有的属性会被委托到原型中进行查找。而“构造函数的原型”，实际上是“创建一个对象，并且把这个对象委托给原型进行函数共享”。\n\n### 关系验证\n\n```\n// app.js\nvar foo = fn('red');\nvar bar = fn('green');\n\nconsole.log(foo instanceof fn); // true\n// instanceof 操作符 实际上执行的就是下面的操作\nconsole.log(foo.constructor == fn.prototype.construector); // true\n```\n\n### new 关键字\n\n在fn中，创建一个对象、原型委托和返回对象是一定会做的一件事情，我们可以通过`new关键字`来简化。\n\n```\n// lib.js\nvar fn = function(color){\n    this.color = color;\n}\n```\n\n在使用`new关键字`进行调用时（构造模式），解释器会自动插入两行代码：\n\n```\n// lib.js\nvar fn = function(color){\n    this = Object.create(fn.prototype); // 将新对象委托给原型对象\n\n    this.color;\n\n    return this; // 返回这个新对象\n}\n```\n\n使用构造模式即使用`new关键字`调用fn函数才能被真正称作“构造函数”。\n\n### 子类继承\n\n```\nvar Human = function(name){\n    this.name = name;\n}\n\nHuman.prototype.sayName = function(){\n    console.log(this.name);\n}\n\nvar Man = function(name){\n    Human.call(this, name);\n    this.sex = 'male';\n}\nMan.prototype = Object.create(Human.prototype);\nMan.prototype.constructor = Man;\n\nvar frank = new Man('frank');\n\nfrank.sayName(); // frank\nconsole.log(frank instanceof Man); // true\nconsole.log(frank instanceof Human); // true\n```\n\n务必注意`Man`继承`Human`时调用的`Human`方法，其使用`call`方法指定了`this`绑定的对象。`this`在JavaScript中可以作为一个传入的参数来看待，在使用`obj.method()`时，`method`中的`this`指向`obj`，而使用`new method()`时，`this`指向新构造的空对象。\n\n此外，`Man.prototype`对象的原型委托给了`Human.prototype`形成了原型链`。`这里还需要注意要重新指定`Man.prototype.constructor`赋值`Man`。\n\n","slug":"2017-05-03-JavaScript：从代码复用到面向对象","published":1,"updated":"2017-08-06T12:15:15.000Z","_id":"cj60bzxl2000w1dordwdiqwco","comments":1,"photos":[],"link":"","content":"<h2 id=\"代码复用的问题\"><a href=\"#代码复用的问题\" class=\"headerlink\" title=\"代码复用的问题\"></a>代码复用的问题</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">var foo = &#123;color:&apos;red&apos;&#125;;</div><div class=\"line\">var bar = &#123;color:&apos;green&apos;&#125;;</div></pre></td></tr></table></figure>\n<p>这段代码中我们生成了两个属性相似的对象，每次生成一个类似的对象都需要重新写一遍代码。</p>\n<h2 id=\"装饰器函数\"><a href=\"#装饰器函数\" class=\"headerlink\" title=\"装饰器函数\"></a>装饰器函数</h2><h3 id=\"添加属性\"><a href=\"#添加属性\" class=\"headerlink\" title=\"添加属性\"></a>添加属性</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">// lib.js</div><div class=\"line\">var fn = function(obj,color)&#123;</div><div class=\"line\">    obj.color = color;</div><div class=\"line\">    return obj;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// app.js</div><div class=\"line\">var foo = fn(&#123;&#125;,&apos;red&apos;);</div><div class=\"line\">var bar = fn(&#123;&#125;,&apos;green&apos;);</div></pre></td></tr></table></figure>\n<p>我们可以通过一个装饰器函数，来解决生成类似对象的问题。</p>\n<p>装饰器函数的作用，就是给某个已拥有某些功能的对象添加属性。这里我们传入了一个空的对象，通过fn函数来对这个空对象进行”装饰“（添加属性）。</p>\n<h3 id=\"添加方法\"><a href=\"#添加方法\" class=\"headerlink\" title=\"添加方法\"></a>添加方法</h3><h4 id=\"浪费内存\"><a href=\"#浪费内存\" class=\"headerlink\" title=\"浪费内存\"></a>浪费内存</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">// lib.js</div><div class=\"line\">var fn = function(obj,color)&#123;</div><div class=\"line\">    obj.color = color;</div><div class=\"line\">    obj.printColor = function()&#123;</div><div class=\"line\">        console.log(this.color);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return obj;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// app.js</div><div class=\"line\">var foo = fn(&#123;&#125;,&apos;red&apos;);</div><div class=\"line\">foo.printColor(); // red</div><div class=\"line\">var bar = fn(&#123;&#125;,&apos;green&apos;);</div><div class=\"line\">bar.printColor(); // green</div></pre></td></tr></table></figure>\n<p>上述添加方法的方式，优点是具有良好的封装性，但是最大的问题是每次调用装饰器函数都会在内存中生成一个新的<code>printColor函数</code>。在对象比较多的情况下，就容易浪费内存。</p>\n<h4 id=\"更多的缺点\"><a href=\"#更多的缺点\" class=\"headerlink\" title=\"更多的缺点\"></a>更多的缺点</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">// lib.js</div><div class=\"line\">var fn = function(obj,color)&#123;</div><div class=\"line\">    obj.color = color;</div><div class=\"line\">    obj.printColor = printColor;</div><div class=\"line\">    return obj;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var printColor = function()&#123;</div><div class=\"line\">    console.log(this.printColor);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// app.js</div><div class=\"line\">var foo = fn(&#123;&#125;,&apos;red&apos;);</div><div class=\"line\">foo.printColor(); // red</div><div class=\"line\">var bar = fn(&#123;&#125;,&apos;green&apos;);</div><div class=\"line\">bar.printColor(); // green</div></pre></td></tr></table></figure>\n<p>上述添加方法的方式，尽管解决了内存占用的问题，但是失去了良好的封装性。</p>\n<p>除此之外，如果添加的方法比较多，每次都需要在fn中对函数进行绑定，效率很低。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">// lib.js</div><div class=\"line\">var fn = function(obj,color)&#123;</div><div class=\"line\">    obj.color = color;</div><div class=\"line\">    obj.method_1 = method_1;</div><div class=\"line\">    obj.method_2 = method_2;</div><div class=\"line\">    // ...</div><div class=\"line\">    obj.method_1000 = method_3;</div><div class=\"line\"></div><div class=\"line\">    return obj;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var method_1 = function()&#123; //... &#125;;</div><div class=\"line\">var method_2 = function()&#123; //... &#125;;</div><div class=\"line\">// ...</div><div class=\"line\">var method_1000 = function()&#123; //... &#125;;</div></pre></td></tr></table></figure>\n<h4 id=\"把方法都装在一起\"><a href=\"#把方法都装在一起\" class=\"headerlink\" title=\"把方法都装在一起\"></a>把方法都装在一起</h4><p>在把方法都装进<code>methods</code>中，通过遍历的方式可以把任意数量的方法绑定到<code>obj</code>上。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">// lib.js</div><div class=\"line\">var fn = function(obj,color)&#123;</div><div class=\"line\">    obj.color = color;</div><div class=\"line\"></div><div class=\"line\">    extend(obj,methods); // extend()代表把methods中的属性复制到obj中，注意它并不是原生的函数</div><div class=\"line\"></div><div class=\"line\">    return obj;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var methods = &#123;</div><div class=\"line\">    method_1:function()&#123; //... &#125;,</div><div class=\"line\">    method_2:function()&#123; //... &#125;,</div><div class=\"line\">    // ...</div><div class=\"line\">    method_1000:function()&#123; //... &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h4 id=\"借助Function对象的属性\"><a href=\"#借助Function对象的属性\" class=\"headerlink\" title=\"借助Function对象的属性\"></a>借助Function对象的属性</h4><p><code>methods</code>与<code>fn</code>之间没有一个非常明显的联系，为此我们可以利用<code>Function对象</code>的属性来解决。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">// lib.js</div><div class=\"line\">var fn = function(obj,color)&#123;</div><div class=\"line\">    obj.color = color;</div><div class=\"line\"></div><div class=\"line\">    extend(obj, fn.methods);</div><div class=\"line\"></div><div class=\"line\">    return obj;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">fn.methods = &#123;</div><div class=\"line\">    method_1:function()&#123; //... &#125;,</div><div class=\"line\">    method_2:function()&#123; //... &#125;,</div><div class=\"line\">    // ...</div><div class=\"line\">    method_1000:function()&#123; //... &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"直接在function内部创建对象\"><a href=\"#直接在function内部创建对象\" class=\"headerlink\" title=\"直接在function内部创建对象\"></a>直接在function内部创建对象</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">// lib.js</div><div class=\"line\"></div><div class=\"line\">var fn = function(color)&#123;</div><div class=\"line\">    var obj = &#123;&#125;;</div><div class=\"line\">    obj.color = color;</div><div class=\"line\"></div><div class=\"line\">    extend(obj, fn.methods);</div><div class=\"line\"></div><div class=\"line\">    return obj;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"原型委托\"><a href=\"#原型委托\" class=\"headerlink\" title=\"原型委托\"></a>原型委托</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">// lib.js</div><div class=\"line\">var fn = function(color)&#123;</div><div class=\"line\">    var obj = Object.create(fn.methods);</div><div class=\"line\">    obj.color = color;</div><div class=\"line\"></div><div class=\"line\">    return obj;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">fn.methods = &#123; //... &#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"使用prototype属性\"><a href=\"#使用prototype属性\" class=\"headerlink\" title=\"使用prototype属性\"></a>使用prototype属性</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">// lib.js</div><div class=\"line\">var fn = function(color)&#123;</div><div class=\"line\">    var obj = Object.create(fn.prototype);</div><div class=\"line\">    obj.color = color;</div><div class=\"line\"></div><div class=\"line\">    return obj;</div><div class=\"line\">&#125;</div><div class=\"line\">fn.prototype.printColor = function()&#123;</div><div class=\"line\">    console.log(this.color);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>此时<code>fn</code>就是一个“构造函数”，每一个函数对象被创建时都会有一个<code>prototype</code>属性，这个属性跟之前的<code>fn.methods</code>其实并没有太大的区别，唯一的区别在于<code>prototype.constructor</code>指向了函数对象本身。</p>\n<p>在我们讨论“实例的原型”和“构造函数的原型”时要注意：“实例的原型”实际上就是<code>instance.prototype</code>，在实例中没有的属性会被委托到原型中进行查找。而“构造函数的原型”，实际上是“创建一个对象，并且把这个对象委托给原型进行函数共享”。</p>\n<h3 id=\"关系验证\"><a href=\"#关系验证\" class=\"headerlink\" title=\"关系验证\"></a>关系验证</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">// app.js</div><div class=\"line\">var foo = fn(&apos;red&apos;);</div><div class=\"line\">var bar = fn(&apos;green&apos;);</div><div class=\"line\"></div><div class=\"line\">console.log(foo instanceof fn); // true</div><div class=\"line\">// instanceof 操作符 实际上执行的就是下面的操作</div><div class=\"line\">console.log(foo.constructor == fn.prototype.construector); // true</div></pre></td></tr></table></figure>\n<h3 id=\"new-关键字\"><a href=\"#new-关键字\" class=\"headerlink\" title=\"new 关键字\"></a>new 关键字</h3><p>在fn中，创建一个对象、原型委托和返回对象是一定会做的一件事情，我们可以通过<code>new关键字</code>来简化。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">// lib.js</div><div class=\"line\">var fn = function(color)&#123;</div><div class=\"line\">    this.color = color;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在使用<code>new关键字</code>进行调用时（构造模式），解释器会自动插入两行代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">// lib.js</div><div class=\"line\">var fn = function(color)&#123;</div><div class=\"line\">    this = Object.create(fn.prototype); // 将新对象委托给原型对象</div><div class=\"line\"></div><div class=\"line\">    this.color;</div><div class=\"line\"></div><div class=\"line\">    return this; // 返回这个新对象</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用构造模式即使用<code>new关键字</code>调用fn函数才能被真正称作“构造函数”。</p>\n<h3 id=\"子类继承\"><a href=\"#子类继承\" class=\"headerlink\" title=\"子类继承\"></a>子类继承</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">var Human = function(name)&#123;</div><div class=\"line\">    this.name = name;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Human.prototype.sayName = function()&#123;</div><div class=\"line\">    console.log(this.name);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var Man = function(name)&#123;</div><div class=\"line\">    Human.call(this, name);</div><div class=\"line\">    this.sex = &apos;male&apos;;</div><div class=\"line\">&#125;</div><div class=\"line\">Man.prototype = Object.create(Human.prototype);</div><div class=\"line\">Man.prototype.constructor = Man;</div><div class=\"line\"></div><div class=\"line\">var frank = new Man(&apos;frank&apos;);</div><div class=\"line\"></div><div class=\"line\">frank.sayName(); // frank</div><div class=\"line\">console.log(frank instanceof Man); // true</div><div class=\"line\">console.log(frank instanceof Human); // true</div></pre></td></tr></table></figure>\n<p>务必注意<code>Man</code>继承<code>Human</code>时调用的<code>Human</code>方法，其使用<code>call</code>方法指定了<code>this</code>绑定的对象。<code>this</code>在JavaScript中可以作为一个传入的参数来看待，在使用<code>obj.method()</code>时，<code>method</code>中的<code>this</code>指向<code>obj</code>，而使用<code>new method()</code>时，<code>this</code>指向新构造的空对象。</p>\n<p>此外，<code>Man.prototype</code>对象的原型委托给了<code>Human.prototype</code>形成了原型链<code>。</code>这里还需要注意要重新指定<code>Man.prototype.constructor</code>赋值<code>Man</code>。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"代码复用的问题\"><a href=\"#代码复用的问题\" class=\"headerlink\" title=\"代码复用的问题\"></a>代码复用的问题</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">var foo = &#123;color:&apos;red&apos;&#125;;</div><div class=\"line\">var bar = &#123;color:&apos;green&apos;&#125;;</div></pre></td></tr></table></figure>\n<p>这段代码中我们生成了两个属性相似的对象，每次生成一个类似的对象都需要重新写一遍代码。</p>\n<h2 id=\"装饰器函数\"><a href=\"#装饰器函数\" class=\"headerlink\" title=\"装饰器函数\"></a>装饰器函数</h2><h3 id=\"添加属性\"><a href=\"#添加属性\" class=\"headerlink\" title=\"添加属性\"></a>添加属性</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">// lib.js</div><div class=\"line\">var fn = function(obj,color)&#123;</div><div class=\"line\">    obj.color = color;</div><div class=\"line\">    return obj;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// app.js</div><div class=\"line\">var foo = fn(&#123;&#125;,&apos;red&apos;);</div><div class=\"line\">var bar = fn(&#123;&#125;,&apos;green&apos;);</div></pre></td></tr></table></figure>\n<p>我们可以通过一个装饰器函数，来解决生成类似对象的问题。</p>\n<p>装饰器函数的作用，就是给某个已拥有某些功能的对象添加属性。这里我们传入了一个空的对象，通过fn函数来对这个空对象进行”装饰“（添加属性）。</p>\n<h3 id=\"添加方法\"><a href=\"#添加方法\" class=\"headerlink\" title=\"添加方法\"></a>添加方法</h3><h4 id=\"浪费内存\"><a href=\"#浪费内存\" class=\"headerlink\" title=\"浪费内存\"></a>浪费内存</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">// lib.js</div><div class=\"line\">var fn = function(obj,color)&#123;</div><div class=\"line\">    obj.color = color;</div><div class=\"line\">    obj.printColor = function()&#123;</div><div class=\"line\">        console.log(this.color);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return obj;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// app.js</div><div class=\"line\">var foo = fn(&#123;&#125;,&apos;red&apos;);</div><div class=\"line\">foo.printColor(); // red</div><div class=\"line\">var bar = fn(&#123;&#125;,&apos;green&apos;);</div><div class=\"line\">bar.printColor(); // green</div></pre></td></tr></table></figure>\n<p>上述添加方法的方式，优点是具有良好的封装性，但是最大的问题是每次调用装饰器函数都会在内存中生成一个新的<code>printColor函数</code>。在对象比较多的情况下，就容易浪费内存。</p>\n<h4 id=\"更多的缺点\"><a href=\"#更多的缺点\" class=\"headerlink\" title=\"更多的缺点\"></a>更多的缺点</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">// lib.js</div><div class=\"line\">var fn = function(obj,color)&#123;</div><div class=\"line\">    obj.color = color;</div><div class=\"line\">    obj.printColor = printColor;</div><div class=\"line\">    return obj;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var printColor = function()&#123;</div><div class=\"line\">    console.log(this.printColor);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// app.js</div><div class=\"line\">var foo = fn(&#123;&#125;,&apos;red&apos;);</div><div class=\"line\">foo.printColor(); // red</div><div class=\"line\">var bar = fn(&#123;&#125;,&apos;green&apos;);</div><div class=\"line\">bar.printColor(); // green</div></pre></td></tr></table></figure>\n<p>上述添加方法的方式，尽管解决了内存占用的问题，但是失去了良好的封装性。</p>\n<p>除此之外，如果添加的方法比较多，每次都需要在fn中对函数进行绑定，效率很低。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">// lib.js</div><div class=\"line\">var fn = function(obj,color)&#123;</div><div class=\"line\">    obj.color = color;</div><div class=\"line\">    obj.method_1 = method_1;</div><div class=\"line\">    obj.method_2 = method_2;</div><div class=\"line\">    // ...</div><div class=\"line\">    obj.method_1000 = method_3;</div><div class=\"line\"></div><div class=\"line\">    return obj;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var method_1 = function()&#123; //... &#125;;</div><div class=\"line\">var method_2 = function()&#123; //... &#125;;</div><div class=\"line\">// ...</div><div class=\"line\">var method_1000 = function()&#123; //... &#125;;</div></pre></td></tr></table></figure>\n<h4 id=\"把方法都装在一起\"><a href=\"#把方法都装在一起\" class=\"headerlink\" title=\"把方法都装在一起\"></a>把方法都装在一起</h4><p>在把方法都装进<code>methods</code>中，通过遍历的方式可以把任意数量的方法绑定到<code>obj</code>上。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">// lib.js</div><div class=\"line\">var fn = function(obj,color)&#123;</div><div class=\"line\">    obj.color = color;</div><div class=\"line\"></div><div class=\"line\">    extend(obj,methods); // extend()代表把methods中的属性复制到obj中，注意它并不是原生的函数</div><div class=\"line\"></div><div class=\"line\">    return obj;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var methods = &#123;</div><div class=\"line\">    method_1:function()&#123; //... &#125;,</div><div class=\"line\">    method_2:function()&#123; //... &#125;,</div><div class=\"line\">    // ...</div><div class=\"line\">    method_1000:function()&#123; //... &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h4 id=\"借助Function对象的属性\"><a href=\"#借助Function对象的属性\" class=\"headerlink\" title=\"借助Function对象的属性\"></a>借助Function对象的属性</h4><p><code>methods</code>与<code>fn</code>之间没有一个非常明显的联系，为此我们可以利用<code>Function对象</code>的属性来解决。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">// lib.js</div><div class=\"line\">var fn = function(obj,color)&#123;</div><div class=\"line\">    obj.color = color;</div><div class=\"line\"></div><div class=\"line\">    extend(obj, fn.methods);</div><div class=\"line\"></div><div class=\"line\">    return obj;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">fn.methods = &#123;</div><div class=\"line\">    method_1:function()&#123; //... &#125;,</div><div class=\"line\">    method_2:function()&#123; //... &#125;,</div><div class=\"line\">    // ...</div><div class=\"line\">    method_1000:function()&#123; //... &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"直接在function内部创建对象\"><a href=\"#直接在function内部创建对象\" class=\"headerlink\" title=\"直接在function内部创建对象\"></a>直接在function内部创建对象</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">// lib.js</div><div class=\"line\"></div><div class=\"line\">var fn = function(color)&#123;</div><div class=\"line\">    var obj = &#123;&#125;;</div><div class=\"line\">    obj.color = color;</div><div class=\"line\"></div><div class=\"line\">    extend(obj, fn.methods);</div><div class=\"line\"></div><div class=\"line\">    return obj;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"原型委托\"><a href=\"#原型委托\" class=\"headerlink\" title=\"原型委托\"></a>原型委托</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">// lib.js</div><div class=\"line\">var fn = function(color)&#123;</div><div class=\"line\">    var obj = Object.create(fn.methods);</div><div class=\"line\">    obj.color = color;</div><div class=\"line\"></div><div class=\"line\">    return obj;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">fn.methods = &#123; //... &#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"使用prototype属性\"><a href=\"#使用prototype属性\" class=\"headerlink\" title=\"使用prototype属性\"></a>使用prototype属性</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">// lib.js</div><div class=\"line\">var fn = function(color)&#123;</div><div class=\"line\">    var obj = Object.create(fn.prototype);</div><div class=\"line\">    obj.color = color;</div><div class=\"line\"></div><div class=\"line\">    return obj;</div><div class=\"line\">&#125;</div><div class=\"line\">fn.prototype.printColor = function()&#123;</div><div class=\"line\">    console.log(this.color);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>此时<code>fn</code>就是一个“构造函数”，每一个函数对象被创建时都会有一个<code>prototype</code>属性，这个属性跟之前的<code>fn.methods</code>其实并没有太大的区别，唯一的区别在于<code>prototype.constructor</code>指向了函数对象本身。</p>\n<p>在我们讨论“实例的原型”和“构造函数的原型”时要注意：“实例的原型”实际上就是<code>instance.prototype</code>，在实例中没有的属性会被委托到原型中进行查找。而“构造函数的原型”，实际上是“创建一个对象，并且把这个对象委托给原型进行函数共享”。</p>\n<h3 id=\"关系验证\"><a href=\"#关系验证\" class=\"headerlink\" title=\"关系验证\"></a>关系验证</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">// app.js</div><div class=\"line\">var foo = fn(&apos;red&apos;);</div><div class=\"line\">var bar = fn(&apos;green&apos;);</div><div class=\"line\"></div><div class=\"line\">console.log(foo instanceof fn); // true</div><div class=\"line\">// instanceof 操作符 实际上执行的就是下面的操作</div><div class=\"line\">console.log(foo.constructor == fn.prototype.construector); // true</div></pre></td></tr></table></figure>\n<h3 id=\"new-关键字\"><a href=\"#new-关键字\" class=\"headerlink\" title=\"new 关键字\"></a>new 关键字</h3><p>在fn中，创建一个对象、原型委托和返回对象是一定会做的一件事情，我们可以通过<code>new关键字</code>来简化。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">// lib.js</div><div class=\"line\">var fn = function(color)&#123;</div><div class=\"line\">    this.color = color;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在使用<code>new关键字</code>进行调用时（构造模式），解释器会自动插入两行代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">// lib.js</div><div class=\"line\">var fn = function(color)&#123;</div><div class=\"line\">    this = Object.create(fn.prototype); // 将新对象委托给原型对象</div><div class=\"line\"></div><div class=\"line\">    this.color;</div><div class=\"line\"></div><div class=\"line\">    return this; // 返回这个新对象</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用构造模式即使用<code>new关键字</code>调用fn函数才能被真正称作“构造函数”。</p>\n<h3 id=\"子类继承\"><a href=\"#子类继承\" class=\"headerlink\" title=\"子类继承\"></a>子类继承</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">var Human = function(name)&#123;</div><div class=\"line\">    this.name = name;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Human.prototype.sayName = function()&#123;</div><div class=\"line\">    console.log(this.name);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var Man = function(name)&#123;</div><div class=\"line\">    Human.call(this, name);</div><div class=\"line\">    this.sex = &apos;male&apos;;</div><div class=\"line\">&#125;</div><div class=\"line\">Man.prototype = Object.create(Human.prototype);</div><div class=\"line\">Man.prototype.constructor = Man;</div><div class=\"line\"></div><div class=\"line\">var frank = new Man(&apos;frank&apos;);</div><div class=\"line\"></div><div class=\"line\">frank.sayName(); // frank</div><div class=\"line\">console.log(frank instanceof Man); // true</div><div class=\"line\">console.log(frank instanceof Human); // true</div></pre></td></tr></table></figure>\n<p>务必注意<code>Man</code>继承<code>Human</code>时调用的<code>Human</code>方法，其使用<code>call</code>方法指定了<code>this</code>绑定的对象。<code>this</code>在JavaScript中可以作为一个传入的参数来看待，在使用<code>obj.method()</code>时，<code>method</code>中的<code>this</code>指向<code>obj</code>，而使用<code>new method()</code>时，<code>this</code>指向新构造的空对象。</p>\n<p>此外，<code>Man.prototype</code>对象的原型委托给了<code>Human.prototype</code>形成了原型链<code>。</code>这里还需要注意要重新指定<code>Man.prototype.constructor</code>赋值<code>Man</code>。</p>\n"},{"layout":"post","title":"JavaScript：逻辑与 与 逻辑或","date":"2017-05-08T12:00:00.000Z","_content":"\n## 逻辑与\n\n逻辑与是**短路操作**，如果第一个**操作数**能够决定结果，那么将不会对接下来的**操作数**进行**求值**。\n\n```\nvar a = 0,\n    b = 1;\n\na && b++;\n\nconsole.log(a); // 0\nconsole.log(b); // 1, b++没有执行\n```\n\n### 表达式语句的值\n\n如果操作数都是`True`（对象、非空字符串、非`0`或`NaN`的数字、布尔值`True`），则返回最后一个操作数。\n\n如果操作数中有若干个`False`（`Null`、`Undefined`、空字符串、`NaN`、布尔值`False`），则返回第一个`False`。\n\n```\n{} && false ; // false\n{} && 0; // 0\n{} && null; // null\n{} && undefined; // undefined\n\nnull && 0; // null\n\n{a:1} && {b:1} && {c:1}; // {c:1}\n```\n\n与函数相结合\n\n```\ntrue && foo(); // 执行foo\ntrue && false && foo(); // 返回false，不执行foo\n```\n\n## 逻辑或\n\n逻辑或与逻辑与一样，也是**短路操作**。\n\n```\nvar a = 0,\n    b = 1;\n\nb || a++;\n\nconsole.log(a); // 0\nconsole.log(b); // 1\n```\n\n### 表达式语句的值\n\n如果操作数都是False，则返回最后一个操作数。\n\n如果操作数中有若干个True，则返回第一个True。\n\n逻辑或一般用于避免给变量赋null或undefined值。\n\n```\nvar foo = null;\n    bar = 1;\n\nvar value = foo || bar;\n```\n\n也可以用来在函数中对参数进行校验，下面三个函数等价，但是显然第一个是最优雅的。\n\n```\nfunction(v){\n    var value = v || defaultValue;\n}\n\nfunction(v){\n    var value = !!v ? v : defaultValue;\n}\n\nfunction(v){\n    if(v){\n        var value = v;\n    }else{\n        var value = defaultValue;\n    }\n}\n```\n\n\n\n","source":"_posts/2017-05-08-JavaScript：逻辑与 与 逻辑或.md","raw":"---\nlayout: post\ntitle:  \"JavaScript：逻辑与 与 逻辑或\"\ndate:   2017-05-08 20:00:00 +0800\ntags: javascript\n---\n\n## 逻辑与\n\n逻辑与是**短路操作**，如果第一个**操作数**能够决定结果，那么将不会对接下来的**操作数**进行**求值**。\n\n```\nvar a = 0,\n    b = 1;\n\na && b++;\n\nconsole.log(a); // 0\nconsole.log(b); // 1, b++没有执行\n```\n\n### 表达式语句的值\n\n如果操作数都是`True`（对象、非空字符串、非`0`或`NaN`的数字、布尔值`True`），则返回最后一个操作数。\n\n如果操作数中有若干个`False`（`Null`、`Undefined`、空字符串、`NaN`、布尔值`False`），则返回第一个`False`。\n\n```\n{} && false ; // false\n{} && 0; // 0\n{} && null; // null\n{} && undefined; // undefined\n\nnull && 0; // null\n\n{a:1} && {b:1} && {c:1}; // {c:1}\n```\n\n与函数相结合\n\n```\ntrue && foo(); // 执行foo\ntrue && false && foo(); // 返回false，不执行foo\n```\n\n## 逻辑或\n\n逻辑或与逻辑与一样，也是**短路操作**。\n\n```\nvar a = 0,\n    b = 1;\n\nb || a++;\n\nconsole.log(a); // 0\nconsole.log(b); // 1\n```\n\n### 表达式语句的值\n\n如果操作数都是False，则返回最后一个操作数。\n\n如果操作数中有若干个True，则返回第一个True。\n\n逻辑或一般用于避免给变量赋null或undefined值。\n\n```\nvar foo = null;\n    bar = 1;\n\nvar value = foo || bar;\n```\n\n也可以用来在函数中对参数进行校验，下面三个函数等价，但是显然第一个是最优雅的。\n\n```\nfunction(v){\n    var value = v || defaultValue;\n}\n\nfunction(v){\n    var value = !!v ? v : defaultValue;\n}\n\nfunction(v){\n    if(v){\n        var value = v;\n    }else{\n        var value = defaultValue;\n    }\n}\n```\n\n\n\n","slug":"2017-05-08-JavaScript：逻辑与 与 逻辑或","published":1,"updated":"2017-08-06T12:15:18.000Z","_id":"cj60bzxl3000x1dor3mgo5pn2","comments":1,"photos":[],"link":"","content":"<h2 id=\"逻辑与\"><a href=\"#逻辑与\" class=\"headerlink\" title=\"逻辑与\"></a>逻辑与</h2><p>逻辑与是<strong>短路操作</strong>，如果第一个<strong>操作数</strong>能够决定结果，那么将不会对接下来的<strong>操作数</strong>进行<strong>求值</strong>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">var a = 0,</div><div class=\"line\">    b = 1;</div><div class=\"line\"></div><div class=\"line\">a &amp;&amp; b++;</div><div class=\"line\"></div><div class=\"line\">console.log(a); // 0</div><div class=\"line\">console.log(b); // 1, b++没有执行</div></pre></td></tr></table></figure>\n<h3 id=\"表达式语句的值\"><a href=\"#表达式语句的值\" class=\"headerlink\" title=\"表达式语句的值\"></a>表达式语句的值</h3><p>如果操作数都是<code>True</code>（对象、非空字符串、非<code>0</code>或<code>NaN</code>的数字、布尔值<code>True</code>），则返回最后一个操作数。</p>\n<p>如果操作数中有若干个<code>False</code>（<code>Null</code>、<code>Undefined</code>、空字符串、<code>NaN</code>、布尔值<code>False</code>），则返回第一个<code>False</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;&#125; &amp;&amp; false ; // false</div><div class=\"line\">&#123;&#125; &amp;&amp; 0; // 0</div><div class=\"line\">&#123;&#125; &amp;&amp; null; // null</div><div class=\"line\">&#123;&#125; &amp;&amp; undefined; // undefined</div><div class=\"line\"></div><div class=\"line\">null &amp;&amp; 0; // null</div><div class=\"line\"></div><div class=\"line\">&#123;a:1&#125; &amp;&amp; &#123;b:1&#125; &amp;&amp; &#123;c:1&#125;; // &#123;c:1&#125;</div></pre></td></tr></table></figure>\n<p>与函数相结合</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">true &amp;&amp; foo(); // 执行foo</div><div class=\"line\">true &amp;&amp; false &amp;&amp; foo(); // 返回false，不执行foo</div></pre></td></tr></table></figure>\n<h2 id=\"逻辑或\"><a href=\"#逻辑或\" class=\"headerlink\" title=\"逻辑或\"></a>逻辑或</h2><p>逻辑或与逻辑与一样，也是<strong>短路操作</strong>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">var a = 0,</div><div class=\"line\">    b = 1;</div><div class=\"line\"></div><div class=\"line\">b || a++;</div><div class=\"line\"></div><div class=\"line\">console.log(a); // 0</div><div class=\"line\">console.log(b); // 1</div></pre></td></tr></table></figure>\n<h3 id=\"表达式语句的值-1\"><a href=\"#表达式语句的值-1\" class=\"headerlink\" title=\"表达式语句的值\"></a>表达式语句的值</h3><p>如果操作数都是False，则返回最后一个操作数。</p>\n<p>如果操作数中有若干个True，则返回第一个True。</p>\n<p>逻辑或一般用于避免给变量赋null或undefined值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">var foo = null;</div><div class=\"line\">    bar = 1;</div><div class=\"line\"></div><div class=\"line\">var value = foo || bar;</div></pre></td></tr></table></figure>\n<p>也可以用来在函数中对参数进行校验，下面三个函数等价，但是显然第一个是最优雅的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">function(v)&#123;</div><div class=\"line\">    var value = v || defaultValue;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">function(v)&#123;</div><div class=\"line\">    var value = !!v ? v : defaultValue;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">function(v)&#123;</div><div class=\"line\">    if(v)&#123;</div><div class=\"line\">        var value = v;</div><div class=\"line\">    &#125;else&#123;</div><div class=\"line\">        var value = defaultValue;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"逻辑与\"><a href=\"#逻辑与\" class=\"headerlink\" title=\"逻辑与\"></a>逻辑与</h2><p>逻辑与是<strong>短路操作</strong>，如果第一个<strong>操作数</strong>能够决定结果，那么将不会对接下来的<strong>操作数</strong>进行<strong>求值</strong>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">var a = 0,</div><div class=\"line\">    b = 1;</div><div class=\"line\"></div><div class=\"line\">a &amp;&amp; b++;</div><div class=\"line\"></div><div class=\"line\">console.log(a); // 0</div><div class=\"line\">console.log(b); // 1, b++没有执行</div></pre></td></tr></table></figure>\n<h3 id=\"表达式语句的值\"><a href=\"#表达式语句的值\" class=\"headerlink\" title=\"表达式语句的值\"></a>表达式语句的值</h3><p>如果操作数都是<code>True</code>（对象、非空字符串、非<code>0</code>或<code>NaN</code>的数字、布尔值<code>True</code>），则返回最后一个操作数。</p>\n<p>如果操作数中有若干个<code>False</code>（<code>Null</code>、<code>Undefined</code>、空字符串、<code>NaN</code>、布尔值<code>False</code>），则返回第一个<code>False</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;&#125; &amp;&amp; false ; // false</div><div class=\"line\">&#123;&#125; &amp;&amp; 0; // 0</div><div class=\"line\">&#123;&#125; &amp;&amp; null; // null</div><div class=\"line\">&#123;&#125; &amp;&amp; undefined; // undefined</div><div class=\"line\"></div><div class=\"line\">null &amp;&amp; 0; // null</div><div class=\"line\"></div><div class=\"line\">&#123;a:1&#125; &amp;&amp; &#123;b:1&#125; &amp;&amp; &#123;c:1&#125;; // &#123;c:1&#125;</div></pre></td></tr></table></figure>\n<p>与函数相结合</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">true &amp;&amp; foo(); // 执行foo</div><div class=\"line\">true &amp;&amp; false &amp;&amp; foo(); // 返回false，不执行foo</div></pre></td></tr></table></figure>\n<h2 id=\"逻辑或\"><a href=\"#逻辑或\" class=\"headerlink\" title=\"逻辑或\"></a>逻辑或</h2><p>逻辑或与逻辑与一样，也是<strong>短路操作</strong>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">var a = 0,</div><div class=\"line\">    b = 1;</div><div class=\"line\"></div><div class=\"line\">b || a++;</div><div class=\"line\"></div><div class=\"line\">console.log(a); // 0</div><div class=\"line\">console.log(b); // 1</div></pre></td></tr></table></figure>\n<h3 id=\"表达式语句的值-1\"><a href=\"#表达式语句的值-1\" class=\"headerlink\" title=\"表达式语句的值\"></a>表达式语句的值</h3><p>如果操作数都是False，则返回最后一个操作数。</p>\n<p>如果操作数中有若干个True，则返回第一个True。</p>\n<p>逻辑或一般用于避免给变量赋null或undefined值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">var foo = null;</div><div class=\"line\">    bar = 1;</div><div class=\"line\"></div><div class=\"line\">var value = foo || bar;</div></pre></td></tr></table></figure>\n<p>也可以用来在函数中对参数进行校验，下面三个函数等价，但是显然第一个是最优雅的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">function(v)&#123;</div><div class=\"line\">    var value = v || defaultValue;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">function(v)&#123;</div><div class=\"line\">    var value = !!v ? v : defaultValue;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">function(v)&#123;</div><div class=\"line\">    if(v)&#123;</div><div class=\"line\">        var value = v;</div><div class=\"line\">    &#125;else&#123;</div><div class=\"line\">        var value = defaultValue;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n"},{"layout":"post","title":"JSON：JSON 方法小记","date":"2017-05-19T12:00:00.000Z","_content":"\n## JSON.parse\\(\\)\n\n> JSON.parse\\( text\\[, reviver\\] \\)\n\n* text : 要被解析成 JavaScript 值的字符串\n\n* reviver : 规定原始值如何被解析改造的函数\n\n### reviver 函数\n\n解析值本身以及它所包含的值，从里向外调用去调用 `reviver` 函数。属性名和属性值会作为参数传入 `reviver` 中，如果 `reviver` 返回 `undefined` ，那么当前属性就会从对象中删除；如果返回其他值，返回值就会作为当前属性新的属性值。\n\n注意，遍历到顶层时，传入 `reviver` 函数的是空字符串和当前对象，即`{\"\" : 修改过的解析值 }`。这是个特例，需要特别注意。\n\n所以 `reviver` 函数有基本两种种用法：\n\n1、删除特定属性\n\n```\nvar str = '{\"a\":1, \"b\":2}';\n\n// 将属性值置为 undefined 删除属性\nvar json = JSON.parse(str,function(key, value){\n    return key == 'a' ? undefined : value;\n})\n\nconsole.log(json); // {b:2}\n```\n\n2、修改特定属性的值\n\n```\nvar str = '{\"a\":1, \"b\":2}';\n\nvar json = JSON.parse(str, function(key, value){\n    return key == 'a' ? value * 2 : value;\n})\n\nconsole.log(json); // {a:2, b:4}\n```\n\n## JSON.stringify\\(\\)\n\n> JSON.stringify value\\[, replacer\\[, space \\]\\] \\)\n\n* value : 要被转换成 JSON 字符串的值\n* replacer : 规定如何转换和处理值的属性\n* space : 指定缩进用的空白字符串\n\n### replacer 参数\n\n#### 传入函数\n\n返回 `undefined` 代表不输出该属性；输出其他（包括 `null` ）都会替代原来的属性值输出。\n\n```\nfunction replacer(key, value) {\n  if (typeof value === \"string\") {\n    return undefined;\n  }\n  return value;\n}\n\nvar foo = {foundation: \"Mozilla\", model: \"box\", week: 45, transport: \"car\", month: 7};\nvar jsonString = JSON.stringify(foo, replacer);\n\nconsole.log(jsonString); // {\"week\":45,\"month\":7}\n```\n\n#### 传入数组\n\n根据属性名指定哪些属性会被输出。\n\n```\nvar foo = {foundation: \"Mozilla\", model: \"box\", week: 45, transport: \"car\", month: 7};\nvar jsonString = JSON.stringify(foo, ['week','model']);\n\nconsole.log(jsonString); // {\"week\":45,\"model\":\"box\"}\n```\n\n#### 传入 `undefined` 或 `null`\n\n输出所有的属性。\n\n```\nvar foo = {foundation: \"Mozilla\", model: \"box\", week: 45, transport: \"car\", month: 7};\nvar jsonString = JSON.stringify(foo, null);\n\nconsole.log(jsonString); // {\"foundation\":\"Mozilla\",\"model\":\"box\",\"week\":45,\"transport\":\"car\",\"month\":7}\n```\n\n### space 参数\n\n指定缩进用的空白字符串，用于美化输出。\n\n如果参数是数字，就代表有多少空格，上限是10；\n\n如果参数是字符串，则为该字符串的前10个字母；\n\n如果参数没有提供，就意味着没有空格。\n\n除此之外，也可以传入转义字符（ `\\t` ）来用 tab 进行缩进。\n\n## 参考\n\n[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global\\_Objects/JSON/parse](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse)\n\n[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global\\_Objects/JSON/stringify](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify)\n\n","source":"_posts/2017-05-19-JSON：JSON 方法小记.md","raw":"---\nlayout: post\ntitle:  \"JSON：JSON 方法小记\"\ndate:   2017-05-19 20:00:00 +0800\ncategories: javascript\n---\n\n## JSON.parse\\(\\)\n\n> JSON.parse\\( text\\[, reviver\\] \\)\n\n* text : 要被解析成 JavaScript 值的字符串\n\n* reviver : 规定原始值如何被解析改造的函数\n\n### reviver 函数\n\n解析值本身以及它所包含的值，从里向外调用去调用 `reviver` 函数。属性名和属性值会作为参数传入 `reviver` 中，如果 `reviver` 返回 `undefined` ，那么当前属性就会从对象中删除；如果返回其他值，返回值就会作为当前属性新的属性值。\n\n注意，遍历到顶层时，传入 `reviver` 函数的是空字符串和当前对象，即`{\"\" : 修改过的解析值 }`。这是个特例，需要特别注意。\n\n所以 `reviver` 函数有基本两种种用法：\n\n1、删除特定属性\n\n```\nvar str = '{\"a\":1, \"b\":2}';\n\n// 将属性值置为 undefined 删除属性\nvar json = JSON.parse(str,function(key, value){\n    return key == 'a' ? undefined : value;\n})\n\nconsole.log(json); // {b:2}\n```\n\n2、修改特定属性的值\n\n```\nvar str = '{\"a\":1, \"b\":2}';\n\nvar json = JSON.parse(str, function(key, value){\n    return key == 'a' ? value * 2 : value;\n})\n\nconsole.log(json); // {a:2, b:4}\n```\n\n## JSON.stringify\\(\\)\n\n> JSON.stringify value\\[, replacer\\[, space \\]\\] \\)\n\n* value : 要被转换成 JSON 字符串的值\n* replacer : 规定如何转换和处理值的属性\n* space : 指定缩进用的空白字符串\n\n### replacer 参数\n\n#### 传入函数\n\n返回 `undefined` 代表不输出该属性；输出其他（包括 `null` ）都会替代原来的属性值输出。\n\n```\nfunction replacer(key, value) {\n  if (typeof value === \"string\") {\n    return undefined;\n  }\n  return value;\n}\n\nvar foo = {foundation: \"Mozilla\", model: \"box\", week: 45, transport: \"car\", month: 7};\nvar jsonString = JSON.stringify(foo, replacer);\n\nconsole.log(jsonString); // {\"week\":45,\"month\":7}\n```\n\n#### 传入数组\n\n根据属性名指定哪些属性会被输出。\n\n```\nvar foo = {foundation: \"Mozilla\", model: \"box\", week: 45, transport: \"car\", month: 7};\nvar jsonString = JSON.stringify(foo, ['week','model']);\n\nconsole.log(jsonString); // {\"week\":45,\"model\":\"box\"}\n```\n\n#### 传入 `undefined` 或 `null`\n\n输出所有的属性。\n\n```\nvar foo = {foundation: \"Mozilla\", model: \"box\", week: 45, transport: \"car\", month: 7};\nvar jsonString = JSON.stringify(foo, null);\n\nconsole.log(jsonString); // {\"foundation\":\"Mozilla\",\"model\":\"box\",\"week\":45,\"transport\":\"car\",\"month\":7}\n```\n\n### space 参数\n\n指定缩进用的空白字符串，用于美化输出。\n\n如果参数是数字，就代表有多少空格，上限是10；\n\n如果参数是字符串，则为该字符串的前10个字母；\n\n如果参数没有提供，就意味着没有空格。\n\n除此之外，也可以传入转义字符（ `\\t` ）来用 tab 进行缩进。\n\n## 参考\n\n[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global\\_Objects/JSON/parse](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse)\n\n[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global\\_Objects/JSON/stringify](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify)\n\n","slug":"2017-05-19-JSON：JSON 方法小记","published":1,"updated":"2017-07-31T16:42:14.000Z","comments":1,"photos":[],"link":"","_id":"cj60bzxl4000z1dorjqifgpap","content":"<h2 id=\"JSON-parse\"><a href=\"#JSON-parse\" class=\"headerlink\" title=\"JSON.parse()\"></a>JSON.parse()</h2><blockquote>\n<p>JSON.parse( text[, reviver] )</p>\n</blockquote>\n<ul>\n<li><p>text : 要被解析成 JavaScript 值的字符串</p>\n</li>\n<li><p>reviver : 规定原始值如何被解析改造的函数</p>\n</li>\n</ul>\n<h3 id=\"reviver-函数\"><a href=\"#reviver-函数\" class=\"headerlink\" title=\"reviver 函数\"></a>reviver 函数</h3><p>解析值本身以及它所包含的值，从里向外调用去调用 <code>reviver</code> 函数。属性名和属性值会作为参数传入 <code>reviver</code> 中，如果 <code>reviver</code> 返回 <code>undefined</code> ，那么当前属性就会从对象中删除；如果返回其他值，返回值就会作为当前属性新的属性值。</p>\n<p>注意，遍历到顶层时，传入 <code>reviver</code> 函数的是空字符串和当前对象，即<code>{&quot;&quot; : 修改过的解析值 }</code>。这是个特例，需要特别注意。</p>\n<p>所以 <code>reviver</code> 函数有基本两种种用法：</p>\n<p>1、删除特定属性</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">var str = &apos;&#123;&quot;a&quot;:1, &quot;b&quot;:2&#125;&apos;;</div><div class=\"line\"></div><div class=\"line\">// 将属性值置为 undefined 删除属性</div><div class=\"line\">var json = JSON.parse(str,function(key, value)&#123;</div><div class=\"line\">    return key == &apos;a&apos; ? undefined : value;</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">console.log(json); // &#123;b:2&#125;</div></pre></td></tr></table></figure>\n<p>2、修改特定属性的值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">var str = &apos;&#123;&quot;a&quot;:1, &quot;b&quot;:2&#125;&apos;;</div><div class=\"line\"></div><div class=\"line\">var json = JSON.parse(str, function(key, value)&#123;</div><div class=\"line\">    return key == &apos;a&apos; ? value * 2 : value;</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">console.log(json); // &#123;a:2, b:4&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"JSON-stringify\"><a href=\"#JSON-stringify\" class=\"headerlink\" title=\"JSON.stringify()\"></a>JSON.stringify()</h2><blockquote>\n<p>JSON.stringify value[, replacer[, space ]] )</p>\n</blockquote>\n<ul>\n<li>value : 要被转换成 JSON 字符串的值</li>\n<li>replacer : 规定如何转换和处理值的属性</li>\n<li>space : 指定缩进用的空白字符串</li>\n</ul>\n<h3 id=\"replacer-参数\"><a href=\"#replacer-参数\" class=\"headerlink\" title=\"replacer 参数\"></a>replacer 参数</h3><h4 id=\"传入函数\"><a href=\"#传入函数\" class=\"headerlink\" title=\"传入函数\"></a>传入函数</h4><p>返回 <code>undefined</code> 代表不输出该属性；输出其他（包括 <code>null</code> ）都会替代原来的属性值输出。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">function replacer(key, value) &#123;</div><div class=\"line\">  if (typeof value === &quot;string&quot;) &#123;</div><div class=\"line\">    return undefined;</div><div class=\"line\">  &#125;</div><div class=\"line\">  return value;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var foo = &#123;foundation: &quot;Mozilla&quot;, model: &quot;box&quot;, week: 45, transport: &quot;car&quot;, month: 7&#125;;</div><div class=\"line\">var jsonString = JSON.stringify(foo, replacer);</div><div class=\"line\"></div><div class=\"line\">console.log(jsonString); // &#123;&quot;week&quot;:45,&quot;month&quot;:7&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"传入数组\"><a href=\"#传入数组\" class=\"headerlink\" title=\"传入数组\"></a>传入数组</h4><p>根据属性名指定哪些属性会被输出。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">var foo = &#123;foundation: &quot;Mozilla&quot;, model: &quot;box&quot;, week: 45, transport: &quot;car&quot;, month: 7&#125;;</div><div class=\"line\">var jsonString = JSON.stringify(foo, [&apos;week&apos;,&apos;model&apos;]);</div><div class=\"line\"></div><div class=\"line\">console.log(jsonString); // &#123;&quot;week&quot;:45,&quot;model&quot;:&quot;box&quot;&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"传入-undefined-或-null\"><a href=\"#传入-undefined-或-null\" class=\"headerlink\" title=\"传入 undefined 或 null\"></a>传入 <code>undefined</code> 或 <code>null</code></h4><p>输出所有的属性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">var foo = &#123;foundation: &quot;Mozilla&quot;, model: &quot;box&quot;, week: 45, transport: &quot;car&quot;, month: 7&#125;;</div><div class=\"line\">var jsonString = JSON.stringify(foo, null);</div><div class=\"line\"></div><div class=\"line\">console.log(jsonString); // &#123;&quot;foundation&quot;:&quot;Mozilla&quot;,&quot;model&quot;:&quot;box&quot;,&quot;week&quot;:45,&quot;transport&quot;:&quot;car&quot;,&quot;month&quot;:7&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"space-参数\"><a href=\"#space-参数\" class=\"headerlink\" title=\"space 参数\"></a>space 参数</h3><p>指定缩进用的空白字符串，用于美化输出。</p>\n<p>如果参数是数字，就代表有多少空格，上限是10；</p>\n<p>如果参数是字符串，则为该字符串的前10个字母；</p>\n<p>如果参数没有提供，就意味着没有空格。</p>\n<p>除此之外，也可以传入转义字符（ <code>\\t</code> ）来用 tab 进行缩进。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse\" target=\"_blank\" rel=\"external\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse</a></p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify\" target=\"_blank\" rel=\"external\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"JSON-parse\"><a href=\"#JSON-parse\" class=\"headerlink\" title=\"JSON.parse()\"></a>JSON.parse()</h2><blockquote>\n<p>JSON.parse( text[, reviver] )</p>\n</blockquote>\n<ul>\n<li><p>text : 要被解析成 JavaScript 值的字符串</p>\n</li>\n<li><p>reviver : 规定原始值如何被解析改造的函数</p>\n</li>\n</ul>\n<h3 id=\"reviver-函数\"><a href=\"#reviver-函数\" class=\"headerlink\" title=\"reviver 函数\"></a>reviver 函数</h3><p>解析值本身以及它所包含的值，从里向外调用去调用 <code>reviver</code> 函数。属性名和属性值会作为参数传入 <code>reviver</code> 中，如果 <code>reviver</code> 返回 <code>undefined</code> ，那么当前属性就会从对象中删除；如果返回其他值，返回值就会作为当前属性新的属性值。</p>\n<p>注意，遍历到顶层时，传入 <code>reviver</code> 函数的是空字符串和当前对象，即<code>{&quot;&quot; : 修改过的解析值 }</code>。这是个特例，需要特别注意。</p>\n<p>所以 <code>reviver</code> 函数有基本两种种用法：</p>\n<p>1、删除特定属性</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">var str = &apos;&#123;&quot;a&quot;:1, &quot;b&quot;:2&#125;&apos;;</div><div class=\"line\"></div><div class=\"line\">// 将属性值置为 undefined 删除属性</div><div class=\"line\">var json = JSON.parse(str,function(key, value)&#123;</div><div class=\"line\">    return key == &apos;a&apos; ? undefined : value;</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">console.log(json); // &#123;b:2&#125;</div></pre></td></tr></table></figure>\n<p>2、修改特定属性的值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">var str = &apos;&#123;&quot;a&quot;:1, &quot;b&quot;:2&#125;&apos;;</div><div class=\"line\"></div><div class=\"line\">var json = JSON.parse(str, function(key, value)&#123;</div><div class=\"line\">    return key == &apos;a&apos; ? value * 2 : value;</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">console.log(json); // &#123;a:2, b:4&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"JSON-stringify\"><a href=\"#JSON-stringify\" class=\"headerlink\" title=\"JSON.stringify()\"></a>JSON.stringify()</h2><blockquote>\n<p>JSON.stringify value[, replacer[, space ]] )</p>\n</blockquote>\n<ul>\n<li>value : 要被转换成 JSON 字符串的值</li>\n<li>replacer : 规定如何转换和处理值的属性</li>\n<li>space : 指定缩进用的空白字符串</li>\n</ul>\n<h3 id=\"replacer-参数\"><a href=\"#replacer-参数\" class=\"headerlink\" title=\"replacer 参数\"></a>replacer 参数</h3><h4 id=\"传入函数\"><a href=\"#传入函数\" class=\"headerlink\" title=\"传入函数\"></a>传入函数</h4><p>返回 <code>undefined</code> 代表不输出该属性；输出其他（包括 <code>null</code> ）都会替代原来的属性值输出。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">function replacer(key, value) &#123;</div><div class=\"line\">  if (typeof value === &quot;string&quot;) &#123;</div><div class=\"line\">    return undefined;</div><div class=\"line\">  &#125;</div><div class=\"line\">  return value;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var foo = &#123;foundation: &quot;Mozilla&quot;, model: &quot;box&quot;, week: 45, transport: &quot;car&quot;, month: 7&#125;;</div><div class=\"line\">var jsonString = JSON.stringify(foo, replacer);</div><div class=\"line\"></div><div class=\"line\">console.log(jsonString); // &#123;&quot;week&quot;:45,&quot;month&quot;:7&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"传入数组\"><a href=\"#传入数组\" class=\"headerlink\" title=\"传入数组\"></a>传入数组</h4><p>根据属性名指定哪些属性会被输出。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">var foo = &#123;foundation: &quot;Mozilla&quot;, model: &quot;box&quot;, week: 45, transport: &quot;car&quot;, month: 7&#125;;</div><div class=\"line\">var jsonString = JSON.stringify(foo, [&apos;week&apos;,&apos;model&apos;]);</div><div class=\"line\"></div><div class=\"line\">console.log(jsonString); // &#123;&quot;week&quot;:45,&quot;model&quot;:&quot;box&quot;&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"传入-undefined-或-null\"><a href=\"#传入-undefined-或-null\" class=\"headerlink\" title=\"传入 undefined 或 null\"></a>传入 <code>undefined</code> 或 <code>null</code></h4><p>输出所有的属性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">var foo = &#123;foundation: &quot;Mozilla&quot;, model: &quot;box&quot;, week: 45, transport: &quot;car&quot;, month: 7&#125;;</div><div class=\"line\">var jsonString = JSON.stringify(foo, null);</div><div class=\"line\"></div><div class=\"line\">console.log(jsonString); // &#123;&quot;foundation&quot;:&quot;Mozilla&quot;,&quot;model&quot;:&quot;box&quot;,&quot;week&quot;:45,&quot;transport&quot;:&quot;car&quot;,&quot;month&quot;:7&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"space-参数\"><a href=\"#space-参数\" class=\"headerlink\" title=\"space 参数\"></a>space 参数</h3><p>指定缩进用的空白字符串，用于美化输出。</p>\n<p>如果参数是数字，就代表有多少空格，上限是10；</p>\n<p>如果参数是字符串，则为该字符串的前10个字母；</p>\n<p>如果参数没有提供，就意味着没有空格。</p>\n<p>除此之外，也可以传入转义字符（ <code>\\t</code> ）来用 tab 进行缩进。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse\" target=\"_blank\" rel=\"external\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse</a></p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify\" target=\"_blank\" rel=\"external\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify</a></p>\n"},{"layout":"post","title":"什么是Hybrid App","date":"2017-05-23T07:30:00.000Z","_content":"## 什么是Hybrid\n\n### Hybrid 出现的历史原因\n\n* 2013年起移动互联网的兴起导致App开发的需求日益高涨。\n* 2014年 H5 的发布，使得 Web 能够实现更多功能。\n* 在产品需要快速迭代、抢占市场的大背景下，开发 iOS 和 Android 原生应用的时间成本和劳动成本都非常高。\n* 随着 iOS 和 Android 两大阵营对 H5 的支持日益完善，H5 足以实现大多数的需求。\n* 为了利用 Web 应用低成本、高效率、跨成本等诸多优点，出现了使用 Web 和 Native 混合进行开发的模式。\n\n### Hybrid 的分类\n\nApp 应用从实现机制上来区分，主要分为三类：\n\n1. Native 应用：使用原生语言的应用，能够调用所有底层接口，交互体验最好。\n2. Web App 应用：使用纯 Web 开发的应用，通过浏览器访问，交互体验最差。\n3. Hybrid 应用：\n   1. 以 WebView 作为用户界面层，以 JavaScript 为基本逻辑通过与中间件通讯、访问底层 API ，进行应用开发。\n   2. 使用非官方语言的工具，打包成原生应用的方式开发。\n   3. 基于原生应用的架构，在部分功能中嵌入 WebView 。WebView 负责对界面的渲染，同时也可以访问底层的 API 以实现特定的功能。\n   4. 通过 JavaScript 引擎管理和渲染 native 视图，将 JavaScript 代码渲染成原生组件，调用原生 API 与用户进行交互。（ReactNative、Weex）\n\n### Hybrid 的优势\n\n* 开发效率高\n* 开发成本低\n* 跨平台\n* 快速迭代，无需发布版本即可修复Bug\n\n总结来说，Hybrid 是既保持了对原生API的完整掌控，同时可以在特定功能下节省跨平台开发成本、提升效率。\n\n### Hybrid 的劣势\n\n* 容易造成性能问题，不适用于依赖原生 API 、动画较多和游戏开发的需求。\n* 永远保持最新（直接访问线上，而不是使用 App 本地的静态资源）带来的低版本机型的适配问题，包括调用底层 API 和对 H5 的支持方面。（即不太好做版本控制）\n* 需要实现 Native 与 H5 之间的通信机制\n* 交互体验不如原生页面，需要尽可能仿制原生应用的体验\n\n总结来说，Web 只能替代、辅助一部分功能，无法取代原生开发的主导地位。\n\n## Hybrid 实现\n\n### Native 与前端之间的关系\n\nHybrid App 底层依赖于 Native 提供的容器，上层使用 H5 做业务开发，底层透明化、上层多样化，适合前端介入进行快速迭代开发。\n\nNative 提供的实际上是类似于浏览器的宿主环境，H5 页面可以利用宿主环境提供的“能力”来进行开发。正如一般浏览器为 JavaScript 提供了 window 对象以控制浏览器一样，Native 也可以为 H5 页面提供特定的接口以调用底层的 API。\n\n### Hybrid 交互设计\n\nNative 可以调用前端页面的 JavaScript 方法对视图进行操作，前端页面也可以通过 JavaScript 方法调用 Native 提供的接口实现系统层面的功能。两者沟通的桥梁则是 WebView。\n\n### ![](/images/FE-Hybrid-interaction.png)Schema\n\nApp 自身可以自定义 URL Schema，并且把自定义的 URL 注册在调度中心。App 安装后会在手机上注册一个 Schema，例如淘宝是 taobao:// ，Native 会有一个进程监控 WebView 发出的所有 schema:// 请求，从而打开 Native 应用并传入参数执行特定的行为。\n\n通过 Schema ，H5 可以通过发起 schema 请求，来实现 H5 与 Native 页面之间的跳转。\n\n### 常用交互 API\n\n* 跳转\n  * 页面内部跳转\n  * H5 跳转 Native 界面，Native 通过截获 URL 参数跳转到响应页面。\n  * H5 新打开一个 WebView。\n* Header 组件\n  * 避免白屏陷入假死状态\n  * Header 左侧和右侧按钮可配置，中间 title 部分可配置\n* 请求类\n  * 通过 Native 代理发起 AJAX 请求，解决跨域问题\n* Native UI 组件\n  * Loading 组件\n  * Toast 组件\n\n## 参考\n\n[http://www.cnblogs.com/yexiaochai/p/4921635.html](http://www.cnblogs.com/yexiaochai/p/4921635.html)\n\n[http://ued.ctrip.com/blog/translation-hybrid-mobile-application-provide-native-web-technology-experience.html](http://ued.ctrip.com/blog/translation-hybrid-mobile-application-provide-native-web-technology-experience.html)\n\n[https://dailc.github.io/2016/10/04/hybridBase01HybridInfo.html](https://dailc.github.io/2016/10/04/hybridBase01HybridInfo.html)\n\n[https://dailc.github.io/2016/10/04/hybridBase02HybridCompareOthers.html](https://dailc.github.io/2016/10/04/hybridBase02HybridCompareOthers.html)\n\n[https://weex.apache.org/cn/](https://weex.apache.org/cn/)\n\n[http://www.infoq.com/cn/articles/hybrid-app-development-combat\\#note-bottom-anchor](http://www.infoq.com/cn/articles/hybrid-app-development-combat#note-bottom-anchor)\n\n[http://www.jianshu.com/p/e83aa2d1ade3](http://www.jianshu.com/p/e83aa2d1ade3)\n\n","source":"_posts/2017-05-23-什么是Hybrid App.markdown","raw":"---\nlayout: post\ntitle:  \"什么是Hybrid App\"\ndate:   2017-05-23 15:30:00 +0800\ntags: fe\n---\n## 什么是Hybrid\n\n### Hybrid 出现的历史原因\n\n* 2013年起移动互联网的兴起导致App开发的需求日益高涨。\n* 2014年 H5 的发布，使得 Web 能够实现更多功能。\n* 在产品需要快速迭代、抢占市场的大背景下，开发 iOS 和 Android 原生应用的时间成本和劳动成本都非常高。\n* 随着 iOS 和 Android 两大阵营对 H5 的支持日益完善，H5 足以实现大多数的需求。\n* 为了利用 Web 应用低成本、高效率、跨成本等诸多优点，出现了使用 Web 和 Native 混合进行开发的模式。\n\n### Hybrid 的分类\n\nApp 应用从实现机制上来区分，主要分为三类：\n\n1. Native 应用：使用原生语言的应用，能够调用所有底层接口，交互体验最好。\n2. Web App 应用：使用纯 Web 开发的应用，通过浏览器访问，交互体验最差。\n3. Hybrid 应用：\n   1. 以 WebView 作为用户界面层，以 JavaScript 为基本逻辑通过与中间件通讯、访问底层 API ，进行应用开发。\n   2. 使用非官方语言的工具，打包成原生应用的方式开发。\n   3. 基于原生应用的架构，在部分功能中嵌入 WebView 。WebView 负责对界面的渲染，同时也可以访问底层的 API 以实现特定的功能。\n   4. 通过 JavaScript 引擎管理和渲染 native 视图，将 JavaScript 代码渲染成原生组件，调用原生 API 与用户进行交互。（ReactNative、Weex）\n\n### Hybrid 的优势\n\n* 开发效率高\n* 开发成本低\n* 跨平台\n* 快速迭代，无需发布版本即可修复Bug\n\n总结来说，Hybrid 是既保持了对原生API的完整掌控，同时可以在特定功能下节省跨平台开发成本、提升效率。\n\n### Hybrid 的劣势\n\n* 容易造成性能问题，不适用于依赖原生 API 、动画较多和游戏开发的需求。\n* 永远保持最新（直接访问线上，而不是使用 App 本地的静态资源）带来的低版本机型的适配问题，包括调用底层 API 和对 H5 的支持方面。（即不太好做版本控制）\n* 需要实现 Native 与 H5 之间的通信机制\n* 交互体验不如原生页面，需要尽可能仿制原生应用的体验\n\n总结来说，Web 只能替代、辅助一部分功能，无法取代原生开发的主导地位。\n\n## Hybrid 实现\n\n### Native 与前端之间的关系\n\nHybrid App 底层依赖于 Native 提供的容器，上层使用 H5 做业务开发，底层透明化、上层多样化，适合前端介入进行快速迭代开发。\n\nNative 提供的实际上是类似于浏览器的宿主环境，H5 页面可以利用宿主环境提供的“能力”来进行开发。正如一般浏览器为 JavaScript 提供了 window 对象以控制浏览器一样，Native 也可以为 H5 页面提供特定的接口以调用底层的 API。\n\n### Hybrid 交互设计\n\nNative 可以调用前端页面的 JavaScript 方法对视图进行操作，前端页面也可以通过 JavaScript 方法调用 Native 提供的接口实现系统层面的功能。两者沟通的桥梁则是 WebView。\n\n### ![](/images/FE-Hybrid-interaction.png)Schema\n\nApp 自身可以自定义 URL Schema，并且把自定义的 URL 注册在调度中心。App 安装后会在手机上注册一个 Schema，例如淘宝是 taobao:// ，Native 会有一个进程监控 WebView 发出的所有 schema:// 请求，从而打开 Native 应用并传入参数执行特定的行为。\n\n通过 Schema ，H5 可以通过发起 schema 请求，来实现 H5 与 Native 页面之间的跳转。\n\n### 常用交互 API\n\n* 跳转\n  * 页面内部跳转\n  * H5 跳转 Native 界面，Native 通过截获 URL 参数跳转到响应页面。\n  * H5 新打开一个 WebView。\n* Header 组件\n  * 避免白屏陷入假死状态\n  * Header 左侧和右侧按钮可配置，中间 title 部分可配置\n* 请求类\n  * 通过 Native 代理发起 AJAX 请求，解决跨域问题\n* Native UI 组件\n  * Loading 组件\n  * Toast 组件\n\n## 参考\n\n[http://www.cnblogs.com/yexiaochai/p/4921635.html](http://www.cnblogs.com/yexiaochai/p/4921635.html)\n\n[http://ued.ctrip.com/blog/translation-hybrid-mobile-application-provide-native-web-technology-experience.html](http://ued.ctrip.com/blog/translation-hybrid-mobile-application-provide-native-web-technology-experience.html)\n\n[https://dailc.github.io/2016/10/04/hybridBase01HybridInfo.html](https://dailc.github.io/2016/10/04/hybridBase01HybridInfo.html)\n\n[https://dailc.github.io/2016/10/04/hybridBase02HybridCompareOthers.html](https://dailc.github.io/2016/10/04/hybridBase02HybridCompareOthers.html)\n\n[https://weex.apache.org/cn/](https://weex.apache.org/cn/)\n\n[http://www.infoq.com/cn/articles/hybrid-app-development-combat\\#note-bottom-anchor](http://www.infoq.com/cn/articles/hybrid-app-development-combat#note-bottom-anchor)\n\n[http://www.jianshu.com/p/e83aa2d1ade3](http://www.jianshu.com/p/e83aa2d1ade3)\n\n","slug":"2017-05-23-什么是Hybrid App","published":1,"updated":"2017-08-06T12:15:31.000Z","_id":"cj60bzxl500111dor7opnoi2v","comments":1,"photos":[],"link":"","content":"<h2 id=\"什么是Hybrid\"><a href=\"#什么是Hybrid\" class=\"headerlink\" title=\"什么是Hybrid\"></a>什么是Hybrid</h2><h3 id=\"Hybrid-出现的历史原因\"><a href=\"#Hybrid-出现的历史原因\" class=\"headerlink\" title=\"Hybrid 出现的历史原因\"></a>Hybrid 出现的历史原因</h3><ul>\n<li>2013年起移动互联网的兴起导致App开发的需求日益高涨。</li>\n<li>2014年 H5 的发布，使得 Web 能够实现更多功能。</li>\n<li>在产品需要快速迭代、抢占市场的大背景下，开发 iOS 和 Android 原生应用的时间成本和劳动成本都非常高。</li>\n<li>随着 iOS 和 Android 两大阵营对 H5 的支持日益完善，H5 足以实现大多数的需求。</li>\n<li>为了利用 Web 应用低成本、高效率、跨成本等诸多优点，出现了使用 Web 和 Native 混合进行开发的模式。</li>\n</ul>\n<h3 id=\"Hybrid-的分类\"><a href=\"#Hybrid-的分类\" class=\"headerlink\" title=\"Hybrid 的分类\"></a>Hybrid 的分类</h3><p>App 应用从实现机制上来区分，主要分为三类：</p>\n<ol>\n<li>Native 应用：使用原生语言的应用，能够调用所有底层接口，交互体验最好。</li>\n<li>Web App 应用：使用纯 Web 开发的应用，通过浏览器访问，交互体验最差。</li>\n<li>Hybrid 应用：<ol>\n<li>以 WebView 作为用户界面层，以 JavaScript 为基本逻辑通过与中间件通讯、访问底层 API ，进行应用开发。</li>\n<li>使用非官方语言的工具，打包成原生应用的方式开发。</li>\n<li>基于原生应用的架构，在部分功能中嵌入 WebView 。WebView 负责对界面的渲染，同时也可以访问底层的 API 以实现特定的功能。</li>\n<li>通过 JavaScript 引擎管理和渲染 native 视图，将 JavaScript 代码渲染成原生组件，调用原生 API 与用户进行交互。（ReactNative、Weex）</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"Hybrid-的优势\"><a href=\"#Hybrid-的优势\" class=\"headerlink\" title=\"Hybrid 的优势\"></a>Hybrid 的优势</h3><ul>\n<li>开发效率高</li>\n<li>开发成本低</li>\n<li>跨平台</li>\n<li>快速迭代，无需发布版本即可修复Bug</li>\n</ul>\n<p>总结来说，Hybrid 是既保持了对原生API的完整掌控，同时可以在特定功能下节省跨平台开发成本、提升效率。</p>\n<h3 id=\"Hybrid-的劣势\"><a href=\"#Hybrid-的劣势\" class=\"headerlink\" title=\"Hybrid 的劣势\"></a>Hybrid 的劣势</h3><ul>\n<li>容易造成性能问题，不适用于依赖原生 API 、动画较多和游戏开发的需求。</li>\n<li>永远保持最新（直接访问线上，而不是使用 App 本地的静态资源）带来的低版本机型的适配问题，包括调用底层 API 和对 H5 的支持方面。（即不太好做版本控制）</li>\n<li>需要实现 Native 与 H5 之间的通信机制</li>\n<li>交互体验不如原生页面，需要尽可能仿制原生应用的体验</li>\n</ul>\n<p>总结来说，Web 只能替代、辅助一部分功能，无法取代原生开发的主导地位。</p>\n<h2 id=\"Hybrid-实现\"><a href=\"#Hybrid-实现\" class=\"headerlink\" title=\"Hybrid 实现\"></a>Hybrid 实现</h2><h3 id=\"Native-与前端之间的关系\"><a href=\"#Native-与前端之间的关系\" class=\"headerlink\" title=\"Native 与前端之间的关系\"></a>Native 与前端之间的关系</h3><p>Hybrid App 底层依赖于 Native 提供的容器，上层使用 H5 做业务开发，底层透明化、上层多样化，适合前端介入进行快速迭代开发。</p>\n<p>Native 提供的实际上是类似于浏览器的宿主环境，H5 页面可以利用宿主环境提供的“能力”来进行开发。正如一般浏览器为 JavaScript 提供了 window 对象以控制浏览器一样，Native 也可以为 H5 页面提供特定的接口以调用底层的 API。</p>\n<h3 id=\"Hybrid-交互设计\"><a href=\"#Hybrid-交互设计\" class=\"headerlink\" title=\"Hybrid 交互设计\"></a>Hybrid 交互设计</h3><p>Native 可以调用前端页面的 JavaScript 方法对视图进行操作，前端页面也可以通过 JavaScript 方法调用 Native 提供的接口实现系统层面的功能。两者沟通的桥梁则是 WebView。</p>\n<h3 id=\"Schema\"><a href=\"#Schema\" class=\"headerlink\" title=\"Schema\"></a><img src=\"/images/FE-Hybrid-interaction.png\" alt=\"\">Schema</h3><p>App 自身可以自定义 URL Schema，并且把自定义的 URL 注册在调度中心。App 安装后会在手机上注册一个 Schema，例如淘宝是 taobao:// ，Native 会有一个进程监控 WebView 发出的所有 schema:// 请求，从而打开 Native 应用并传入参数执行特定的行为。</p>\n<p>通过 Schema ，H5 可以通过发起 schema 请求，来实现 H5 与 Native 页面之间的跳转。</p>\n<h3 id=\"常用交互-API\"><a href=\"#常用交互-API\" class=\"headerlink\" title=\"常用交互 API\"></a>常用交互 API</h3><ul>\n<li>跳转<ul>\n<li>页面内部跳转</li>\n<li>H5 跳转 Native 界面，Native 通过截获 URL 参数跳转到响应页面。</li>\n<li>H5 新打开一个 WebView。</li>\n</ul>\n</li>\n<li>Header 组件<ul>\n<li>避免白屏陷入假死状态</li>\n<li>Header 左侧和右侧按钮可配置，中间 title 部分可配置</li>\n</ul>\n</li>\n<li>请求类<ul>\n<li>通过 Native 代理发起 AJAX 请求，解决跨域问题</li>\n</ul>\n</li>\n<li>Native UI 组件<ul>\n<li>Loading 组件</li>\n<li>Toast 组件</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://www.cnblogs.com/yexiaochai/p/4921635.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/yexiaochai/p/4921635.html</a></p>\n<p><a href=\"http://ued.ctrip.com/blog/translation-hybrid-mobile-application-provide-native-web-technology-experience.html\" target=\"_blank\" rel=\"external\">http://ued.ctrip.com/blog/translation-hybrid-mobile-application-provide-native-web-technology-experience.html</a></p>\n<p><a href=\"https://dailc.github.io/2016/10/04/hybridBase01HybridInfo.html\" target=\"_blank\" rel=\"external\">https://dailc.github.io/2016/10/04/hybridBase01HybridInfo.html</a></p>\n<p><a href=\"https://dailc.github.io/2016/10/04/hybridBase02HybridCompareOthers.html\" target=\"_blank\" rel=\"external\">https://dailc.github.io/2016/10/04/hybridBase02HybridCompareOthers.html</a></p>\n<p><a href=\"https://weex.apache.org/cn/\" target=\"_blank\" rel=\"external\">https://weex.apache.org/cn/</a></p>\n<p><a href=\"http://www.infoq.com/cn/articles/hybrid-app-development-combat#note-bottom-anchor\" target=\"_blank\" rel=\"external\">http://www.infoq.com/cn/articles/hybrid-app-development-combat#note-bottom-anchor</a></p>\n<p><a href=\"http://www.jianshu.com/p/e83aa2d1ade3\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/e83aa2d1ade3</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"什么是Hybrid\"><a href=\"#什么是Hybrid\" class=\"headerlink\" title=\"什么是Hybrid\"></a>什么是Hybrid</h2><h3 id=\"Hybrid-出现的历史原因\"><a href=\"#Hybrid-出现的历史原因\" class=\"headerlink\" title=\"Hybrid 出现的历史原因\"></a>Hybrid 出现的历史原因</h3><ul>\n<li>2013年起移动互联网的兴起导致App开发的需求日益高涨。</li>\n<li>2014年 H5 的发布，使得 Web 能够实现更多功能。</li>\n<li>在产品需要快速迭代、抢占市场的大背景下，开发 iOS 和 Android 原生应用的时间成本和劳动成本都非常高。</li>\n<li>随着 iOS 和 Android 两大阵营对 H5 的支持日益完善，H5 足以实现大多数的需求。</li>\n<li>为了利用 Web 应用低成本、高效率、跨成本等诸多优点，出现了使用 Web 和 Native 混合进行开发的模式。</li>\n</ul>\n<h3 id=\"Hybrid-的分类\"><a href=\"#Hybrid-的分类\" class=\"headerlink\" title=\"Hybrid 的分类\"></a>Hybrid 的分类</h3><p>App 应用从实现机制上来区分，主要分为三类：</p>\n<ol>\n<li>Native 应用：使用原生语言的应用，能够调用所有底层接口，交互体验最好。</li>\n<li>Web App 应用：使用纯 Web 开发的应用，通过浏览器访问，交互体验最差。</li>\n<li>Hybrid 应用：<ol>\n<li>以 WebView 作为用户界面层，以 JavaScript 为基本逻辑通过与中间件通讯、访问底层 API ，进行应用开发。</li>\n<li>使用非官方语言的工具，打包成原生应用的方式开发。</li>\n<li>基于原生应用的架构，在部分功能中嵌入 WebView 。WebView 负责对界面的渲染，同时也可以访问底层的 API 以实现特定的功能。</li>\n<li>通过 JavaScript 引擎管理和渲染 native 视图，将 JavaScript 代码渲染成原生组件，调用原生 API 与用户进行交互。（ReactNative、Weex）</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"Hybrid-的优势\"><a href=\"#Hybrid-的优势\" class=\"headerlink\" title=\"Hybrid 的优势\"></a>Hybrid 的优势</h3><ul>\n<li>开发效率高</li>\n<li>开发成本低</li>\n<li>跨平台</li>\n<li>快速迭代，无需发布版本即可修复Bug</li>\n</ul>\n<p>总结来说，Hybrid 是既保持了对原生API的完整掌控，同时可以在特定功能下节省跨平台开发成本、提升效率。</p>\n<h3 id=\"Hybrid-的劣势\"><a href=\"#Hybrid-的劣势\" class=\"headerlink\" title=\"Hybrid 的劣势\"></a>Hybrid 的劣势</h3><ul>\n<li>容易造成性能问题，不适用于依赖原生 API 、动画较多和游戏开发的需求。</li>\n<li>永远保持最新（直接访问线上，而不是使用 App 本地的静态资源）带来的低版本机型的适配问题，包括调用底层 API 和对 H5 的支持方面。（即不太好做版本控制）</li>\n<li>需要实现 Native 与 H5 之间的通信机制</li>\n<li>交互体验不如原生页面，需要尽可能仿制原生应用的体验</li>\n</ul>\n<p>总结来说，Web 只能替代、辅助一部分功能，无法取代原生开发的主导地位。</p>\n<h2 id=\"Hybrid-实现\"><a href=\"#Hybrid-实现\" class=\"headerlink\" title=\"Hybrid 实现\"></a>Hybrid 实现</h2><h3 id=\"Native-与前端之间的关系\"><a href=\"#Native-与前端之间的关系\" class=\"headerlink\" title=\"Native 与前端之间的关系\"></a>Native 与前端之间的关系</h3><p>Hybrid App 底层依赖于 Native 提供的容器，上层使用 H5 做业务开发，底层透明化、上层多样化，适合前端介入进行快速迭代开发。</p>\n<p>Native 提供的实际上是类似于浏览器的宿主环境，H5 页面可以利用宿主环境提供的“能力”来进行开发。正如一般浏览器为 JavaScript 提供了 window 对象以控制浏览器一样，Native 也可以为 H5 页面提供特定的接口以调用底层的 API。</p>\n<h3 id=\"Hybrid-交互设计\"><a href=\"#Hybrid-交互设计\" class=\"headerlink\" title=\"Hybrid 交互设计\"></a>Hybrid 交互设计</h3><p>Native 可以调用前端页面的 JavaScript 方法对视图进行操作，前端页面也可以通过 JavaScript 方法调用 Native 提供的接口实现系统层面的功能。两者沟通的桥梁则是 WebView。</p>\n<h3 id=\"Schema\"><a href=\"#Schema\" class=\"headerlink\" title=\"Schema\"></a><img src=\"/images/FE-Hybrid-interaction.png\" alt=\"\">Schema</h3><p>App 自身可以自定义 URL Schema，并且把自定义的 URL 注册在调度中心。App 安装后会在手机上注册一个 Schema，例如淘宝是 taobao:// ，Native 会有一个进程监控 WebView 发出的所有 schema:// 请求，从而打开 Native 应用并传入参数执行特定的行为。</p>\n<p>通过 Schema ，H5 可以通过发起 schema 请求，来实现 H5 与 Native 页面之间的跳转。</p>\n<h3 id=\"常用交互-API\"><a href=\"#常用交互-API\" class=\"headerlink\" title=\"常用交互 API\"></a>常用交互 API</h3><ul>\n<li>跳转<ul>\n<li>页面内部跳转</li>\n<li>H5 跳转 Native 界面，Native 通过截获 URL 参数跳转到响应页面。</li>\n<li>H5 新打开一个 WebView。</li>\n</ul>\n</li>\n<li>Header 组件<ul>\n<li>避免白屏陷入假死状态</li>\n<li>Header 左侧和右侧按钮可配置，中间 title 部分可配置</li>\n</ul>\n</li>\n<li>请求类<ul>\n<li>通过 Native 代理发起 AJAX 请求，解决跨域问题</li>\n</ul>\n</li>\n<li>Native UI 组件<ul>\n<li>Loading 组件</li>\n<li>Toast 组件</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://www.cnblogs.com/yexiaochai/p/4921635.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/yexiaochai/p/4921635.html</a></p>\n<p><a href=\"http://ued.ctrip.com/blog/translation-hybrid-mobile-application-provide-native-web-technology-experience.html\" target=\"_blank\" rel=\"external\">http://ued.ctrip.com/blog/translation-hybrid-mobile-application-provide-native-web-technology-experience.html</a></p>\n<p><a href=\"https://dailc.github.io/2016/10/04/hybridBase01HybridInfo.html\" target=\"_blank\" rel=\"external\">https://dailc.github.io/2016/10/04/hybridBase01HybridInfo.html</a></p>\n<p><a href=\"https://dailc.github.io/2016/10/04/hybridBase02HybridCompareOthers.html\" target=\"_blank\" rel=\"external\">https://dailc.github.io/2016/10/04/hybridBase02HybridCompareOthers.html</a></p>\n<p><a href=\"https://weex.apache.org/cn/\" target=\"_blank\" rel=\"external\">https://weex.apache.org/cn/</a></p>\n<p><a href=\"http://www.infoq.com/cn/articles/hybrid-app-development-combat#note-bottom-anchor\" target=\"_blank\" rel=\"external\">http://www.infoq.com/cn/articles/hybrid-app-development-combat#note-bottom-anchor</a></p>\n<p><a href=\"http://www.jianshu.com/p/e83aa2d1ade3\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/e83aa2d1ade3</a></p>\n"},{"layout":"post","title":"JavaScript：Promise 小记","date":"2017-05-28T12:00:00.000Z","_content":"\nPromise 对象是一个代理对象（代理一个值），被代理的值在 Promise 对象创建时可能是未知的。它最主要的特点，是可以让异步代码像同步方法那样返回值，并为结果的成功（onFulfilled）和失败（onRejected）绑定相应的处理方法（Handlers）。需要注意的是，尽管看起来像同步方法那样返回了值但是并不是**立即返回执行**的。\n\n```\nnew Promise(function(resolve, reject){\n    resolve(1);\n}).then(function(msg){\n    console.log(msg);\n})\n\nconsole.log(2);\n\n// 输出顺序为\n// 2\n// 1\n```\n\n一个 Promise 有以下几种状态：\n\n* pendding 初始状态\n* fulfilled 意味着操作成功\n* rejected 意味着操作失败\n\n![](https://mdn.mozillademos.org/files/8633/promises.png)\n\n\n\n## 语法\n\n```\nvar promise = new Promise(\n    /* executor */\n    function(resolve, reject) {...}\n);\n\n// 第一种处理方式\npromise.then(\n    /* onFulfilled */\n    function(){...},\n    \n    /* onRejected */\n    function(){...}\n)\n\n// 第二种处理方式\npromise.then(\n    /* onFulfilled */\n    function(){...}\n).catch(\n    /* onRejected */\n    function(){...}\n)\n```\n\n## 与回调函数的区别\n\n先来看一下一个普通的异步处理，使用回调函数来处理回调的结果：\n\n```\ngetAsycn(\"file.txt\", function(error, result){\n    \n    if(error){ // 取得失败时的处理\n        throw error;\n    }\n    \n    // 取得成功时的处理\n    \n})\n```\n\n接下来是使用Promise的处理方式：\n\n```\nvar promise = getAsyncPromise(\"file.txt\"); // 返回一个Promise对象\n\npromise.then(function(result){\n    // 取得成功时的处理\n    \n}.catch(function(error){\n    // 取得失败时的处理\n    \n})\n```\n\n## 参考\n\n[https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global\\_Objects/Promise](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise)\n\n\n\n","source":"_posts/2017-05-28-JavaScript：Promise 小记.md","raw":"---\nlayout: post\ntitle:  \"JavaScript：Promise 小记\"\ndate:   2017-05-28 20:00:00 +0800\ntags: javascript\n---\n\nPromise 对象是一个代理对象（代理一个值），被代理的值在 Promise 对象创建时可能是未知的。它最主要的特点，是可以让异步代码像同步方法那样返回值，并为结果的成功（onFulfilled）和失败（onRejected）绑定相应的处理方法（Handlers）。需要注意的是，尽管看起来像同步方法那样返回了值但是并不是**立即返回执行**的。\n\n```\nnew Promise(function(resolve, reject){\n    resolve(1);\n}).then(function(msg){\n    console.log(msg);\n})\n\nconsole.log(2);\n\n// 输出顺序为\n// 2\n// 1\n```\n\n一个 Promise 有以下几种状态：\n\n* pendding 初始状态\n* fulfilled 意味着操作成功\n* rejected 意味着操作失败\n\n![](https://mdn.mozillademos.org/files/8633/promises.png)\n\n\n\n## 语法\n\n```\nvar promise = new Promise(\n    /* executor */\n    function(resolve, reject) {...}\n);\n\n// 第一种处理方式\npromise.then(\n    /* onFulfilled */\n    function(){...},\n    \n    /* onRejected */\n    function(){...}\n)\n\n// 第二种处理方式\npromise.then(\n    /* onFulfilled */\n    function(){...}\n).catch(\n    /* onRejected */\n    function(){...}\n)\n```\n\n## 与回调函数的区别\n\n先来看一下一个普通的异步处理，使用回调函数来处理回调的结果：\n\n```\ngetAsycn(\"file.txt\", function(error, result){\n    \n    if(error){ // 取得失败时的处理\n        throw error;\n    }\n    \n    // 取得成功时的处理\n    \n})\n```\n\n接下来是使用Promise的处理方式：\n\n```\nvar promise = getAsyncPromise(\"file.txt\"); // 返回一个Promise对象\n\npromise.then(function(result){\n    // 取得成功时的处理\n    \n}.catch(function(error){\n    // 取得失败时的处理\n    \n})\n```\n\n## 参考\n\n[https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global\\_Objects/Promise](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise)\n\n\n\n","slug":"2017-05-28-JavaScript：Promise 小记","published":1,"updated":"2017-08-06T12:15:35.000Z","_id":"cj60bzxl800131dor1qb9hkjs","comments":1,"photos":[],"link":"","content":"<p>Promise 对象是一个代理对象（代理一个值），被代理的值在 Promise 对象创建时可能是未知的。它最主要的特点，是可以让异步代码像同步方法那样返回值，并为结果的成功（onFulfilled）和失败（onRejected）绑定相应的处理方法（Handlers）。需要注意的是，尽管看起来像同步方法那样返回了值但是并不是<strong>立即返回执行</strong>的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">new Promise(function(resolve, reject)&#123;</div><div class=\"line\">    resolve(1);</div><div class=\"line\">&#125;).then(function(msg)&#123;</div><div class=\"line\">    console.log(msg);</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">console.log(2);</div><div class=\"line\"></div><div class=\"line\">// 输出顺序为</div><div class=\"line\">// 2</div><div class=\"line\">// 1</div></pre></td></tr></table></figure>\n<p>一个 Promise 有以下几种状态：</p>\n<ul>\n<li>pendding 初始状态</li>\n<li>fulfilled 意味着操作成功</li>\n<li>rejected 意味着操作失败</li>\n</ul>\n<p><img src=\"https://mdn.mozillademos.org/files/8633/promises.png\" alt=\"\"></p>\n<h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">var promise = new Promise(</div><div class=\"line\">    /* executor */</div><div class=\"line\">    function(resolve, reject) &#123;...&#125;</div><div class=\"line\">);</div><div class=\"line\"></div><div class=\"line\">// 第一种处理方式</div><div class=\"line\">promise.then(</div><div class=\"line\">    /* onFulfilled */</div><div class=\"line\">    function()&#123;...&#125;,</div><div class=\"line\">    </div><div class=\"line\">    /* onRejected */</div><div class=\"line\">    function()&#123;...&#125;</div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\">// 第二种处理方式</div><div class=\"line\">promise.then(</div><div class=\"line\">    /* onFulfilled */</div><div class=\"line\">    function()&#123;...&#125;</div><div class=\"line\">).catch(</div><div class=\"line\">    /* onRejected */</div><div class=\"line\">    function()&#123;...&#125;</div><div class=\"line\">)</div></pre></td></tr></table></figure>\n<h2 id=\"与回调函数的区别\"><a href=\"#与回调函数的区别\" class=\"headerlink\" title=\"与回调函数的区别\"></a>与回调函数的区别</h2><p>先来看一下一个普通的异步处理，使用回调函数来处理回调的结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">getAsycn(&quot;file.txt&quot;, function(error, result)&#123;</div><div class=\"line\">    </div><div class=\"line\">    if(error)&#123; // 取得失败时的处理</div><div class=\"line\">        throw error;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    // 取得成功时的处理</div><div class=\"line\">    </div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>接下来是使用Promise的处理方式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">var promise = getAsyncPromise(&quot;file.txt&quot;); // 返回一个Promise对象</div><div class=\"line\"></div><div class=\"line\">promise.then(function(result)&#123;</div><div class=\"line\">    // 取得成功时的处理</div><div class=\"line\">    </div><div class=\"line\">&#125;.catch(function(error)&#123;</div><div class=\"line\">    // 取得失败时的处理</div><div class=\"line\">    </div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise\" target=\"_blank\" rel=\"external\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Promise 对象是一个代理对象（代理一个值），被代理的值在 Promise 对象创建时可能是未知的。它最主要的特点，是可以让异步代码像同步方法那样返回值，并为结果的成功（onFulfilled）和失败（onRejected）绑定相应的处理方法（Handlers）。需要注意的是，尽管看起来像同步方法那样返回了值但是并不是<strong>立即返回执行</strong>的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">new Promise(function(resolve, reject)&#123;</div><div class=\"line\">    resolve(1);</div><div class=\"line\">&#125;).then(function(msg)&#123;</div><div class=\"line\">    console.log(msg);</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">console.log(2);</div><div class=\"line\"></div><div class=\"line\">// 输出顺序为</div><div class=\"line\">// 2</div><div class=\"line\">// 1</div></pre></td></tr></table></figure>\n<p>一个 Promise 有以下几种状态：</p>\n<ul>\n<li>pendding 初始状态</li>\n<li>fulfilled 意味着操作成功</li>\n<li>rejected 意味着操作失败</li>\n</ul>\n<p><img src=\"https://mdn.mozillademos.org/files/8633/promises.png\" alt=\"\"></p>\n<h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">var promise = new Promise(</div><div class=\"line\">    /* executor */</div><div class=\"line\">    function(resolve, reject) &#123;...&#125;</div><div class=\"line\">);</div><div class=\"line\"></div><div class=\"line\">// 第一种处理方式</div><div class=\"line\">promise.then(</div><div class=\"line\">    /* onFulfilled */</div><div class=\"line\">    function()&#123;...&#125;,</div><div class=\"line\">    </div><div class=\"line\">    /* onRejected */</div><div class=\"line\">    function()&#123;...&#125;</div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\">// 第二种处理方式</div><div class=\"line\">promise.then(</div><div class=\"line\">    /* onFulfilled */</div><div class=\"line\">    function()&#123;...&#125;</div><div class=\"line\">).catch(</div><div class=\"line\">    /* onRejected */</div><div class=\"line\">    function()&#123;...&#125;</div><div class=\"line\">)</div></pre></td></tr></table></figure>\n<h2 id=\"与回调函数的区别\"><a href=\"#与回调函数的区别\" class=\"headerlink\" title=\"与回调函数的区别\"></a>与回调函数的区别</h2><p>先来看一下一个普通的异步处理，使用回调函数来处理回调的结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">getAsycn(&quot;file.txt&quot;, function(error, result)&#123;</div><div class=\"line\">    </div><div class=\"line\">    if(error)&#123; // 取得失败时的处理</div><div class=\"line\">        throw error;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    // 取得成功时的处理</div><div class=\"line\">    </div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>接下来是使用Promise的处理方式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">var promise = getAsyncPromise(&quot;file.txt&quot;); // 返回一个Promise对象</div><div class=\"line\"></div><div class=\"line\">promise.then(function(result)&#123;</div><div class=\"line\">    // 取得成功时的处理</div><div class=\"line\">    </div><div class=\"line\">&#125;.catch(function(error)&#123;</div><div class=\"line\">    // 取得失败时的处理</div><div class=\"line\">    </div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise\" target=\"_blank\" rel=\"external\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise</a></p>\n"},{"layout":"post","title":"CSS：table-cell 用法小记","date":"2017-06-01T12:00:00.000Z","_content":"\n## 1、垂直居中\n\n```\n<div class=\"table-cell\">\n    <div>需要垂直居中的元素</div>\n</div>\n```\n\n```\n.table-cell {\n    display: table-cell;\n    verticall-align: middle;\n    height: 200px;\n}\n```\n\n## 2、等高布局\n\n```\n<div class=\"table\">\n    <div class=\"table-cell\">\n        <div>等高布局</div>\n    </div>\n    <div class=\"table-cell width-100\">\n        <div>table-cell的高度取决于所有table-cell中最大的高度</div>\n    </div>\n</div>\n```\n\n```\n.table {\n    display: table;\n}\n.table-cell {\n    display: table-cell;\n}\n.width-100 {\n    width: 100px;\n}\n```\n\n## 3、平均划分子元素\n\n```\n<div class=\"table\">\n    <div class=\"table-cell\">\n        子元素\n    </div>\n    <div class=\"table-cell\">\n        子元素\n    </div>\n    <div class=\"table-cell\">\n        子元素\n    </div>\n</div>\n```\n\n```\n.table {\n    display: table;\n    width: 100%;\n}\n.table-cell {\n    display: table-cell;\n}\n```\n\n## 参考\n\n[https://my.oschina.net/CharmyZ/blog/714983](https://my.oschina.net/CharmyZ/blog/714983)\n\n\n\n","source":"_posts/2017-06-01-CSS：table-cell 用法小.md","raw":"---\nlayout: post\ntitle:  \"CSS：table-cell 用法小记\"\ndate:   2017-06-01 20:00:00 +0800\ntags: css\n---\n\n## 1、垂直居中\n\n```\n<div class=\"table-cell\">\n    <div>需要垂直居中的元素</div>\n</div>\n```\n\n```\n.table-cell {\n    display: table-cell;\n    verticall-align: middle;\n    height: 200px;\n}\n```\n\n## 2、等高布局\n\n```\n<div class=\"table\">\n    <div class=\"table-cell\">\n        <div>等高布局</div>\n    </div>\n    <div class=\"table-cell width-100\">\n        <div>table-cell的高度取决于所有table-cell中最大的高度</div>\n    </div>\n</div>\n```\n\n```\n.table {\n    display: table;\n}\n.table-cell {\n    display: table-cell;\n}\n.width-100 {\n    width: 100px;\n}\n```\n\n## 3、平均划分子元素\n\n```\n<div class=\"table\">\n    <div class=\"table-cell\">\n        子元素\n    </div>\n    <div class=\"table-cell\">\n        子元素\n    </div>\n    <div class=\"table-cell\">\n        子元素\n    </div>\n</div>\n```\n\n```\n.table {\n    display: table;\n    width: 100%;\n}\n.table-cell {\n    display: table-cell;\n}\n```\n\n## 参考\n\n[https://my.oschina.net/CharmyZ/blog/714983](https://my.oschina.net/CharmyZ/blog/714983)\n\n\n\n","slug":"2017-06-01-CSS：table-cell 用法小","published":1,"updated":"2017-08-06T12:15:40.000Z","_id":"cj60bzxl900151dorx35wkekt","comments":1,"photos":[],"link":"","content":"<h2 id=\"1、垂直居中\"><a href=\"#1、垂直居中\" class=\"headerlink\" title=\"1、垂直居中\"></a>1、垂直居中</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div class=&quot;table-cell&quot;&gt;</div><div class=\"line\">    &lt;div&gt;需要垂直居中的元素&lt;/div&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">.table-cell &#123;</div><div class=\"line\">    display: table-cell;</div><div class=\"line\">    verticall-align: middle;</div><div class=\"line\">    height: 200px;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"2、等高布局\"><a href=\"#2、等高布局\" class=\"headerlink\" title=\"2、等高布局\"></a>2、等高布局</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div class=&quot;table&quot;&gt;</div><div class=\"line\">    &lt;div class=&quot;table-cell&quot;&gt;</div><div class=\"line\">        &lt;div&gt;等高布局&lt;/div&gt;</div><div class=\"line\">    &lt;/div&gt;</div><div class=\"line\">    &lt;div class=&quot;table-cell width-100&quot;&gt;</div><div class=\"line\">        &lt;div&gt;table-cell的高度取决于所有table-cell中最大的高度&lt;/div&gt;</div><div class=\"line\">    &lt;/div&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">.table &#123;</div><div class=\"line\">    display: table;</div><div class=\"line\">&#125;</div><div class=\"line\">.table-cell &#123;</div><div class=\"line\">    display: table-cell;</div><div class=\"line\">&#125;</div><div class=\"line\">.width-100 &#123;</div><div class=\"line\">    width: 100px;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"3、平均划分子元素\"><a href=\"#3、平均划分子元素\" class=\"headerlink\" title=\"3、平均划分子元素\"></a>3、平均划分子元素</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div class=&quot;table&quot;&gt;</div><div class=\"line\">    &lt;div class=&quot;table-cell&quot;&gt;</div><div class=\"line\">        子元素</div><div class=\"line\">    &lt;/div&gt;</div><div class=\"line\">    &lt;div class=&quot;table-cell&quot;&gt;</div><div class=\"line\">        子元素</div><div class=\"line\">    &lt;/div&gt;</div><div class=\"line\">    &lt;div class=&quot;table-cell&quot;&gt;</div><div class=\"line\">        子元素</div><div class=\"line\">    &lt;/div&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">.table &#123;</div><div class=\"line\">    display: table;</div><div class=\"line\">    width: 100%;</div><div class=\"line\">&#125;</div><div class=\"line\">.table-cell &#123;</div><div class=\"line\">    display: table-cell;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://my.oschina.net/CharmyZ/blog/714983\" target=\"_blank\" rel=\"external\">https://my.oschina.net/CharmyZ/blog/714983</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1、垂直居中\"><a href=\"#1、垂直居中\" class=\"headerlink\" title=\"1、垂直居中\"></a>1、垂直居中</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div class=&quot;table-cell&quot;&gt;</div><div class=\"line\">    &lt;div&gt;需要垂直居中的元素&lt;/div&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">.table-cell &#123;</div><div class=\"line\">    display: table-cell;</div><div class=\"line\">    verticall-align: middle;</div><div class=\"line\">    height: 200px;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"2、等高布局\"><a href=\"#2、等高布局\" class=\"headerlink\" title=\"2、等高布局\"></a>2、等高布局</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div class=&quot;table&quot;&gt;</div><div class=\"line\">    &lt;div class=&quot;table-cell&quot;&gt;</div><div class=\"line\">        &lt;div&gt;等高布局&lt;/div&gt;</div><div class=\"line\">    &lt;/div&gt;</div><div class=\"line\">    &lt;div class=&quot;table-cell width-100&quot;&gt;</div><div class=\"line\">        &lt;div&gt;table-cell的高度取决于所有table-cell中最大的高度&lt;/div&gt;</div><div class=\"line\">    &lt;/div&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">.table &#123;</div><div class=\"line\">    display: table;</div><div class=\"line\">&#125;</div><div class=\"line\">.table-cell &#123;</div><div class=\"line\">    display: table-cell;</div><div class=\"line\">&#125;</div><div class=\"line\">.width-100 &#123;</div><div class=\"line\">    width: 100px;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"3、平均划分子元素\"><a href=\"#3、平均划分子元素\" class=\"headerlink\" title=\"3、平均划分子元素\"></a>3、平均划分子元素</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div class=&quot;table&quot;&gt;</div><div class=\"line\">    &lt;div class=&quot;table-cell&quot;&gt;</div><div class=\"line\">        子元素</div><div class=\"line\">    &lt;/div&gt;</div><div class=\"line\">    &lt;div class=&quot;table-cell&quot;&gt;</div><div class=\"line\">        子元素</div><div class=\"line\">    &lt;/div&gt;</div><div class=\"line\">    &lt;div class=&quot;table-cell&quot;&gt;</div><div class=\"line\">        子元素</div><div class=\"line\">    &lt;/div&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">.table &#123;</div><div class=\"line\">    display: table;</div><div class=\"line\">    width: 100%;</div><div class=\"line\">&#125;</div><div class=\"line\">.table-cell &#123;</div><div class=\"line\">    display: table-cell;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://my.oschina.net/CharmyZ/blog/714983\" target=\"_blank\" rel=\"external\">https://my.oschina.net/CharmyZ/blog/714983</a></p>\n"},{"layout":"post","title":"CSS：Animation 动画小记","date":"2017-06-21T12:00:00.000Z","_content":"\n## 属性\n\n* animation-delay 延时\n* animation-direction 动画重复播放时是反向运行还是回到开始位置\n* animation-duration 动画持续时间\n* animation-iteration-count 动画重复次数\n* animation-name 关键帧名称\n* animation-play-state 允许暂停和回复动画\n* animation-timing-function 动画速度函数\n* animation-fill-mode 动画执行前后目标元素如何应用样式\n\n## 关键帧 keyframes\n\n```\np {\n    animation-name: slidein;\n}\n\n@keyframes slidein {\n    from {\n        margin-left: 100%;\n        width: 300%;\n    }\n    \n    to {\n        margin-left: 0%;\n        width: 100%;\n    }\n}\n```\n\n除了 from 和 to ，也可以用百分比来定义关键帧。\n\n```\n@keyframes slidein {\n    0% {\n        margin-left: 100%;\n        width: 300%;\n    }\n    \n    50% {\n        margin-left: 70%;\n        witdh: 250%;\n    }\n    \n    100% {\n        margin-left: 0;\n        width: 100%;\n    }\n}\n```\n\n## 重复播放动画\n\n设置 `animation-iteration-coutn` 为 `infinite` 即可。\n\n```\np {\n    animation-name: slidein;\n    animation-iteration-count: infinite;\n}\n```\n\n## 来回播放动画\n\n设置 `animation-direction` 为 `alternate`\n\n```\np {\n    animation-name: slidein;\n    animation-iteration-count: infinite;\n    animation-direction: alternate;\n}\n```\n\n## 动画事件 Animation Event\n\n* animationstart 动画开始时\n* animationend 动画结束时\n* animationiteration 开始重复动画时\n\n```\n$('p').on('animationiteration webkitAnimationIteration', (e) => {\n    // do something\n})\n```\n\n注意添加 webkit 前缀，以兼容低版本浏览器。\n\n## 移动设备兼容性\n\n iOS 9.2 起、安卓 4.2~4.3 起（需添加 webkit 前缀）\n\n## 参考\n\n[http://www.runoob.com/jsref/event-animationiteration.html](http://www.runoob.com/jsref/event-animationiteration.html)\n\n[https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent](https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent)\n\n[https://caniuse.com/\\#search=animation](https://caniuse.com/#search=animation)\n\n","source":"_posts/2017-06-21-CSS：Animation 动画.md","raw":"---\nlayout: post\ntitle:  \"CSS：Animation 动画小记\"\ndate:   2017-06-21 20:00:00 +0800\ntags: css\n---\n\n## 属性\n\n* animation-delay 延时\n* animation-direction 动画重复播放时是反向运行还是回到开始位置\n* animation-duration 动画持续时间\n* animation-iteration-count 动画重复次数\n* animation-name 关键帧名称\n* animation-play-state 允许暂停和回复动画\n* animation-timing-function 动画速度函数\n* animation-fill-mode 动画执行前后目标元素如何应用样式\n\n## 关键帧 keyframes\n\n```\np {\n    animation-name: slidein;\n}\n\n@keyframes slidein {\n    from {\n        margin-left: 100%;\n        width: 300%;\n    }\n    \n    to {\n        margin-left: 0%;\n        width: 100%;\n    }\n}\n```\n\n除了 from 和 to ，也可以用百分比来定义关键帧。\n\n```\n@keyframes slidein {\n    0% {\n        margin-left: 100%;\n        width: 300%;\n    }\n    \n    50% {\n        margin-left: 70%;\n        witdh: 250%;\n    }\n    \n    100% {\n        margin-left: 0;\n        width: 100%;\n    }\n}\n```\n\n## 重复播放动画\n\n设置 `animation-iteration-coutn` 为 `infinite` 即可。\n\n```\np {\n    animation-name: slidein;\n    animation-iteration-count: infinite;\n}\n```\n\n## 来回播放动画\n\n设置 `animation-direction` 为 `alternate`\n\n```\np {\n    animation-name: slidein;\n    animation-iteration-count: infinite;\n    animation-direction: alternate;\n}\n```\n\n## 动画事件 Animation Event\n\n* animationstart 动画开始时\n* animationend 动画结束时\n* animationiteration 开始重复动画时\n\n```\n$('p').on('animationiteration webkitAnimationIteration', (e) => {\n    // do something\n})\n```\n\n注意添加 webkit 前缀，以兼容低版本浏览器。\n\n## 移动设备兼容性\n\n iOS 9.2 起、安卓 4.2~4.3 起（需添加 webkit 前缀）\n\n## 参考\n\n[http://www.runoob.com/jsref/event-animationiteration.html](http://www.runoob.com/jsref/event-animationiteration.html)\n\n[https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent](https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent)\n\n[https://caniuse.com/\\#search=animation](https://caniuse.com/#search=animation)\n\n","slug":"2017-06-21-CSS：Animation 动画","published":1,"updated":"2017-08-06T12:15:43.000Z","_id":"cj60bzxla00161dorbhx32z3f","comments":1,"photos":[],"link":"","content":"<h2 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h2><ul>\n<li>animation-delay 延时</li>\n<li>animation-direction 动画重复播放时是反向运行还是回到开始位置</li>\n<li>animation-duration 动画持续时间</li>\n<li>animation-iteration-count 动画重复次数</li>\n<li>animation-name 关键帧名称</li>\n<li>animation-play-state 允许暂停和回复动画</li>\n<li>animation-timing-function 动画速度函数</li>\n<li>animation-fill-mode 动画执行前后目标元素如何应用样式</li>\n</ul>\n<h2 id=\"关键帧-keyframes\"><a href=\"#关键帧-keyframes\" class=\"headerlink\" title=\"关键帧 keyframes\"></a>关键帧 keyframes</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">p &#123;</div><div class=\"line\">    animation-name: slidein;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@keyframes slidein &#123;</div><div class=\"line\">    from &#123;</div><div class=\"line\">        margin-left: 100%;</div><div class=\"line\">        width: 300%;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    to &#123;</div><div class=\"line\">        margin-left: 0%;</div><div class=\"line\">        width: 100%;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>除了 from 和 to ，也可以用百分比来定义关键帧。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">@keyframes slidein &#123;</div><div class=\"line\">    0% &#123;</div><div class=\"line\">        margin-left: 100%;</div><div class=\"line\">        width: 300%;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    50% &#123;</div><div class=\"line\">        margin-left: 70%;</div><div class=\"line\">        witdh: 250%;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    100% &#123;</div><div class=\"line\">        margin-left: 0;</div><div class=\"line\">        width: 100%;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"重复播放动画\"><a href=\"#重复播放动画\" class=\"headerlink\" title=\"重复播放动画\"></a>重复播放动画</h2><p>设置 <code>animation-iteration-coutn</code> 为 <code>infinite</code> 即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">p &#123;</div><div class=\"line\">    animation-name: slidein;</div><div class=\"line\">    animation-iteration-count: infinite;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"来回播放动画\"><a href=\"#来回播放动画\" class=\"headerlink\" title=\"来回播放动画\"></a>来回播放动画</h2><p>设置 <code>animation-direction</code> 为 <code>alternate</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">p &#123;</div><div class=\"line\">    animation-name: slidein;</div><div class=\"line\">    animation-iteration-count: infinite;</div><div class=\"line\">    animation-direction: alternate;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"动画事件-Animation-Event\"><a href=\"#动画事件-Animation-Event\" class=\"headerlink\" title=\"动画事件 Animation Event\"></a>动画事件 Animation Event</h2><ul>\n<li>animationstart 动画开始时</li>\n<li>animationend 动画结束时</li>\n<li>animationiteration 开始重复动画时</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$(&apos;p&apos;).on(&apos;animationiteration webkitAnimationIteration&apos;, (e) =&gt; &#123;</div><div class=\"line\">    // do something</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>注意添加 webkit 前缀，以兼容低版本浏览器。</p>\n<h2 id=\"移动设备兼容性\"><a href=\"#移动设备兼容性\" class=\"headerlink\" title=\"移动设备兼容性\"></a>移动设备兼容性</h2><p> iOS 9.2 起、安卓 4.2~4.3 起（需添加 webkit 前缀）</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://www.runoob.com/jsref/event-animationiteration.html\" target=\"_blank\" rel=\"external\">http://www.runoob.com/jsref/event-animationiteration.html</a></p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent\" target=\"_blank\" rel=\"external\">https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent</a></p>\n<p><a href=\"https://caniuse.com/#search=animation\" target=\"_blank\" rel=\"external\">https://caniuse.com/#search=animation</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h2><ul>\n<li>animation-delay 延时</li>\n<li>animation-direction 动画重复播放时是反向运行还是回到开始位置</li>\n<li>animation-duration 动画持续时间</li>\n<li>animation-iteration-count 动画重复次数</li>\n<li>animation-name 关键帧名称</li>\n<li>animation-play-state 允许暂停和回复动画</li>\n<li>animation-timing-function 动画速度函数</li>\n<li>animation-fill-mode 动画执行前后目标元素如何应用样式</li>\n</ul>\n<h2 id=\"关键帧-keyframes\"><a href=\"#关键帧-keyframes\" class=\"headerlink\" title=\"关键帧 keyframes\"></a>关键帧 keyframes</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">p &#123;</div><div class=\"line\">    animation-name: slidein;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@keyframes slidein &#123;</div><div class=\"line\">    from &#123;</div><div class=\"line\">        margin-left: 100%;</div><div class=\"line\">        width: 300%;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    to &#123;</div><div class=\"line\">        margin-left: 0%;</div><div class=\"line\">        width: 100%;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>除了 from 和 to ，也可以用百分比来定义关键帧。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">@keyframes slidein &#123;</div><div class=\"line\">    0% &#123;</div><div class=\"line\">        margin-left: 100%;</div><div class=\"line\">        width: 300%;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    50% &#123;</div><div class=\"line\">        margin-left: 70%;</div><div class=\"line\">        witdh: 250%;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    100% &#123;</div><div class=\"line\">        margin-left: 0;</div><div class=\"line\">        width: 100%;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"重复播放动画\"><a href=\"#重复播放动画\" class=\"headerlink\" title=\"重复播放动画\"></a>重复播放动画</h2><p>设置 <code>animation-iteration-coutn</code> 为 <code>infinite</code> 即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">p &#123;</div><div class=\"line\">    animation-name: slidein;</div><div class=\"line\">    animation-iteration-count: infinite;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"来回播放动画\"><a href=\"#来回播放动画\" class=\"headerlink\" title=\"来回播放动画\"></a>来回播放动画</h2><p>设置 <code>animation-direction</code> 为 <code>alternate</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">p &#123;</div><div class=\"line\">    animation-name: slidein;</div><div class=\"line\">    animation-iteration-count: infinite;</div><div class=\"line\">    animation-direction: alternate;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"动画事件-Animation-Event\"><a href=\"#动画事件-Animation-Event\" class=\"headerlink\" title=\"动画事件 Animation Event\"></a>动画事件 Animation Event</h2><ul>\n<li>animationstart 动画开始时</li>\n<li>animationend 动画结束时</li>\n<li>animationiteration 开始重复动画时</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$(&apos;p&apos;).on(&apos;animationiteration webkitAnimationIteration&apos;, (e) =&gt; &#123;</div><div class=\"line\">    // do something</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>注意添加 webkit 前缀，以兼容低版本浏览器。</p>\n<h2 id=\"移动设备兼容性\"><a href=\"#移动设备兼容性\" class=\"headerlink\" title=\"移动设备兼容性\"></a>移动设备兼容性</h2><p> iOS 9.2 起、安卓 4.2~4.3 起（需添加 webkit 前缀）</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://www.runoob.com/jsref/event-animationiteration.html\" target=\"_blank\" rel=\"external\">http://www.runoob.com/jsref/event-animationiteration.html</a></p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent\" target=\"_blank\" rel=\"external\">https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent</a></p>\n<p><a href=\"https://caniuse.com/#search=animation\" target=\"_blank\" rel=\"external\">https://caniuse.com/#search=animation</a></p>\n"},{"layout":"post","title":"Vue：基础用法与指令","date":"2017-06-21T12:00:00.000Z","_content":"## Vue 是什么？\n\nVue 是一套构建用户界面的渐进式框架，采用自底向上增量开发的设计。Vue 的核心库值关注视图层（View）。\n\n## 声明式渲染\n\n### 文本插值\n\n```\n<div id=\"app\">\n    {{ message }}\n</div>\n```\n\n```\nvar app = new Vue({\n    el:'#app',\n    data: {\n        message: 'hello'\n    }\n})\n```\n\n### 渲染 DOM 属性（ v-bind:name 指令）\n\n```\n<div id=\"app\">\n    <span v-bind:title=\"message\">\n        鼠标悬停此处查看动态提示信息\n    </span>\n</div>\n```\n\n```\nvar app = new Vue({\n    el: '#app',\n    data: {\n        message: '提示信息'\n    }\n})\n```\n\nv-bind 属性被称为指令（指令带有前缀 v-，以表示他们是 Vue 提供的特殊属性）。这里该指令的作用是“将这个元素的 title 属性和 Vue 实例的 message 属性保持一致”。\n\n## 条件与循环（ v-if 指令和 v-for 指令）\n\n### 条件\n\n```\n<div id=\"app\">\n    <p v-if=\"seen\">看到了没？</p>\n</div>\n```\n\n```\nvar app = new Vue({\n    el: '#app',\n    data: {\n        seen: true\n    }\n})\n```\n\n### 循环\n\n```\n<div id=\"app\">\n    <ol>\n        <li v-for=\"todo in todos\">\n            {{ todo.text }}\n        </li>\n    </ol>\n</div>\n```\n\n```\nvar app = new Vue({\n    el: '#app',\n    data: {\n        todos:［\n            { text : '吃饭' },\n            { text : '睡觉' },\n            { text : '打游戏' }\n        ］\n    }\n})\n```\n\n## 处理用户输入（ v-on 指令和 v-model 指令）\n\n### 事件监听器\n\n```\n<div id=\"app\">\n    <p>{{ message }}</p>\n    <button v-on:click=\"reverseMessage\">逆转消息</\n</div>\n```\n\n```\nvar app = new Vue({\n    el:'#app',\n    data: {\n        message: 'hello'\n    },\n    methods: {\n        reverseMessage: function(){\n            this.message = this.message.split('').reverse().join()\n        }\n    }\n})\n```\n\n### 双向绑定\n\n```\n<div id=\"app\">\n    <p>{{ message }}</p>\n    <input v-model=\"message\" >\n</div>\n```\n\n```\nvar app = new Vue({\n    el: '#app',\n    data:{\n        message: 'hello'\n    }\n})\n```\n\n## 组件化\n\n```\n<div id=\"app\">\n    <ol>\n        <todo-item v-for=\"item in list\" v-bind:todo=\"item\"></todo-item>\n    </ol>\n</div>\n```\n\n```\nVue.component('todo-item', {\n    props: ['todo'], //接受一个自定义属性todo\n    template: '<li>{{ todo.text }}</li>'\n})\n\nvar app = new Vue({\n    el:'#app',\n    data: {\n        list : [\n            { text: 'apple' },\n            { text: 'banana' },\n            { text: 'orange' }\n        ]\n    }\n})\n```\n\n注意，在这个例子中 v-for 循环渲染子组件 todo-item ，并传递了 item 变量。接着 v-bind 指令将 item 与子组件的 todo 属性绑定起来，接受到 todo 属性的子组件读取 todo.text 插入到 &lt;li&gt; 中。整个过程，父组件向子组件单向传递数据并渲染出来。\n\n## 小结\n\n### 指令\n\n* v-bind:name \n* v-if \n* v-for\n* v-on\n* v-model\n\n## 参考\n\n[https://cn.vuejs.org/v2/guide/](https://cn.vuejs.org/v2/guide/)\n\n","source":"_posts/2017-06-21-Vue：基础用法与指令.md","raw":"---\nlayout: post\ntitle:  \"Vue：基础用法与指令\"\ndate:   2017-06-21 20:00:00 +0800\ntags: vue\n---\n## Vue 是什么？\n\nVue 是一套构建用户界面的渐进式框架，采用自底向上增量开发的设计。Vue 的核心库值关注视图层（View）。\n\n## 声明式渲染\n\n### 文本插值\n\n```\n<div id=\"app\">\n    {{ message }}\n</div>\n```\n\n```\nvar app = new Vue({\n    el:'#app',\n    data: {\n        message: 'hello'\n    }\n})\n```\n\n### 渲染 DOM 属性（ v-bind:name 指令）\n\n```\n<div id=\"app\">\n    <span v-bind:title=\"message\">\n        鼠标悬停此处查看动态提示信息\n    </span>\n</div>\n```\n\n```\nvar app = new Vue({\n    el: '#app',\n    data: {\n        message: '提示信息'\n    }\n})\n```\n\nv-bind 属性被称为指令（指令带有前缀 v-，以表示他们是 Vue 提供的特殊属性）。这里该指令的作用是“将这个元素的 title 属性和 Vue 实例的 message 属性保持一致”。\n\n## 条件与循环（ v-if 指令和 v-for 指令）\n\n### 条件\n\n```\n<div id=\"app\">\n    <p v-if=\"seen\">看到了没？</p>\n</div>\n```\n\n```\nvar app = new Vue({\n    el: '#app',\n    data: {\n        seen: true\n    }\n})\n```\n\n### 循环\n\n```\n<div id=\"app\">\n    <ol>\n        <li v-for=\"todo in todos\">\n            {{ todo.text }}\n        </li>\n    </ol>\n</div>\n```\n\n```\nvar app = new Vue({\n    el: '#app',\n    data: {\n        todos:［\n            { text : '吃饭' },\n            { text : '睡觉' },\n            { text : '打游戏' }\n        ］\n    }\n})\n```\n\n## 处理用户输入（ v-on 指令和 v-model 指令）\n\n### 事件监听器\n\n```\n<div id=\"app\">\n    <p>{{ message }}</p>\n    <button v-on:click=\"reverseMessage\">逆转消息</\n</div>\n```\n\n```\nvar app = new Vue({\n    el:'#app',\n    data: {\n        message: 'hello'\n    },\n    methods: {\n        reverseMessage: function(){\n            this.message = this.message.split('').reverse().join()\n        }\n    }\n})\n```\n\n### 双向绑定\n\n```\n<div id=\"app\">\n    <p>{{ message }}</p>\n    <input v-model=\"message\" >\n</div>\n```\n\n```\nvar app = new Vue({\n    el: '#app',\n    data:{\n        message: 'hello'\n    }\n})\n```\n\n## 组件化\n\n```\n<div id=\"app\">\n    <ol>\n        <todo-item v-for=\"item in list\" v-bind:todo=\"item\"></todo-item>\n    </ol>\n</div>\n```\n\n```\nVue.component('todo-item', {\n    props: ['todo'], //接受一个自定义属性todo\n    template: '<li>{{ todo.text }}</li>'\n})\n\nvar app = new Vue({\n    el:'#app',\n    data: {\n        list : [\n            { text: 'apple' },\n            { text: 'banana' },\n            { text: 'orange' }\n        ]\n    }\n})\n```\n\n注意，在这个例子中 v-for 循环渲染子组件 todo-item ，并传递了 item 变量。接着 v-bind 指令将 item 与子组件的 todo 属性绑定起来，接受到 todo 属性的子组件读取 todo.text 插入到 &lt;li&gt; 中。整个过程，父组件向子组件单向传递数据并渲染出来。\n\n## 小结\n\n### 指令\n\n* v-bind:name \n* v-if \n* v-for\n* v-on\n* v-model\n\n## 参考\n\n[https://cn.vuejs.org/v2/guide/](https://cn.vuejs.org/v2/guide/)\n\n","slug":"2017-06-21-Vue：基础用法与指令","published":1,"updated":"2017-08-06T12:15:47.000Z","_id":"cj60bzxlb00191dormk6720gq","comments":1,"photos":[],"link":"","content":"<h2 id=\"Vue-是什么？\"><a href=\"#Vue-是什么？\" class=\"headerlink\" title=\"Vue 是什么？\"></a>Vue 是什么？</h2><p>Vue 是一套构建用户界面的渐进式框架，采用自底向上增量开发的设计。Vue 的核心库值关注视图层（View）。</p>\n<h2 id=\"声明式渲染\"><a href=\"#声明式渲染\" class=\"headerlink\" title=\"声明式渲染\"></a>声明式渲染</h2><h3 id=\"文本插值\"><a href=\"#文本插值\" class=\"headerlink\" title=\"文本插值\"></a>文本插值</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div id=&quot;app&quot;&gt;</div><div class=\"line\">    &#123;&#123; message &#125;&#125;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">var app = new Vue(&#123;</div><div class=\"line\">    el:&apos;#app&apos;,</div><div class=\"line\">    data: &#123;</div><div class=\"line\">        message: &apos;hello&apos;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h3 id=\"渲染-DOM-属性（-v-bind-name-指令）\"><a href=\"#渲染-DOM-属性（-v-bind-name-指令）\" class=\"headerlink\" title=\"渲染 DOM 属性（ v-bind:name 指令）\"></a>渲染 DOM 属性（ v-bind:name 指令）</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div id=&quot;app&quot;&gt;</div><div class=\"line\">    &lt;span v-bind:title=&quot;message&quot;&gt;</div><div class=\"line\">        鼠标悬停此处查看动态提示信息</div><div class=\"line\">    &lt;/span&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">var app = new Vue(&#123;</div><div class=\"line\">    el: &apos;#app&apos;,</div><div class=\"line\">    data: &#123;</div><div class=\"line\">        message: &apos;提示信息&apos;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>v-bind 属性被称为指令（指令带有前缀 v-，以表示他们是 Vue 提供的特殊属性）。这里该指令的作用是“将这个元素的 title 属性和 Vue 实例的 message 属性保持一致”。</p>\n<h2 id=\"条件与循环（-v-if-指令和-v-for-指令）\"><a href=\"#条件与循环（-v-if-指令和-v-for-指令）\" class=\"headerlink\" title=\"条件与循环（ v-if 指令和 v-for 指令）\"></a>条件与循环（ v-if 指令和 v-for 指令）</h2><h3 id=\"条件\"><a href=\"#条件\" class=\"headerlink\" title=\"条件\"></a>条件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div id=&quot;app&quot;&gt;</div><div class=\"line\">    &lt;p v-if=&quot;seen&quot;&gt;看到了没？&lt;/p&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">var app = new Vue(&#123;</div><div class=\"line\">    el: &apos;#app&apos;,</div><div class=\"line\">    data: &#123;</div><div class=\"line\">        seen: true</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h3 id=\"循环\"><a href=\"#循环\" class=\"headerlink\" title=\"循环\"></a>循环</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div id=&quot;app&quot;&gt;</div><div class=\"line\">    &lt;ol&gt;</div><div class=\"line\">        &lt;li v-for=&quot;todo in todos&quot;&gt;</div><div class=\"line\">            &#123;&#123; todo.text &#125;&#125;</div><div class=\"line\">        &lt;/li&gt;</div><div class=\"line\">    &lt;/ol&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">var app = new Vue(&#123;</div><div class=\"line\">    el: &apos;#app&apos;,</div><div class=\"line\">    data: &#123;</div><div class=\"line\">        todos:［</div><div class=\"line\">            &#123; text : &apos;吃饭&apos; &#125;,</div><div class=\"line\">            &#123; text : &apos;睡觉&apos; &#125;,</div><div class=\"line\">            &#123; text : &apos;打游戏&apos; &#125;</div><div class=\"line\">        ］</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h2 id=\"处理用户输入（-v-on-指令和-v-model-指令）\"><a href=\"#处理用户输入（-v-on-指令和-v-model-指令）\" class=\"headerlink\" title=\"处理用户输入（ v-on 指令和 v-model 指令）\"></a>处理用户输入（ v-on 指令和 v-model 指令）</h2><h3 id=\"事件监听器\"><a href=\"#事件监听器\" class=\"headerlink\" title=\"事件监听器\"></a>事件监听器</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div id=&quot;app&quot;&gt;</div><div class=\"line\">    &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;</div><div class=\"line\">    &lt;button v-on:click=&quot;reverseMessage&quot;&gt;逆转消息&lt;/</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">var app = new Vue(&#123;</div><div class=\"line\">    el:&apos;#app&apos;,</div><div class=\"line\">    data: &#123;</div><div class=\"line\">        message: &apos;hello&apos;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    methods: &#123;</div><div class=\"line\">        reverseMessage: function()&#123;</div><div class=\"line\">            this.message = this.message.split(&apos;&apos;).reverse().join()</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h3 id=\"双向绑定\"><a href=\"#双向绑定\" class=\"headerlink\" title=\"双向绑定\"></a>双向绑定</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div id=&quot;app&quot;&gt;</div><div class=\"line\">    &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;</div><div class=\"line\">    &lt;input v-model=&quot;message&quot; &gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">var app = new Vue(&#123;</div><div class=\"line\">    el: &apos;#app&apos;,</div><div class=\"line\">    data:&#123;</div><div class=\"line\">        message: &apos;hello&apos;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h2 id=\"组件化\"><a href=\"#组件化\" class=\"headerlink\" title=\"组件化\"></a>组件化</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div id=&quot;app&quot;&gt;</div><div class=\"line\">    &lt;ol&gt;</div><div class=\"line\">        &lt;todo-item v-for=&quot;item in list&quot; v-bind:todo=&quot;item&quot;&gt;&lt;/todo-item&gt;</div><div class=\"line\">    &lt;/ol&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">Vue.component(&apos;todo-item&apos;, &#123;</div><div class=\"line\">    props: [&apos;todo&apos;], //接受一个自定义属性todo</div><div class=\"line\">    template: &apos;&lt;li&gt;&#123;&#123; todo.text &#125;&#125;&lt;/li&gt;&apos;</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">var app = new Vue(&#123;</div><div class=\"line\">    el:&apos;#app&apos;,</div><div class=\"line\">    data: &#123;</div><div class=\"line\">        list : [</div><div class=\"line\">            &#123; text: &apos;apple&apos; &#125;,</div><div class=\"line\">            &#123; text: &apos;banana&apos; &#125;,</div><div class=\"line\">            &#123; text: &apos;orange&apos; &#125;</div><div class=\"line\">        ]</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>注意，在这个例子中 v-for 循环渲染子组件 todo-item ，并传递了 item 变量。接着 v-bind 指令将 item 与子组件的 todo 属性绑定起来，接受到 todo 属性的子组件读取 todo.text 插入到 &lt;li&gt; 中。整个过程，父组件向子组件单向传递数据并渲染出来。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><h3 id=\"指令\"><a href=\"#指令\" class=\"headerlink\" title=\"指令\"></a>指令</h3><ul>\n<li>v-bind:name </li>\n<li>v-if </li>\n<li>v-for</li>\n<li>v-on</li>\n<li>v-model</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://cn.vuejs.org/v2/guide/\" target=\"_blank\" rel=\"external\">https://cn.vuejs.org/v2/guide/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Vue-是什么？\"><a href=\"#Vue-是什么？\" class=\"headerlink\" title=\"Vue 是什么？\"></a>Vue 是什么？</h2><p>Vue 是一套构建用户界面的渐进式框架，采用自底向上增量开发的设计。Vue 的核心库值关注视图层（View）。</p>\n<h2 id=\"声明式渲染\"><a href=\"#声明式渲染\" class=\"headerlink\" title=\"声明式渲染\"></a>声明式渲染</h2><h3 id=\"文本插值\"><a href=\"#文本插值\" class=\"headerlink\" title=\"文本插值\"></a>文本插值</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div id=&quot;app&quot;&gt;</div><div class=\"line\">    &#123;&#123; message &#125;&#125;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">var app = new Vue(&#123;</div><div class=\"line\">    el:&apos;#app&apos;,</div><div class=\"line\">    data: &#123;</div><div class=\"line\">        message: &apos;hello&apos;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h3 id=\"渲染-DOM-属性（-v-bind-name-指令）\"><a href=\"#渲染-DOM-属性（-v-bind-name-指令）\" class=\"headerlink\" title=\"渲染 DOM 属性（ v-bind:name 指令）\"></a>渲染 DOM 属性（ v-bind:name 指令）</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div id=&quot;app&quot;&gt;</div><div class=\"line\">    &lt;span v-bind:title=&quot;message&quot;&gt;</div><div class=\"line\">        鼠标悬停此处查看动态提示信息</div><div class=\"line\">    &lt;/span&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">var app = new Vue(&#123;</div><div class=\"line\">    el: &apos;#app&apos;,</div><div class=\"line\">    data: &#123;</div><div class=\"line\">        message: &apos;提示信息&apos;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>v-bind 属性被称为指令（指令带有前缀 v-，以表示他们是 Vue 提供的特殊属性）。这里该指令的作用是“将这个元素的 title 属性和 Vue 实例的 message 属性保持一致”。</p>\n<h2 id=\"条件与循环（-v-if-指令和-v-for-指令）\"><a href=\"#条件与循环（-v-if-指令和-v-for-指令）\" class=\"headerlink\" title=\"条件与循环（ v-if 指令和 v-for 指令）\"></a>条件与循环（ v-if 指令和 v-for 指令）</h2><h3 id=\"条件\"><a href=\"#条件\" class=\"headerlink\" title=\"条件\"></a>条件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div id=&quot;app&quot;&gt;</div><div class=\"line\">    &lt;p v-if=&quot;seen&quot;&gt;看到了没？&lt;/p&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">var app = new Vue(&#123;</div><div class=\"line\">    el: &apos;#app&apos;,</div><div class=\"line\">    data: &#123;</div><div class=\"line\">        seen: true</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h3 id=\"循环\"><a href=\"#循环\" class=\"headerlink\" title=\"循环\"></a>循环</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div id=&quot;app&quot;&gt;</div><div class=\"line\">    &lt;ol&gt;</div><div class=\"line\">        &lt;li v-for=&quot;todo in todos&quot;&gt;</div><div class=\"line\">            &#123;&#123; todo.text &#125;&#125;</div><div class=\"line\">        &lt;/li&gt;</div><div class=\"line\">    &lt;/ol&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">var app = new Vue(&#123;</div><div class=\"line\">    el: &apos;#app&apos;,</div><div class=\"line\">    data: &#123;</div><div class=\"line\">        todos:［</div><div class=\"line\">            &#123; text : &apos;吃饭&apos; &#125;,</div><div class=\"line\">            &#123; text : &apos;睡觉&apos; &#125;,</div><div class=\"line\">            &#123; text : &apos;打游戏&apos; &#125;</div><div class=\"line\">        ］</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h2 id=\"处理用户输入（-v-on-指令和-v-model-指令）\"><a href=\"#处理用户输入（-v-on-指令和-v-model-指令）\" class=\"headerlink\" title=\"处理用户输入（ v-on 指令和 v-model 指令）\"></a>处理用户输入（ v-on 指令和 v-model 指令）</h2><h3 id=\"事件监听器\"><a href=\"#事件监听器\" class=\"headerlink\" title=\"事件监听器\"></a>事件监听器</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div id=&quot;app&quot;&gt;</div><div class=\"line\">    &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;</div><div class=\"line\">    &lt;button v-on:click=&quot;reverseMessage&quot;&gt;逆转消息&lt;/</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">var app = new Vue(&#123;</div><div class=\"line\">    el:&apos;#app&apos;,</div><div class=\"line\">    data: &#123;</div><div class=\"line\">        message: &apos;hello&apos;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    methods: &#123;</div><div class=\"line\">        reverseMessage: function()&#123;</div><div class=\"line\">            this.message = this.message.split(&apos;&apos;).reverse().join()</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h3 id=\"双向绑定\"><a href=\"#双向绑定\" class=\"headerlink\" title=\"双向绑定\"></a>双向绑定</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div id=&quot;app&quot;&gt;</div><div class=\"line\">    &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;</div><div class=\"line\">    &lt;input v-model=&quot;message&quot; &gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">var app = new Vue(&#123;</div><div class=\"line\">    el: &apos;#app&apos;,</div><div class=\"line\">    data:&#123;</div><div class=\"line\">        message: &apos;hello&apos;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h2 id=\"组件化\"><a href=\"#组件化\" class=\"headerlink\" title=\"组件化\"></a>组件化</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div id=&quot;app&quot;&gt;</div><div class=\"line\">    &lt;ol&gt;</div><div class=\"line\">        &lt;todo-item v-for=&quot;item in list&quot; v-bind:todo=&quot;item&quot;&gt;&lt;/todo-item&gt;</div><div class=\"line\">    &lt;/ol&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">Vue.component(&apos;todo-item&apos;, &#123;</div><div class=\"line\">    props: [&apos;todo&apos;], //接受一个自定义属性todo</div><div class=\"line\">    template: &apos;&lt;li&gt;&#123;&#123; todo.text &#125;&#125;&lt;/li&gt;&apos;</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">var app = new Vue(&#123;</div><div class=\"line\">    el:&apos;#app&apos;,</div><div class=\"line\">    data: &#123;</div><div class=\"line\">        list : [</div><div class=\"line\">            &#123; text: &apos;apple&apos; &#125;,</div><div class=\"line\">            &#123; text: &apos;banana&apos; &#125;,</div><div class=\"line\">            &#123; text: &apos;orange&apos; &#125;</div><div class=\"line\">        ]</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>注意，在这个例子中 v-for 循环渲染子组件 todo-item ，并传递了 item 变量。接着 v-bind 指令将 item 与子组件的 todo 属性绑定起来，接受到 todo 属性的子组件读取 todo.text 插入到 &lt;li&gt; 中。整个过程，父组件向子组件单向传递数据并渲染出来。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><h3 id=\"指令\"><a href=\"#指令\" class=\"headerlink\" title=\"指令\"></a>指令</h3><ul>\n<li>v-bind:name </li>\n<li>v-if </li>\n<li>v-for</li>\n<li>v-on</li>\n<li>v-model</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://cn.vuejs.org/v2/guide/\" target=\"_blank\" rel=\"external\">https://cn.vuejs.org/v2/guide/</a></p>\n"},{"layout":"post","title":"CSS：什么是 BFC","date":"2017-07-05T12:00:00.000Z","_content":"\n## 什么是 BFC\n\nBFC，Block Formatting Context，直译为**块级格式化上下文**。\n\n在 BFC 中，HTML 元素按照一定的规则进行布局，并且不管其中的元素如何变换样式，均不会影响 BFC 外部的任何元素同样也不受外部任何元素的影响。\n\n## 触发 BFC 的方法\n\n### 0、the root element\n\n一个 HTML 文档本身就是一个 BFC 。\n\n### 1、float\n\nfloat 属性不为 none 时，即如果一个元素是浮动元素，那么它就是一个 BFC 。\n\n* float: left;\n* float: right;\n\n### 2、overflow\n\noverflow 属性不为 visible 时，即 overflow 为auto、scroll、hidden 时会形成一个 BFC 。\n\n* overflow: hidden;\n* overflow: scroll;\n* overflow: auto; \n\n### 3、display\n\ndisplay 属性为 table-cell、table-caption 或 inline-block 时也会触发 BFC。\n\n* display: table-cell;\n* display: table-caption;\n* display: inline-block;\n\n### 4、position\n\nposition 属性不为 relative 或 static 时，即 postion 为 absolute、fixed 时也会触发 BFC 。\n\n* position: absolute;\n* position: fixed;\n\n## BFC 的作用\n\n* 不让文字环绕浮动的兄弟元素（自适应布局）\n\n* 在有浮动子元素的情况下，不让父元素高度坍缩（包含浮动）\n\n* 让兄弟元素之间的外边距不重合（边距折叠）\n\n测试代码：[https://github.com/daixinye/practice/blob/master/HTML/BFC.html](https://github.com/daixinye/practice/blob/master/HTML/BFC.html)\n\n参考：\n\n[https://www.w3cplus.com/css/understanding-bfc-and-margin-collapse.html](https://www.w3cplus.com/css/understanding-bfc-and-margin-collapse.html)\n\n[http://www.zhangxinxu.com/wordpress/2015/02/css-deep-understand-flow-bfc-column-two-auto-layout/](http://www.zhangxinxu.com/wordpress/2015/02/css-deep-understand-flow-bfc-column-two-auto-layout/)\n\n[http://www.cnblogs.com/MockingBirdHome/p/3365346.html](http://www.cnblogs.com/MockingBirdHome/p/3365346.html)\n\n","source":"_posts/2017-07-05-CSS：什么是 BFC.md","raw":"---\nlayout: post\ntitle:  \"CSS：什么是 BFC\"\ndate:   2017-07-05 20:00:00 +0800\ntags: css\n---\n\n## 什么是 BFC\n\nBFC，Block Formatting Context，直译为**块级格式化上下文**。\n\n在 BFC 中，HTML 元素按照一定的规则进行布局，并且不管其中的元素如何变换样式，均不会影响 BFC 外部的任何元素同样也不受外部任何元素的影响。\n\n## 触发 BFC 的方法\n\n### 0、the root element\n\n一个 HTML 文档本身就是一个 BFC 。\n\n### 1、float\n\nfloat 属性不为 none 时，即如果一个元素是浮动元素，那么它就是一个 BFC 。\n\n* float: left;\n* float: right;\n\n### 2、overflow\n\noverflow 属性不为 visible 时，即 overflow 为auto、scroll、hidden 时会形成一个 BFC 。\n\n* overflow: hidden;\n* overflow: scroll;\n* overflow: auto; \n\n### 3、display\n\ndisplay 属性为 table-cell、table-caption 或 inline-block 时也会触发 BFC。\n\n* display: table-cell;\n* display: table-caption;\n* display: inline-block;\n\n### 4、position\n\nposition 属性不为 relative 或 static 时，即 postion 为 absolute、fixed 时也会触发 BFC 。\n\n* position: absolute;\n* position: fixed;\n\n## BFC 的作用\n\n* 不让文字环绕浮动的兄弟元素（自适应布局）\n\n* 在有浮动子元素的情况下，不让父元素高度坍缩（包含浮动）\n\n* 让兄弟元素之间的外边距不重合（边距折叠）\n\n测试代码：[https://github.com/daixinye/practice/blob/master/HTML/BFC.html](https://github.com/daixinye/practice/blob/master/HTML/BFC.html)\n\n参考：\n\n[https://www.w3cplus.com/css/understanding-bfc-and-margin-collapse.html](https://www.w3cplus.com/css/understanding-bfc-and-margin-collapse.html)\n\n[http://www.zhangxinxu.com/wordpress/2015/02/css-deep-understand-flow-bfc-column-two-auto-layout/](http://www.zhangxinxu.com/wordpress/2015/02/css-deep-understand-flow-bfc-column-two-auto-layout/)\n\n[http://www.cnblogs.com/MockingBirdHome/p/3365346.html](http://www.cnblogs.com/MockingBirdHome/p/3365346.html)\n\n","slug":"2017-07-05-CSS：什么是 BFC","published":1,"updated":"2017-08-06T12:15:50.000Z","_id":"cj60bzxlc001b1dorxzhocf2j","comments":1,"photos":[],"link":"","content":"<h2 id=\"什么是-BFC\"><a href=\"#什么是-BFC\" class=\"headerlink\" title=\"什么是 BFC\"></a>什么是 BFC</h2><p>BFC，Block Formatting Context，直译为<strong>块级格式化上下文</strong>。</p>\n<p>在 BFC 中，HTML 元素按照一定的规则进行布局，并且不管其中的元素如何变换样式，均不会影响 BFC 外部的任何元素同样也不受外部任何元素的影响。</p>\n<h2 id=\"触发-BFC-的方法\"><a href=\"#触发-BFC-的方法\" class=\"headerlink\" title=\"触发 BFC 的方法\"></a>触发 BFC 的方法</h2><h3 id=\"0、the-root-element\"><a href=\"#0、the-root-element\" class=\"headerlink\" title=\"0、the root element\"></a>0、the root element</h3><p>一个 HTML 文档本身就是一个 BFC 。</p>\n<h3 id=\"1、float\"><a href=\"#1、float\" class=\"headerlink\" title=\"1、float\"></a>1、float</h3><p>float 属性不为 none 时，即如果一个元素是浮动元素，那么它就是一个 BFC 。</p>\n<ul>\n<li>float: left;</li>\n<li>float: right;</li>\n</ul>\n<h3 id=\"2、overflow\"><a href=\"#2、overflow\" class=\"headerlink\" title=\"2、overflow\"></a>2、overflow</h3><p>overflow 属性不为 visible 时，即 overflow 为auto、scroll、hidden 时会形成一个 BFC 。</p>\n<ul>\n<li>overflow: hidden;</li>\n<li>overflow: scroll;</li>\n<li>overflow: auto; </li>\n</ul>\n<h3 id=\"3、display\"><a href=\"#3、display\" class=\"headerlink\" title=\"3、display\"></a>3、display</h3><p>display 属性为 table-cell、table-caption 或 inline-block 时也会触发 BFC。</p>\n<ul>\n<li>display: table-cell;</li>\n<li>display: table-caption;</li>\n<li>display: inline-block;</li>\n</ul>\n<h3 id=\"4、position\"><a href=\"#4、position\" class=\"headerlink\" title=\"4、position\"></a>4、position</h3><p>position 属性不为 relative 或 static 时，即 postion 为 absolute、fixed 时也会触发 BFC 。</p>\n<ul>\n<li>position: absolute;</li>\n<li>position: fixed;</li>\n</ul>\n<h2 id=\"BFC-的作用\"><a href=\"#BFC-的作用\" class=\"headerlink\" title=\"BFC 的作用\"></a>BFC 的作用</h2><ul>\n<li><p>不让文字环绕浮动的兄弟元素（自适应布局）</p>\n</li>\n<li><p>在有浮动子元素的情况下，不让父元素高度坍缩（包含浮动）</p>\n</li>\n<li><p>让兄弟元素之间的外边距不重合（边距折叠）</p>\n</li>\n</ul>\n<p>测试代码：<a href=\"https://github.com/daixinye/practice/blob/master/HTML/BFC.html\" target=\"_blank\" rel=\"external\">https://github.com/daixinye/practice/blob/master/HTML/BFC.html</a></p>\n<p>参考：</p>\n<p><a href=\"https://www.w3cplus.com/css/understanding-bfc-and-margin-collapse.html\" target=\"_blank\" rel=\"external\">https://www.w3cplus.com/css/understanding-bfc-and-margin-collapse.html</a></p>\n<p><a href=\"http://www.zhangxinxu.com/wordpress/2015/02/css-deep-understand-flow-bfc-column-two-auto-layout/\" target=\"_blank\" rel=\"external\">http://www.zhangxinxu.com/wordpress/2015/02/css-deep-understand-flow-bfc-column-two-auto-layout/</a></p>\n<p><a href=\"http://www.cnblogs.com/MockingBirdHome/p/3365346.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/MockingBirdHome/p/3365346.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"什么是-BFC\"><a href=\"#什么是-BFC\" class=\"headerlink\" title=\"什么是 BFC\"></a>什么是 BFC</h2><p>BFC，Block Formatting Context，直译为<strong>块级格式化上下文</strong>。</p>\n<p>在 BFC 中，HTML 元素按照一定的规则进行布局，并且不管其中的元素如何变换样式，均不会影响 BFC 外部的任何元素同样也不受外部任何元素的影响。</p>\n<h2 id=\"触发-BFC-的方法\"><a href=\"#触发-BFC-的方法\" class=\"headerlink\" title=\"触发 BFC 的方法\"></a>触发 BFC 的方法</h2><h3 id=\"0、the-root-element\"><a href=\"#0、the-root-element\" class=\"headerlink\" title=\"0、the root element\"></a>0、the root element</h3><p>一个 HTML 文档本身就是一个 BFC 。</p>\n<h3 id=\"1、float\"><a href=\"#1、float\" class=\"headerlink\" title=\"1、float\"></a>1、float</h3><p>float 属性不为 none 时，即如果一个元素是浮动元素，那么它就是一个 BFC 。</p>\n<ul>\n<li>float: left;</li>\n<li>float: right;</li>\n</ul>\n<h3 id=\"2、overflow\"><a href=\"#2、overflow\" class=\"headerlink\" title=\"2、overflow\"></a>2、overflow</h3><p>overflow 属性不为 visible 时，即 overflow 为auto、scroll、hidden 时会形成一个 BFC 。</p>\n<ul>\n<li>overflow: hidden;</li>\n<li>overflow: scroll;</li>\n<li>overflow: auto; </li>\n</ul>\n<h3 id=\"3、display\"><a href=\"#3、display\" class=\"headerlink\" title=\"3、display\"></a>3、display</h3><p>display 属性为 table-cell、table-caption 或 inline-block 时也会触发 BFC。</p>\n<ul>\n<li>display: table-cell;</li>\n<li>display: table-caption;</li>\n<li>display: inline-block;</li>\n</ul>\n<h3 id=\"4、position\"><a href=\"#4、position\" class=\"headerlink\" title=\"4、position\"></a>4、position</h3><p>position 属性不为 relative 或 static 时，即 postion 为 absolute、fixed 时也会触发 BFC 。</p>\n<ul>\n<li>position: absolute;</li>\n<li>position: fixed;</li>\n</ul>\n<h2 id=\"BFC-的作用\"><a href=\"#BFC-的作用\" class=\"headerlink\" title=\"BFC 的作用\"></a>BFC 的作用</h2><ul>\n<li><p>不让文字环绕浮动的兄弟元素（自适应布局）</p>\n</li>\n<li><p>在有浮动子元素的情况下，不让父元素高度坍缩（包含浮动）</p>\n</li>\n<li><p>让兄弟元素之间的外边距不重合（边距折叠）</p>\n</li>\n</ul>\n<p>测试代码：<a href=\"https://github.com/daixinye/practice/blob/master/HTML/BFC.html\" target=\"_blank\" rel=\"external\">https://github.com/daixinye/practice/blob/master/HTML/BFC.html</a></p>\n<p>参考：</p>\n<p><a href=\"https://www.w3cplus.com/css/understanding-bfc-and-margin-collapse.html\" target=\"_blank\" rel=\"external\">https://www.w3cplus.com/css/understanding-bfc-and-margin-collapse.html</a></p>\n<p><a href=\"http://www.zhangxinxu.com/wordpress/2015/02/css-deep-understand-flow-bfc-column-two-auto-layout/\" target=\"_blank\" rel=\"external\">http://www.zhangxinxu.com/wordpress/2015/02/css-deep-understand-flow-bfc-column-two-auto-layout/</a></p>\n<p><a href=\"http://www.cnblogs.com/MockingBirdHome/p/3365346.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/MockingBirdHome/p/3365346.html</a></p>\n"},{"layout":"post","title":"Shell 脚本入门","date":"2017-07-06T12:00:00.000Z","_content":"\n在本文开始之前，我想先阐述一下本文的基本内容。\n\n本文的标题是《Shell 脚本入门》，内容将涵盖 如何写一个基本的 Shell 脚本、如何运行它、一些基本的流程控制和判断，以及更多可供参考学习的站点。\n\n那话不多说，让我们从一个最简单的 Shell 脚本开始吧~\n\n## 一、Hello World\n\n打开一个文本编辑器，输入以下脚本代码，保存为 helloworld.sh：\n\n```\n#!/bin/sh\n\n# it's just a demo\n\necho \"Hello World\"\n```\n\n接着，打开 命令行 ，切换至 helloworld.sh 所在目录，并输入以下命令：\n\n```\n$ /bin/sh helloworld.sh\n```\n\n可以看到，命令行中输出了 “哈喽沃德”：\n\n```\nHello World\n```\n\n好了，这就是我们使用一个 Shell 脚本的基本流程：编写脚本 =&gt; 运行脚本 =&gt; 运行结果。\n\n## 二、编写的三个要素\n\n观察一下我们的 helloworld.sh，我们可以把它分为三部分：指定程序、注释说明 以及 脚本命令。\n\n### 1、指定程序：`#!/bin/sh`\n\n符号 `#!` 用于指定运行该脚本使用的程序。\n\n在 helloworld.sh 中，我们用 `/bin/sh`来执行这个脚本。\n\n### 2、注释说明：`# it's just a demo`\n\n注释，以 `#` 开头的一行表示注释。\n\n```\n#!/bin/sh\n\n# 这里是注释 \n# 可以用来解释这个脚本是用来做什么的 \n\n######### 分割线 #############\n# 你也可以用多个#来做注释之间的分割\n#############################\n\necho \"Hello World\"\n```\n\n### 3、脚本命令： `echo \"Hello World\"`\n\n`echo`用于在命令行中打印指定的字符串。\n\n你可以用单引号、双引号将要打印的字符串包裹起来，也可以选择不用引号。\n\n## 三、运行的两个方式\n\n运行一个脚本，有两种方法：作为参数 或者是 作为可执行文件。\n\n### 1、作为参数\n\n```\n$ /bin/bash ./helloworld.sh\n```\n\n可以看到，我们通过给 `/bin/bash` 这个程序指定要运行的脚本，来运行 helloworld.sh 的。\n\n### 2、作为可执行文件\n\n首先，我们让这个脚本变成**可执行**的程序：\n\n```\n$ chmod +x helloworld.sh\n```\n\n接下来，就可以直接运行这个脚本：\n\n```\n$ ./helloworld.sh\n```\n\n## 四、小进阶\n\n在了解了基本的 Shell 编程之后，我们来让 Shell 脚本做更多的事情。\n\n### 1、读取输入\n\n```\n#!/bin/sh\n\n# read.sh\n\necho \"你的名字？\"\nread name\n\necho \"你好 $name，很高兴认识你。\"\n```\n\n运行一下：\n\n```\n$ /bin/sh read.sh \n你的名字？\n```\n\n输入 `daixinye`，回车：\n\n```\n你好daixinye，很高兴认识你。\n```\n\n### 2、条件判断\n\n```\n#!/bin/sh\n\n# if.sh\n\necho \"你的年龄？\"\nread age\n\n# 注意 等号左右两边 不能有空格\nmyAge=18\n\n# 注意 方括号内部前后 需要有空格\nif [ $age == $myAge ]\n    then \n        echo \"我们岁数一样哦\"\n    else \n        echo \"我们岁数不一样哦\" \nfi\n```\n\n运行一下：\n\n```\n$ /bin/sh if.sh \n你的年龄？\n```\n\n输入 `18`，回车：\n\n```\n我们岁数一样哦\n```\n\n### 3、条件循环\n\n```\n#!/bin/sh\n\n# while.sh\n\necho \"我有一个数字，你要来猜一下吗？1~1000哦\"\n\nanswer=666\nbingo=0\n\nwhile [ $bingo == 0 ]; do \n    read guess\n    if [ $guess == $answer ]\n        then\n            echo \"猜对啦\"\n            bingo=1\n        else\n            echo \"猜错啦，再猜一次吧？\"\n    fi\ndone\n```\n\n运行一下：\n\n```\n$ /bin/sh while.sh \n我有一个数字，你要来猜一下吗？1~1000哦\n```\n\n依次输入1、5、10、100、600、666 ：\n\n```\n1\n猜错啦，再猜一次吧？\n5\n猜错啦，再猜一次吧？\n10\n猜错啦，再猜一次吧？\n100\n猜错啦，再猜一次吧？\n600\n猜错啦，再猜一次吧？\n666\n猜对啦\n```\n\n## 五、小结\n\n好啦，通过本文你应该已经了解了以下几个知识点：\n\n1. 如何写一个基本 Shell脚本\n2. 如何打印内容（echo）\n3. 如何运行脚本（作为参数和作为可执行程序）\n4. 如何读取输入（read）\n5. 如何进行条件判断（if...else 语句）\n6. 如何进行条件循环（while... do 语句）\n\n## 本文参考\n\n[https://my.oschina.net/maczhao/blog/349452](https://my.oschina.net/maczhao/blog/349452)\n\n## 测试代码\n\n[https://github.com/daixinye/practice/tree/master/shell](https://github.com/daixinye/practice/tree/master/shell)\n\n\n\n\n\n","source":"_posts/2017-07-06-Shell 脚本入门.md","raw":"---\nlayout: post\ntitle:  \"Shell 脚本入门\"\ndate:   2017-07-06 20:00:00 +0800\ntags: shell\n---\n\n在本文开始之前，我想先阐述一下本文的基本内容。\n\n本文的标题是《Shell 脚本入门》，内容将涵盖 如何写一个基本的 Shell 脚本、如何运行它、一些基本的流程控制和判断，以及更多可供参考学习的站点。\n\n那话不多说，让我们从一个最简单的 Shell 脚本开始吧~\n\n## 一、Hello World\n\n打开一个文本编辑器，输入以下脚本代码，保存为 helloworld.sh：\n\n```\n#!/bin/sh\n\n# it's just a demo\n\necho \"Hello World\"\n```\n\n接着，打开 命令行 ，切换至 helloworld.sh 所在目录，并输入以下命令：\n\n```\n$ /bin/sh helloworld.sh\n```\n\n可以看到，命令行中输出了 “哈喽沃德”：\n\n```\nHello World\n```\n\n好了，这就是我们使用一个 Shell 脚本的基本流程：编写脚本 =&gt; 运行脚本 =&gt; 运行结果。\n\n## 二、编写的三个要素\n\n观察一下我们的 helloworld.sh，我们可以把它分为三部分：指定程序、注释说明 以及 脚本命令。\n\n### 1、指定程序：`#!/bin/sh`\n\n符号 `#!` 用于指定运行该脚本使用的程序。\n\n在 helloworld.sh 中，我们用 `/bin/sh`来执行这个脚本。\n\n### 2、注释说明：`# it's just a demo`\n\n注释，以 `#` 开头的一行表示注释。\n\n```\n#!/bin/sh\n\n# 这里是注释 \n# 可以用来解释这个脚本是用来做什么的 \n\n######### 分割线 #############\n# 你也可以用多个#来做注释之间的分割\n#############################\n\necho \"Hello World\"\n```\n\n### 3、脚本命令： `echo \"Hello World\"`\n\n`echo`用于在命令行中打印指定的字符串。\n\n你可以用单引号、双引号将要打印的字符串包裹起来，也可以选择不用引号。\n\n## 三、运行的两个方式\n\n运行一个脚本，有两种方法：作为参数 或者是 作为可执行文件。\n\n### 1、作为参数\n\n```\n$ /bin/bash ./helloworld.sh\n```\n\n可以看到，我们通过给 `/bin/bash` 这个程序指定要运行的脚本，来运行 helloworld.sh 的。\n\n### 2、作为可执行文件\n\n首先，我们让这个脚本变成**可执行**的程序：\n\n```\n$ chmod +x helloworld.sh\n```\n\n接下来，就可以直接运行这个脚本：\n\n```\n$ ./helloworld.sh\n```\n\n## 四、小进阶\n\n在了解了基本的 Shell 编程之后，我们来让 Shell 脚本做更多的事情。\n\n### 1、读取输入\n\n```\n#!/bin/sh\n\n# read.sh\n\necho \"你的名字？\"\nread name\n\necho \"你好 $name，很高兴认识你。\"\n```\n\n运行一下：\n\n```\n$ /bin/sh read.sh \n你的名字？\n```\n\n输入 `daixinye`，回车：\n\n```\n你好daixinye，很高兴认识你。\n```\n\n### 2、条件判断\n\n```\n#!/bin/sh\n\n# if.sh\n\necho \"你的年龄？\"\nread age\n\n# 注意 等号左右两边 不能有空格\nmyAge=18\n\n# 注意 方括号内部前后 需要有空格\nif [ $age == $myAge ]\n    then \n        echo \"我们岁数一样哦\"\n    else \n        echo \"我们岁数不一样哦\" \nfi\n```\n\n运行一下：\n\n```\n$ /bin/sh if.sh \n你的年龄？\n```\n\n输入 `18`，回车：\n\n```\n我们岁数一样哦\n```\n\n### 3、条件循环\n\n```\n#!/bin/sh\n\n# while.sh\n\necho \"我有一个数字，你要来猜一下吗？1~1000哦\"\n\nanswer=666\nbingo=0\n\nwhile [ $bingo == 0 ]; do \n    read guess\n    if [ $guess == $answer ]\n        then\n            echo \"猜对啦\"\n            bingo=1\n        else\n            echo \"猜错啦，再猜一次吧？\"\n    fi\ndone\n```\n\n运行一下：\n\n```\n$ /bin/sh while.sh \n我有一个数字，你要来猜一下吗？1~1000哦\n```\n\n依次输入1、5、10、100、600、666 ：\n\n```\n1\n猜错啦，再猜一次吧？\n5\n猜错啦，再猜一次吧？\n10\n猜错啦，再猜一次吧？\n100\n猜错啦，再猜一次吧？\n600\n猜错啦，再猜一次吧？\n666\n猜对啦\n```\n\n## 五、小结\n\n好啦，通过本文你应该已经了解了以下几个知识点：\n\n1. 如何写一个基本 Shell脚本\n2. 如何打印内容（echo）\n3. 如何运行脚本（作为参数和作为可执行程序）\n4. 如何读取输入（read）\n5. 如何进行条件判断（if...else 语句）\n6. 如何进行条件循环（while... do 语句）\n\n## 本文参考\n\n[https://my.oschina.net/maczhao/blog/349452](https://my.oschina.net/maczhao/blog/349452)\n\n## 测试代码\n\n[https://github.com/daixinye/practice/tree/master/shell](https://github.com/daixinye/practice/tree/master/shell)\n\n\n\n\n\n","slug":"2017-07-06-Shell 脚本入门","published":1,"updated":"2017-08-06T12:15:53.000Z","_id":"cj60bzxld001e1dorrcnda6ut","comments":1,"photos":[],"link":"","content":"<p>在本文开始之前，我想先阐述一下本文的基本内容。</p>\n<p>本文的标题是《Shell 脚本入门》，内容将涵盖 如何写一个基本的 Shell 脚本、如何运行它、一些基本的流程控制和判断，以及更多可供参考学习的站点。</p>\n<p>那话不多说，让我们从一个最简单的 Shell 脚本开始吧~</p>\n<h2 id=\"一、Hello-World\"><a href=\"#一、Hello-World\" class=\"headerlink\" title=\"一、Hello World\"></a>一、Hello World</h2><p>打开一个文本编辑器，输入以下脚本代码，保存为 helloworld.sh：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">#!/bin/sh</div><div class=\"line\"></div><div class=\"line\"># it&apos;s just a demo</div><div class=\"line\"></div><div class=\"line\">echo &quot;Hello World&quot;</div></pre></td></tr></table></figure>\n<p>接着，打开 命令行 ，切换至 helloworld.sh 所在目录，并输入以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ /bin/sh helloworld.sh</div></pre></td></tr></table></figure>\n<p>可以看到，命令行中输出了 “哈喽沃德”：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Hello World</div></pre></td></tr></table></figure>\n<p>好了，这就是我们使用一个 Shell 脚本的基本流程：编写脚本 =&gt; 运行脚本 =&gt; 运行结果。</p>\n<h2 id=\"二、编写的三个要素\"><a href=\"#二、编写的三个要素\" class=\"headerlink\" title=\"二、编写的三个要素\"></a>二、编写的三个要素</h2><p>观察一下我们的 helloworld.sh，我们可以把它分为三部分：指定程序、注释说明 以及 脚本命令。</p>\n<h3 id=\"1、指定程序：-bin-sh\"><a href=\"#1、指定程序：-bin-sh\" class=\"headerlink\" title=\"1、指定程序：#!/bin/sh\"></a>1、指定程序：<code>#!/bin/sh</code></h3><p>符号 <code>#!</code> 用于指定运行该脚本使用的程序。</p>\n<p>在 helloworld.sh 中，我们用 <code>/bin/sh</code>来执行这个脚本。</p>\n<h3 id=\"2、注释说明：-it-39-s-just-a-demo\"><a href=\"#2、注释说明：-it-39-s-just-a-demo\" class=\"headerlink\" title=\"2、注释说明：# it&#39;s just a demo\"></a>2、注释说明：<code># it&#39;s just a demo</code></h3><p>注释，以 <code>#</code> 开头的一行表示注释。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">#!/bin/sh</div><div class=\"line\"></div><div class=\"line\"># 这里是注释 </div><div class=\"line\"># 可以用来解释这个脚本是用来做什么的 </div><div class=\"line\"></div><div class=\"line\">######### 分割线 #############</div><div class=\"line\"># 你也可以用多个#来做注释之间的分割</div><div class=\"line\">#############################</div><div class=\"line\"></div><div class=\"line\">echo &quot;Hello World&quot;</div></pre></td></tr></table></figure>\n<h3 id=\"3、脚本命令：-echo-quot-Hello-World-quot\"><a href=\"#3、脚本命令：-echo-quot-Hello-World-quot\" class=\"headerlink\" title=\"3、脚本命令： echo &quot;Hello World&quot;\"></a>3、脚本命令： <code>echo &quot;Hello World&quot;</code></h3><p><code>echo</code>用于在命令行中打印指定的字符串。</p>\n<p>你可以用单引号、双引号将要打印的字符串包裹起来，也可以选择不用引号。</p>\n<h2 id=\"三、运行的两个方式\"><a href=\"#三、运行的两个方式\" class=\"headerlink\" title=\"三、运行的两个方式\"></a>三、运行的两个方式</h2><p>运行一个脚本，有两种方法：作为参数 或者是 作为可执行文件。</p>\n<h3 id=\"1、作为参数\"><a href=\"#1、作为参数\" class=\"headerlink\" title=\"1、作为参数\"></a>1、作为参数</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ /bin/bash ./helloworld.sh</div></pre></td></tr></table></figure>\n<p>可以看到，我们通过给 <code>/bin/bash</code> 这个程序指定要运行的脚本，来运行 helloworld.sh 的。</p>\n<h3 id=\"2、作为可执行文件\"><a href=\"#2、作为可执行文件\" class=\"headerlink\" title=\"2、作为可执行文件\"></a>2、作为可执行文件</h3><p>首先，我们让这个脚本变成<strong>可执行</strong>的程序：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ chmod +x helloworld.sh</div></pre></td></tr></table></figure>\n<p>接下来，就可以直接运行这个脚本：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ ./helloworld.sh</div></pre></td></tr></table></figure>\n<h2 id=\"四、小进阶\"><a href=\"#四、小进阶\" class=\"headerlink\" title=\"四、小进阶\"></a>四、小进阶</h2><p>在了解了基本的 Shell 编程之后，我们来让 Shell 脚本做更多的事情。</p>\n<h3 id=\"1、读取输入\"><a href=\"#1、读取输入\" class=\"headerlink\" title=\"1、读取输入\"></a>1、读取输入</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">#!/bin/sh</div><div class=\"line\"></div><div class=\"line\"># read.sh</div><div class=\"line\"></div><div class=\"line\">echo &quot;你的名字？&quot;</div><div class=\"line\">read name</div><div class=\"line\"></div><div class=\"line\">echo &quot;你好 $name，很高兴认识你。&quot;</div></pre></td></tr></table></figure>\n<p>运行一下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ /bin/sh read.sh </div><div class=\"line\">你的名字？</div></pre></td></tr></table></figure>\n<p>输入 <code>daixinye</code>，回车：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">你好daixinye，很高兴认识你。</div></pre></td></tr></table></figure>\n<h3 id=\"2、条件判断\"><a href=\"#2、条件判断\" class=\"headerlink\" title=\"2、条件判断\"></a>2、条件判断</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">#!/bin/sh</div><div class=\"line\"></div><div class=\"line\"># if.sh</div><div class=\"line\"></div><div class=\"line\">echo &quot;你的年龄？&quot;</div><div class=\"line\">read age</div><div class=\"line\"></div><div class=\"line\"># 注意 等号左右两边 不能有空格</div><div class=\"line\">myAge=18</div><div class=\"line\"></div><div class=\"line\"># 注意 方括号内部前后 需要有空格</div><div class=\"line\">if [ $age == $myAge ]</div><div class=\"line\">    then </div><div class=\"line\">        echo &quot;我们岁数一样哦&quot;</div><div class=\"line\">    else </div><div class=\"line\">        echo &quot;我们岁数不一样哦&quot; </div><div class=\"line\">fi</div></pre></td></tr></table></figure>\n<p>运行一下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ /bin/sh if.sh </div><div class=\"line\">你的年龄？</div></pre></td></tr></table></figure>\n<p>输入 <code>18</code>，回车：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">我们岁数一样哦</div></pre></td></tr></table></figure>\n<h3 id=\"3、条件循环\"><a href=\"#3、条件循环\" class=\"headerlink\" title=\"3、条件循环\"></a>3、条件循环</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">#!/bin/sh</div><div class=\"line\"></div><div class=\"line\"># while.sh</div><div class=\"line\"></div><div class=\"line\">echo &quot;我有一个数字，你要来猜一下吗？1~1000哦&quot;</div><div class=\"line\"></div><div class=\"line\">answer=666</div><div class=\"line\">bingo=0</div><div class=\"line\"></div><div class=\"line\">while [ $bingo == 0 ]; do </div><div class=\"line\">    read guess</div><div class=\"line\">    if [ $guess == $answer ]</div><div class=\"line\">        then</div><div class=\"line\">            echo &quot;猜对啦&quot;</div><div class=\"line\">            bingo=1</div><div class=\"line\">        else</div><div class=\"line\">            echo &quot;猜错啦，再猜一次吧？&quot;</div><div class=\"line\">    fi</div><div class=\"line\">done</div></pre></td></tr></table></figure>\n<p>运行一下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ /bin/sh while.sh </div><div class=\"line\">我有一个数字，你要来猜一下吗？1~1000哦</div></pre></td></tr></table></figure>\n<p>依次输入1、5、10、100、600、666 ：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">1</div><div class=\"line\">猜错啦，再猜一次吧？</div><div class=\"line\">5</div><div class=\"line\">猜错啦，再猜一次吧？</div><div class=\"line\">10</div><div class=\"line\">猜错啦，再猜一次吧？</div><div class=\"line\">100</div><div class=\"line\">猜错啦，再猜一次吧？</div><div class=\"line\">600</div><div class=\"line\">猜错啦，再猜一次吧？</div><div class=\"line\">666</div><div class=\"line\">猜对啦</div></pre></td></tr></table></figure>\n<h2 id=\"五、小结\"><a href=\"#五、小结\" class=\"headerlink\" title=\"五、小结\"></a>五、小结</h2><p>好啦，通过本文你应该已经了解了以下几个知识点：</p>\n<ol>\n<li>如何写一个基本 Shell脚本</li>\n<li>如何打印内容（echo）</li>\n<li>如何运行脚本（作为参数和作为可执行程序）</li>\n<li>如何读取输入（read）</li>\n<li>如何进行条件判断（if…else 语句）</li>\n<li>如何进行条件循环（while… do 语句）</li>\n</ol>\n<h2 id=\"本文参考\"><a href=\"#本文参考\" class=\"headerlink\" title=\"本文参考\"></a>本文参考</h2><p><a href=\"https://my.oschina.net/maczhao/blog/349452\" target=\"_blank\" rel=\"external\">https://my.oschina.net/maczhao/blog/349452</a></p>\n<h2 id=\"测试代码\"><a href=\"#测试代码\" class=\"headerlink\" title=\"测试代码\"></a>测试代码</h2><p><a href=\"https://github.com/daixinye/practice/tree/master/shell\" target=\"_blank\" rel=\"external\">https://github.com/daixinye/practice/tree/master/shell</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>在本文开始之前，我想先阐述一下本文的基本内容。</p>\n<p>本文的标题是《Shell 脚本入门》，内容将涵盖 如何写一个基本的 Shell 脚本、如何运行它、一些基本的流程控制和判断，以及更多可供参考学习的站点。</p>\n<p>那话不多说，让我们从一个最简单的 Shell 脚本开始吧~</p>\n<h2 id=\"一、Hello-World\"><a href=\"#一、Hello-World\" class=\"headerlink\" title=\"一、Hello World\"></a>一、Hello World</h2><p>打开一个文本编辑器，输入以下脚本代码，保存为 helloworld.sh：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">#!/bin/sh</div><div class=\"line\"></div><div class=\"line\"># it&apos;s just a demo</div><div class=\"line\"></div><div class=\"line\">echo &quot;Hello World&quot;</div></pre></td></tr></table></figure>\n<p>接着，打开 命令行 ，切换至 helloworld.sh 所在目录，并输入以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ /bin/sh helloworld.sh</div></pre></td></tr></table></figure>\n<p>可以看到，命令行中输出了 “哈喽沃德”：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Hello World</div></pre></td></tr></table></figure>\n<p>好了，这就是我们使用一个 Shell 脚本的基本流程：编写脚本 =&gt; 运行脚本 =&gt; 运行结果。</p>\n<h2 id=\"二、编写的三个要素\"><a href=\"#二、编写的三个要素\" class=\"headerlink\" title=\"二、编写的三个要素\"></a>二、编写的三个要素</h2><p>观察一下我们的 helloworld.sh，我们可以把它分为三部分：指定程序、注释说明 以及 脚本命令。</p>\n<h3 id=\"1、指定程序：-bin-sh\"><a href=\"#1、指定程序：-bin-sh\" class=\"headerlink\" title=\"1、指定程序：#!/bin/sh\"></a>1、指定程序：<code>#!/bin/sh</code></h3><p>符号 <code>#!</code> 用于指定运行该脚本使用的程序。</p>\n<p>在 helloworld.sh 中，我们用 <code>/bin/sh</code>来执行这个脚本。</p>\n<h3 id=\"2、注释说明：-it-39-s-just-a-demo\"><a href=\"#2、注释说明：-it-39-s-just-a-demo\" class=\"headerlink\" title=\"2、注释说明：# it&#39;s just a demo\"></a>2、注释说明：<code># it&#39;s just a demo</code></h3><p>注释，以 <code>#</code> 开头的一行表示注释。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">#!/bin/sh</div><div class=\"line\"></div><div class=\"line\"># 这里是注释 </div><div class=\"line\"># 可以用来解释这个脚本是用来做什么的 </div><div class=\"line\"></div><div class=\"line\">######### 分割线 #############</div><div class=\"line\"># 你也可以用多个#来做注释之间的分割</div><div class=\"line\">#############################</div><div class=\"line\"></div><div class=\"line\">echo &quot;Hello World&quot;</div></pre></td></tr></table></figure>\n<h3 id=\"3、脚本命令：-echo-quot-Hello-World-quot\"><a href=\"#3、脚本命令：-echo-quot-Hello-World-quot\" class=\"headerlink\" title=\"3、脚本命令： echo &quot;Hello World&quot;\"></a>3、脚本命令： <code>echo &quot;Hello World&quot;</code></h3><p><code>echo</code>用于在命令行中打印指定的字符串。</p>\n<p>你可以用单引号、双引号将要打印的字符串包裹起来，也可以选择不用引号。</p>\n<h2 id=\"三、运行的两个方式\"><a href=\"#三、运行的两个方式\" class=\"headerlink\" title=\"三、运行的两个方式\"></a>三、运行的两个方式</h2><p>运行一个脚本，有两种方法：作为参数 或者是 作为可执行文件。</p>\n<h3 id=\"1、作为参数\"><a href=\"#1、作为参数\" class=\"headerlink\" title=\"1、作为参数\"></a>1、作为参数</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ /bin/bash ./helloworld.sh</div></pre></td></tr></table></figure>\n<p>可以看到，我们通过给 <code>/bin/bash</code> 这个程序指定要运行的脚本，来运行 helloworld.sh 的。</p>\n<h3 id=\"2、作为可执行文件\"><a href=\"#2、作为可执行文件\" class=\"headerlink\" title=\"2、作为可执行文件\"></a>2、作为可执行文件</h3><p>首先，我们让这个脚本变成<strong>可执行</strong>的程序：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ chmod +x helloworld.sh</div></pre></td></tr></table></figure>\n<p>接下来，就可以直接运行这个脚本：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ ./helloworld.sh</div></pre></td></tr></table></figure>\n<h2 id=\"四、小进阶\"><a href=\"#四、小进阶\" class=\"headerlink\" title=\"四、小进阶\"></a>四、小进阶</h2><p>在了解了基本的 Shell 编程之后，我们来让 Shell 脚本做更多的事情。</p>\n<h3 id=\"1、读取输入\"><a href=\"#1、读取输入\" class=\"headerlink\" title=\"1、读取输入\"></a>1、读取输入</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">#!/bin/sh</div><div class=\"line\"></div><div class=\"line\"># read.sh</div><div class=\"line\"></div><div class=\"line\">echo &quot;你的名字？&quot;</div><div class=\"line\">read name</div><div class=\"line\"></div><div class=\"line\">echo &quot;你好 $name，很高兴认识你。&quot;</div></pre></td></tr></table></figure>\n<p>运行一下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ /bin/sh read.sh </div><div class=\"line\">你的名字？</div></pre></td></tr></table></figure>\n<p>输入 <code>daixinye</code>，回车：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">你好daixinye，很高兴认识你。</div></pre></td></tr></table></figure>\n<h3 id=\"2、条件判断\"><a href=\"#2、条件判断\" class=\"headerlink\" title=\"2、条件判断\"></a>2、条件判断</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">#!/bin/sh</div><div class=\"line\"></div><div class=\"line\"># if.sh</div><div class=\"line\"></div><div class=\"line\">echo &quot;你的年龄？&quot;</div><div class=\"line\">read age</div><div class=\"line\"></div><div class=\"line\"># 注意 等号左右两边 不能有空格</div><div class=\"line\">myAge=18</div><div class=\"line\"></div><div class=\"line\"># 注意 方括号内部前后 需要有空格</div><div class=\"line\">if [ $age == $myAge ]</div><div class=\"line\">    then </div><div class=\"line\">        echo &quot;我们岁数一样哦&quot;</div><div class=\"line\">    else </div><div class=\"line\">        echo &quot;我们岁数不一样哦&quot; </div><div class=\"line\">fi</div></pre></td></tr></table></figure>\n<p>运行一下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ /bin/sh if.sh </div><div class=\"line\">你的年龄？</div></pre></td></tr></table></figure>\n<p>输入 <code>18</code>，回车：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">我们岁数一样哦</div></pre></td></tr></table></figure>\n<h3 id=\"3、条件循环\"><a href=\"#3、条件循环\" class=\"headerlink\" title=\"3、条件循环\"></a>3、条件循环</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">#!/bin/sh</div><div class=\"line\"></div><div class=\"line\"># while.sh</div><div class=\"line\"></div><div class=\"line\">echo &quot;我有一个数字，你要来猜一下吗？1~1000哦&quot;</div><div class=\"line\"></div><div class=\"line\">answer=666</div><div class=\"line\">bingo=0</div><div class=\"line\"></div><div class=\"line\">while [ $bingo == 0 ]; do </div><div class=\"line\">    read guess</div><div class=\"line\">    if [ $guess == $answer ]</div><div class=\"line\">        then</div><div class=\"line\">            echo &quot;猜对啦&quot;</div><div class=\"line\">            bingo=1</div><div class=\"line\">        else</div><div class=\"line\">            echo &quot;猜错啦，再猜一次吧？&quot;</div><div class=\"line\">    fi</div><div class=\"line\">done</div></pre></td></tr></table></figure>\n<p>运行一下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ /bin/sh while.sh </div><div class=\"line\">我有一个数字，你要来猜一下吗？1~1000哦</div></pre></td></tr></table></figure>\n<p>依次输入1、5、10、100、600、666 ：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">1</div><div class=\"line\">猜错啦，再猜一次吧？</div><div class=\"line\">5</div><div class=\"line\">猜错啦，再猜一次吧？</div><div class=\"line\">10</div><div class=\"line\">猜错啦，再猜一次吧？</div><div class=\"line\">100</div><div class=\"line\">猜错啦，再猜一次吧？</div><div class=\"line\">600</div><div class=\"line\">猜错啦，再猜一次吧？</div><div class=\"line\">666</div><div class=\"line\">猜对啦</div></pre></td></tr></table></figure>\n<h2 id=\"五、小结\"><a href=\"#五、小结\" class=\"headerlink\" title=\"五、小结\"></a>五、小结</h2><p>好啦，通过本文你应该已经了解了以下几个知识点：</p>\n<ol>\n<li>如何写一个基本 Shell脚本</li>\n<li>如何打印内容（echo）</li>\n<li>如何运行脚本（作为参数和作为可执行程序）</li>\n<li>如何读取输入（read）</li>\n<li>如何进行条件判断（if…else 语句）</li>\n<li>如何进行条件循环（while… do 语句）</li>\n</ol>\n<h2 id=\"本文参考\"><a href=\"#本文参考\" class=\"headerlink\" title=\"本文参考\"></a>本文参考</h2><p><a href=\"https://my.oschina.net/maczhao/blog/349452\" target=\"_blank\" rel=\"external\">https://my.oschina.net/maczhao/blog/349452</a></p>\n<h2 id=\"测试代码\"><a href=\"#测试代码\" class=\"headerlink\" title=\"测试代码\"></a>测试代码</h2><p><a href=\"https://github.com/daixinye/practice/tree/master/shell\" target=\"_blank\" rel=\"external\">https://github.com/daixinye/practice/tree/master/shell</a></p>\n"},{"title":"JavaScript：Array 类型小结（1）","date":"2017-08-06T01:49:54.000Z","_content":"\n## 创建\n### 构造函数\n```\nnew Array(5) // 创建一个长度为 5 ，元素值均为 undefined 的数组\nnew Array(1, 2, 3) // 创建一个长度为 3 ，元素为 1、2、3 的数组\nnew Array('a', 'b', 'c') // 创建一个长度为 3 ，元素为 a、b、c 的数组\n```\n注意： new 关键字是不必要的。\n### 字面量\n字面量由若干个元素，以逗号分隔的形式包裹在一对方括号中：\n```\n[,,,,] // 相当于 new Array(5)\n[1, 2, 3] // 相当于 Array(1, 2, 3)\n['a', 'b', 'c'] // 相当于 Array('a', 'b', 'c')\n```\n\n## length 属性\n### 获取数组长度\n我们可以通过 `length` 属性来获取当前数组的长度：\n```\nlet list = [1, 2, 3]\nconsole.log(list.length) // 3\n```\n新增元素或删除元素都会动态的改变 length 的值。\n### 不仅仅是可读的\n`length` 除了可以获取当前数组的长度之外，其也可以用于增加或删除数组元素：\n```\nlet list = [1, 2, 3]\nconsole.log(list.length) // 3\n\nlist.length = 2;\nconsole.log(list) // 输出 1,2， 第3个元素被删除了\n\nlist.length = 4\nconsole.log(list) // 输出 1,2,undefined,undefined，新增了两个值为 undefined 的元素\n\nlist[list.length] = 5\nconsole.log(list) // 输出 1,2,undefined,undefined,5，通过length下标新增一个值为 5 的元素，与 list.push(5) 行为是一致的\n```\n### 不使用循环来创建值为 1,2,...n 的数组\n使用递归：\n```\nfunction producer(n,list =[]){\n\treturn list.length === n ? list : (list[list.length] = list.length + 1) && producer(n, list)\n}\nconsole.log(producer(5)); // 1,2,3,4,5\n```\n\n## 检测数组\n### instanceOf\n```\nnew Array() instanceOf Array // true\n```\n`操作数1 instanceof 操作数2` 操作符实际上做的行为是判断第一个操作数的的构造函数是否等于第二个。\n因此如果是在有多个全局环境的情况下（网页中有多个iframe），那么一个 iframe 的数组实例的构造函数不一定等于另一个 iframe 的 Array。\n所以这个方法存在一定的局限性。\n### Array.isArray()\n```\nlet value = new Array()\nArray.isArray(value) // true\n```\n不同于 `instanceof` 可能会受不同全局环境的影响， `isArray()` 方法在各种环境下都是可靠的，推荐使用 `isArray()` 来判断一个变量是否是数组的实例。\n\n## 转换方法\n### toString()\n在需要字符串的操作场合，都会调用数组的 `toString()` 方法，返回一个以逗号分隔的字符串：\n```\nlet value = new Array(1,2,3)\nconsole.log(value) // 打印的过程中调用了 value 的 toString 方法，输出 [1,2,3]\n```\n### join()\n我们可以通过 `join()` 方法来拼接数组元素，使其成为一个字符串：\n```\nlet value = new Array(1,2,3)\nconsole.log(value.join('&')) // 1&2&3\n```\n\n## 栈方法（LIFO）\n### push()\n`push()` 用于向数组的末尾添加一个元素：\n```\nlet value = new Array(1,2,3)\nvalue.push(4)\nconsole.log(value) // [1,2,3,4]\n```\n我们可以借助 length 属性来模拟这个行为：\n```\nlet value = new Array(1,2,3)\nvalue[value.length] = 4\nconsole.log(value) // [1,2,3,4]\n```\n### pop()\n`pop()` 方法用于移除数组末尾的元素：\n```\nlet value = new Array(1,2,3,4)\nvalue.pop()\nconsole.log(value) // [1,2,3]\n```\n\n\n## 队列方法（FIFO）\n### shift()\n`shift()` 能够移除并返回数组的第一项\n```\nlet value = new Array(1,2,3)\nlet shiftedNode = value.shift()\nconsole.log(value) // [2,3]\nconsole.log(shiftedNode) // 1\n```\n### unshift()\n`unshift()` 与 `shift()` 正好相反，后者用于移除，而前者用于添加若干个新元素到数组的前端，并返回新数组的长度：\n```\nlet value = new Array(1,2,3)\nvalue.unshift(-2,-1,0)\nconsole.log(value) // [-2,-1,0,1,2,3]\n```\n需要注意的是，`unshift()` 里的参数是从最右边开始逐个加到数组前端的。\n\n\n\n## 排序方法\n### reverse()\n`reverse()` 用于反转数组的顺序：\n```\nlet value = new Array(1,2,3)\nvalue.reverse()\nconsole.log(value) // [3,2,1]\n```\n### sort()\n`sort()` 方法用于排序，其默认排序为升序。\n需要注意的是，sort() 排序时会把所有的元素都转换成字符串进行比较，所以有个比较奇怪的现象如下：\n```\nlet value = new Array(1,2,3,11,22,33)\nvalue.sort()\nconsole.log(value) // 1,11,2,22,33\n```\n这时我们需要借助一个比较函数来对这个数组进行排序\n```\nfunction compare(before, after){\n    // 当返回负数时， before 会排在 after 前；返回正数时，before 会被放到 after 后面。\n    return before - after\n}\n\nlet value = new Array(1,2,3,11,22,33)\nvalue.sort(compare)\nconsole.log(value) // 1,2,3,11,22,33\n```\n\n## 操作方法\n### concat()\n`concat()` 用于连接两个数组：\n```\nlet value_1 = new Array(1,2,3)\nlet value_2 = new Array(4,5,6)\nlet result = value_1.concat(value_2)\nconsole.log(result) // [1,2,3,4,5,6]\n\n// 当 concat 没有被传入参数时， 返回的是原数组的一个副本，即 concat 可以用来浅拷贝一个数组\nlet value_copy = value_1.concat()\nconsole.log(value_copy) // [1,2,3,4,5,6]\n```\n需要注意的是，`concat()` 是不会影响原数组的。\n### slice()\n`slice()` 用来创建一个子数组，其接受两个参数，分别为起始下标和结束下标，当只传了起始下标时，会返回从这个起始下标开始的所有数组元素。\n需要注意的是，结束下标所在的元素并不会被包含到新的子数组中去：\n```\nlet value = new Array(1,2,3,4,5)\nconsole.log(value.slice(2)) // [3,4,5]\nconsole.log(value.slice(2, value.length)) // [3,4,5]\nconsole.log(value.slice(2,3)) // [3]\n```\n`slice()` 也不会影响原数组，也可以用于浅拷贝一个数组。\n### splice()\n`splice()` 可用于删除、插入和替换元素，其接受三个参数，分别为需要删除或插入的元素下标，需要删除的个数，以及需要插入的元素：\n```\nlet value = new Array(1,2,3)\n// 删除一个元素\nvalue.splice(0,1)\nconsole.log(value) // [2,3]\n// 插入一个元素\nvalue.splice(0,0,1.5)\nconsole.log(value) // [1.5,2,3]\n\n// 删除多个元素和插入多个元素\nvalue.splice(1,2, 2.5, 3.5)\nconsole.log(value) // [1.5, 2.5, 3.5]\n```\n`splice()` 会返回被删除的元素，与 `concat()`和 `slice()` 不同的是，`splice()` 是会直接影响原数组的。\n\n\n","source":"_posts/JavaScript：Array类型小结（1）.md","raw":"---\ntitle: JavaScript：Array 类型小结（1）\ndate: 2017-08-06 09:49:54\ntags: javascript\n---\n\n## 创建\n### 构造函数\n```\nnew Array(5) // 创建一个长度为 5 ，元素值均为 undefined 的数组\nnew Array(1, 2, 3) // 创建一个长度为 3 ，元素为 1、2、3 的数组\nnew Array('a', 'b', 'c') // 创建一个长度为 3 ，元素为 a、b、c 的数组\n```\n注意： new 关键字是不必要的。\n### 字面量\n字面量由若干个元素，以逗号分隔的形式包裹在一对方括号中：\n```\n[,,,,] // 相当于 new Array(5)\n[1, 2, 3] // 相当于 Array(1, 2, 3)\n['a', 'b', 'c'] // 相当于 Array('a', 'b', 'c')\n```\n\n## length 属性\n### 获取数组长度\n我们可以通过 `length` 属性来获取当前数组的长度：\n```\nlet list = [1, 2, 3]\nconsole.log(list.length) // 3\n```\n新增元素或删除元素都会动态的改变 length 的值。\n### 不仅仅是可读的\n`length` 除了可以获取当前数组的长度之外，其也可以用于增加或删除数组元素：\n```\nlet list = [1, 2, 3]\nconsole.log(list.length) // 3\n\nlist.length = 2;\nconsole.log(list) // 输出 1,2， 第3个元素被删除了\n\nlist.length = 4\nconsole.log(list) // 输出 1,2,undefined,undefined，新增了两个值为 undefined 的元素\n\nlist[list.length] = 5\nconsole.log(list) // 输出 1,2,undefined,undefined,5，通过length下标新增一个值为 5 的元素，与 list.push(5) 行为是一致的\n```\n### 不使用循环来创建值为 1,2,...n 的数组\n使用递归：\n```\nfunction producer(n,list =[]){\n\treturn list.length === n ? list : (list[list.length] = list.length + 1) && producer(n, list)\n}\nconsole.log(producer(5)); // 1,2,3,4,5\n```\n\n## 检测数组\n### instanceOf\n```\nnew Array() instanceOf Array // true\n```\n`操作数1 instanceof 操作数2` 操作符实际上做的行为是判断第一个操作数的的构造函数是否等于第二个。\n因此如果是在有多个全局环境的情况下（网页中有多个iframe），那么一个 iframe 的数组实例的构造函数不一定等于另一个 iframe 的 Array。\n所以这个方法存在一定的局限性。\n### Array.isArray()\n```\nlet value = new Array()\nArray.isArray(value) // true\n```\n不同于 `instanceof` 可能会受不同全局环境的影响， `isArray()` 方法在各种环境下都是可靠的，推荐使用 `isArray()` 来判断一个变量是否是数组的实例。\n\n## 转换方法\n### toString()\n在需要字符串的操作场合，都会调用数组的 `toString()` 方法，返回一个以逗号分隔的字符串：\n```\nlet value = new Array(1,2,3)\nconsole.log(value) // 打印的过程中调用了 value 的 toString 方法，输出 [1,2,3]\n```\n### join()\n我们可以通过 `join()` 方法来拼接数组元素，使其成为一个字符串：\n```\nlet value = new Array(1,2,3)\nconsole.log(value.join('&')) // 1&2&3\n```\n\n## 栈方法（LIFO）\n### push()\n`push()` 用于向数组的末尾添加一个元素：\n```\nlet value = new Array(1,2,3)\nvalue.push(4)\nconsole.log(value) // [1,2,3,4]\n```\n我们可以借助 length 属性来模拟这个行为：\n```\nlet value = new Array(1,2,3)\nvalue[value.length] = 4\nconsole.log(value) // [1,2,3,4]\n```\n### pop()\n`pop()` 方法用于移除数组末尾的元素：\n```\nlet value = new Array(1,2,3,4)\nvalue.pop()\nconsole.log(value) // [1,2,3]\n```\n\n\n## 队列方法（FIFO）\n### shift()\n`shift()` 能够移除并返回数组的第一项\n```\nlet value = new Array(1,2,3)\nlet shiftedNode = value.shift()\nconsole.log(value) // [2,3]\nconsole.log(shiftedNode) // 1\n```\n### unshift()\n`unshift()` 与 `shift()` 正好相反，后者用于移除，而前者用于添加若干个新元素到数组的前端，并返回新数组的长度：\n```\nlet value = new Array(1,2,3)\nvalue.unshift(-2,-1,0)\nconsole.log(value) // [-2,-1,0,1,2,3]\n```\n需要注意的是，`unshift()` 里的参数是从最右边开始逐个加到数组前端的。\n\n\n\n## 排序方法\n### reverse()\n`reverse()` 用于反转数组的顺序：\n```\nlet value = new Array(1,2,3)\nvalue.reverse()\nconsole.log(value) // [3,2,1]\n```\n### sort()\n`sort()` 方法用于排序，其默认排序为升序。\n需要注意的是，sort() 排序时会把所有的元素都转换成字符串进行比较，所以有个比较奇怪的现象如下：\n```\nlet value = new Array(1,2,3,11,22,33)\nvalue.sort()\nconsole.log(value) // 1,11,2,22,33\n```\n这时我们需要借助一个比较函数来对这个数组进行排序\n```\nfunction compare(before, after){\n    // 当返回负数时， before 会排在 after 前；返回正数时，before 会被放到 after 后面。\n    return before - after\n}\n\nlet value = new Array(1,2,3,11,22,33)\nvalue.sort(compare)\nconsole.log(value) // 1,2,3,11,22,33\n```\n\n## 操作方法\n### concat()\n`concat()` 用于连接两个数组：\n```\nlet value_1 = new Array(1,2,3)\nlet value_2 = new Array(4,5,6)\nlet result = value_1.concat(value_2)\nconsole.log(result) // [1,2,3,4,5,6]\n\n// 当 concat 没有被传入参数时， 返回的是原数组的一个副本，即 concat 可以用来浅拷贝一个数组\nlet value_copy = value_1.concat()\nconsole.log(value_copy) // [1,2,3,4,5,6]\n```\n需要注意的是，`concat()` 是不会影响原数组的。\n### slice()\n`slice()` 用来创建一个子数组，其接受两个参数，分别为起始下标和结束下标，当只传了起始下标时，会返回从这个起始下标开始的所有数组元素。\n需要注意的是，结束下标所在的元素并不会被包含到新的子数组中去：\n```\nlet value = new Array(1,2,3,4,5)\nconsole.log(value.slice(2)) // [3,4,5]\nconsole.log(value.slice(2, value.length)) // [3,4,5]\nconsole.log(value.slice(2,3)) // [3]\n```\n`slice()` 也不会影响原数组，也可以用于浅拷贝一个数组。\n### splice()\n`splice()` 可用于删除、插入和替换元素，其接受三个参数，分别为需要删除或插入的元素下标，需要删除的个数，以及需要插入的元素：\n```\nlet value = new Array(1,2,3)\n// 删除一个元素\nvalue.splice(0,1)\nconsole.log(value) // [2,3]\n// 插入一个元素\nvalue.splice(0,0,1.5)\nconsole.log(value) // [1.5,2,3]\n\n// 删除多个元素和插入多个元素\nvalue.splice(1,2, 2.5, 3.5)\nconsole.log(value) // [1.5, 2.5, 3.5]\n```\n`splice()` 会返回被删除的元素，与 `concat()`和 `slice()` 不同的是，`splice()` 是会直接影响原数组的。\n\n\n","slug":"JavaScript：Array类型小结（1）","published":1,"updated":"2017-08-06T12:11:59.000Z","_id":"cj60bzxlf001g1dors87vaiej","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h2><h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">new Array(5) // 创建一个长度为 5 ，元素值均为 undefined 的数组</div><div class=\"line\">new Array(1, 2, 3) // 创建一个长度为 3 ，元素为 1、2、3 的数组</div><div class=\"line\">new Array(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;) // 创建一个长度为 3 ，元素为 a、b、c 的数组</div></pre></td></tr></table></figure>\n<p>注意： new 关键字是不必要的。</p>\n<h3 id=\"字面量\"><a href=\"#字面量\" class=\"headerlink\" title=\"字面量\"></a>字面量</h3><p>字面量由若干个元素，以逗号分隔的形式包裹在一对方括号中：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">[,,,,] // 相当于 new Array(5)</div><div class=\"line\">[1, 2, 3] // 相当于 Array(1, 2, 3)</div><div class=\"line\">[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;] // 相当于 Array(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;)</div></pre></td></tr></table></figure></p>\n<h2 id=\"length-属性\"><a href=\"#length-属性\" class=\"headerlink\" title=\"length 属性\"></a>length 属性</h2><h3 id=\"获取数组长度\"><a href=\"#获取数组长度\" class=\"headerlink\" title=\"获取数组长度\"></a>获取数组长度</h3><p>我们可以通过 <code>length</code> 属性来获取当前数组的长度：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">let list = [1, 2, 3]</div><div class=\"line\">console.log(list.length) // 3</div></pre></td></tr></table></figure></p>\n<p>新增元素或删除元素都会动态的改变 length 的值。</p>\n<h3 id=\"不仅仅是可读的\"><a href=\"#不仅仅是可读的\" class=\"headerlink\" title=\"不仅仅是可读的\"></a>不仅仅是可读的</h3><p><code>length</code> 除了可以获取当前数组的长度之外，其也可以用于增加或删除数组元素：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">let list = [1, 2, 3]</div><div class=\"line\">console.log(list.length) // 3</div><div class=\"line\"></div><div class=\"line\">list.length = 2;</div><div class=\"line\">console.log(list) // 输出 1,2， 第3个元素被删除了</div><div class=\"line\"></div><div class=\"line\">list.length = 4</div><div class=\"line\">console.log(list) // 输出 1,2,undefined,undefined，新增了两个值为 undefined 的元素</div><div class=\"line\"></div><div class=\"line\">list[list.length] = 5</div><div class=\"line\">console.log(list) // 输出 1,2,undefined,undefined,5，通过length下标新增一个值为 5 的元素，与 list.push(5) 行为是一致的</div></pre></td></tr></table></figure></p>\n<h3 id=\"不使用循环来创建值为-1-2-…n-的数组\"><a href=\"#不使用循环来创建值为-1-2-…n-的数组\" class=\"headerlink\" title=\"不使用循环来创建值为 1,2,…n 的数组\"></a>不使用循环来创建值为 1,2,…n 的数组</h3><p>使用递归：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">function producer(n,list =[])&#123;</div><div class=\"line\">\treturn list.length === n ? list : (list[list.length] = list.length + 1) &amp;&amp; producer(n, list)</div><div class=\"line\">&#125;</div><div class=\"line\">console.log(producer(5)); // 1,2,3,4,5</div></pre></td></tr></table></figure></p>\n<h2 id=\"检测数组\"><a href=\"#检测数组\" class=\"headerlink\" title=\"检测数组\"></a>检测数组</h2><h3 id=\"instanceOf\"><a href=\"#instanceOf\" class=\"headerlink\" title=\"instanceOf\"></a>instanceOf</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">new Array() instanceOf Array // true</div></pre></td></tr></table></figure>\n<p><code>操作数1 instanceof 操作数2</code> 操作符实际上做的行为是判断第一个操作数的的构造函数是否等于第二个。<br>因此如果是在有多个全局环境的情况下（网页中有多个iframe），那么一个 iframe 的数组实例的构造函数不一定等于另一个 iframe 的 Array。<br>所以这个方法存在一定的局限性。</p>\n<h3 id=\"Array-isArray\"><a href=\"#Array-isArray\" class=\"headerlink\" title=\"Array.isArray()\"></a>Array.isArray()</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">let value = new Array()</div><div class=\"line\">Array.isArray(value) // true</div></pre></td></tr></table></figure>\n<p>不同于 <code>instanceof</code> 可能会受不同全局环境的影响， <code>isArray()</code> 方法在各种环境下都是可靠的，推荐使用 <code>isArray()</code> 来判断一个变量是否是数组的实例。</p>\n<h2 id=\"转换方法\"><a href=\"#转换方法\" class=\"headerlink\" title=\"转换方法\"></a>转换方法</h2><h3 id=\"toString-NaN\"><a href=\"#toString-NaN\" class=\"headerlink\" title=\"toString()\"></a>toString()</h3><p>在需要字符串的操作场合，都会调用数组的 <code>toString()</code> 方法，返回一个以逗号分隔的字符串：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">let value = new Array(1,2,3)</div><div class=\"line\">console.log(value) // 打印的过程中调用了 value 的 toString 方法，输出 [1,2,3]</div></pre></td></tr></table></figure></p>\n<h3 id=\"join\"><a href=\"#join\" class=\"headerlink\" title=\"join()\"></a>join()</h3><p>我们可以通过 <code>join()</code> 方法来拼接数组元素，使其成为一个字符串：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">let value = new Array(1,2,3)</div><div class=\"line\">console.log(value.join(&apos;&amp;&apos;)) // 1&amp;2&amp;3</div></pre></td></tr></table></figure></p>\n<h2 id=\"栈方法（LIFO）\"><a href=\"#栈方法（LIFO）\" class=\"headerlink\" title=\"栈方法（LIFO）\"></a>栈方法（LIFO）</h2><h3 id=\"push\"><a href=\"#push\" class=\"headerlink\" title=\"push()\"></a>push()</h3><p><code>push()</code> 用于向数组的末尾添加一个元素：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">let value = new Array(1,2,3)</div><div class=\"line\">value.push(4)</div><div class=\"line\">console.log(value) // [1,2,3,4]</div></pre></td></tr></table></figure></p>\n<p>我们可以借助 length 属性来模拟这个行为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">let value = new Array(1,2,3)</div><div class=\"line\">value[value.length] = 4</div><div class=\"line\">console.log(value) // [1,2,3,4]</div></pre></td></tr></table></figure></p>\n<h3 id=\"pop\"><a href=\"#pop\" class=\"headerlink\" title=\"pop()\"></a>pop()</h3><p><code>pop()</code> 方法用于移除数组末尾的元素：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">let value = new Array(1,2,3,4)</div><div class=\"line\">value.pop()</div><div class=\"line\">console.log(value) // [1,2,3]</div></pre></td></tr></table></figure></p>\n<h2 id=\"队列方法（FIFO）\"><a href=\"#队列方法（FIFO）\" class=\"headerlink\" title=\"队列方法（FIFO）\"></a>队列方法（FIFO）</h2><h3 id=\"shift\"><a href=\"#shift\" class=\"headerlink\" title=\"shift()\"></a>shift()</h3><p><code>shift()</code> 能够移除并返回数组的第一项<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">let value = new Array(1,2,3)</div><div class=\"line\">let shiftedNode = value.shift()</div><div class=\"line\">console.log(value) // [2,3]</div><div class=\"line\">console.log(shiftedNode) // 1</div></pre></td></tr></table></figure></p>\n<h3 id=\"unshift\"><a href=\"#unshift\" class=\"headerlink\" title=\"unshift()\"></a>unshift()</h3><p><code>unshift()</code> 与 <code>shift()</code> 正好相反，后者用于移除，而前者用于添加若干个新元素到数组的前端，并返回新数组的长度：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">let value = new Array(1,2,3)</div><div class=\"line\">value.unshift(-2,-1,0)</div><div class=\"line\">console.log(value) // [-2,-1,0,1,2,3]</div></pre></td></tr></table></figure></p>\n<p>需要注意的是，<code>unshift()</code> 里的参数是从最右边开始逐个加到数组前端的。</p>\n<h2 id=\"排序方法\"><a href=\"#排序方法\" class=\"headerlink\" title=\"排序方法\"></a>排序方法</h2><h3 id=\"reverse\"><a href=\"#reverse\" class=\"headerlink\" title=\"reverse()\"></a>reverse()</h3><p><code>reverse()</code> 用于反转数组的顺序：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">let value = new Array(1,2,3)</div><div class=\"line\">value.reverse()</div><div class=\"line\">console.log(value) // [3,2,1]</div></pre></td></tr></table></figure></p>\n<h3 id=\"sort\"><a href=\"#sort\" class=\"headerlink\" title=\"sort()\"></a>sort()</h3><p><code>sort()</code> 方法用于排序，其默认排序为升序。<br>需要注意的是，sort() 排序时会把所有的元素都转换成字符串进行比较，所以有个比较奇怪的现象如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">let value = new Array(1,2,3,11,22,33)</div><div class=\"line\">value.sort()</div><div class=\"line\">console.log(value) // 1,11,2,22,33</div></pre></td></tr></table></figure></p>\n<p>这时我们需要借助一个比较函数来对这个数组进行排序<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">function compare(before, after)&#123;</div><div class=\"line\">    // 当返回负数时， before 会排在 after 前；返回正数时，before 会被放到 after 后面。</div><div class=\"line\">    return before - after</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">let value = new Array(1,2,3,11,22,33)</div><div class=\"line\">value.sort(compare)</div><div class=\"line\">console.log(value) // 1,2,3,11,22,33</div></pre></td></tr></table></figure></p>\n<h2 id=\"操作方法\"><a href=\"#操作方法\" class=\"headerlink\" title=\"操作方法\"></a>操作方法</h2><h3 id=\"concat\"><a href=\"#concat\" class=\"headerlink\" title=\"concat()\"></a>concat()</h3><p><code>concat()</code> 用于连接两个数组：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">let value_1 = new Array(1,2,3)</div><div class=\"line\">let value_2 = new Array(4,5,6)</div><div class=\"line\">let result = value_1.concat(value_2)</div><div class=\"line\">console.log(result) // [1,2,3,4,5,6]</div><div class=\"line\"></div><div class=\"line\">// 当 concat 没有被传入参数时， 返回的是原数组的一个副本，即 concat 可以用来浅拷贝一个数组</div><div class=\"line\">let value_copy = value_1.concat()</div><div class=\"line\">console.log(value_copy) // [1,2,3,4,5,6]</div></pre></td></tr></table></figure></p>\n<p>需要注意的是，<code>concat()</code> 是不会影响原数组的。</p>\n<h3 id=\"slice\"><a href=\"#slice\" class=\"headerlink\" title=\"slice()\"></a>slice()</h3><p><code>slice()</code> 用来创建一个子数组，其接受两个参数，分别为起始下标和结束下标，当只传了起始下标时，会返回从这个起始下标开始的所有数组元素。<br>需要注意的是，结束下标所在的元素并不会被包含到新的子数组中去：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">let value = new Array(1,2,3,4,5)</div><div class=\"line\">console.log(value.slice(2)) // [3,4,5]</div><div class=\"line\">console.log(value.slice(2, value.length)) // [3,4,5]</div><div class=\"line\">console.log(value.slice(2,3)) // [3]</div></pre></td></tr></table></figure></p>\n<p><code>slice()</code> 也不会影响原数组，也可以用于浅拷贝一个数组。</p>\n<h3 id=\"splice\"><a href=\"#splice\" class=\"headerlink\" title=\"splice()\"></a>splice()</h3><p><code>splice()</code> 可用于删除、插入和替换元素，其接受三个参数，分别为需要删除或插入的元素下标，需要删除的个数，以及需要插入的元素：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">let value = new Array(1,2,3)</div><div class=\"line\">// 删除一个元素</div><div class=\"line\">value.splice(0,1)</div><div class=\"line\">console.log(value) // [2,3]</div><div class=\"line\">// 插入一个元素</div><div class=\"line\">value.splice(0,0,1.5)</div><div class=\"line\">console.log(value) // [1.5,2,3]</div><div class=\"line\"></div><div class=\"line\">// 删除多个元素和插入多个元素</div><div class=\"line\">value.splice(1,2, 2.5, 3.5)</div><div class=\"line\">console.log(value) // [1.5, 2.5, 3.5]</div></pre></td></tr></table></figure></p>\n<p><code>splice()</code> 会返回被删除的元素，与 <code>concat()</code>和 <code>slice()</code> 不同的是，<code>splice()</code> 是会直接影响原数组的。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h2><h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">new Array(5) // 创建一个长度为 5 ，元素值均为 undefined 的数组</div><div class=\"line\">new Array(1, 2, 3) // 创建一个长度为 3 ，元素为 1、2、3 的数组</div><div class=\"line\">new Array(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;) // 创建一个长度为 3 ，元素为 a、b、c 的数组</div></pre></td></tr></table></figure>\n<p>注意： new 关键字是不必要的。</p>\n<h3 id=\"字面量\"><a href=\"#字面量\" class=\"headerlink\" title=\"字面量\"></a>字面量</h3><p>字面量由若干个元素，以逗号分隔的形式包裹在一对方括号中：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">[,,,,] // 相当于 new Array(5)</div><div class=\"line\">[1, 2, 3] // 相当于 Array(1, 2, 3)</div><div class=\"line\">[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;] // 相当于 Array(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;)</div></pre></td></tr></table></figure></p>\n<h2 id=\"length-属性\"><a href=\"#length-属性\" class=\"headerlink\" title=\"length 属性\"></a>length 属性</h2><h3 id=\"获取数组长度\"><a href=\"#获取数组长度\" class=\"headerlink\" title=\"获取数组长度\"></a>获取数组长度</h3><p>我们可以通过 <code>length</code> 属性来获取当前数组的长度：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">let list = [1, 2, 3]</div><div class=\"line\">console.log(list.length) // 3</div></pre></td></tr></table></figure></p>\n<p>新增元素或删除元素都会动态的改变 length 的值。</p>\n<h3 id=\"不仅仅是可读的\"><a href=\"#不仅仅是可读的\" class=\"headerlink\" title=\"不仅仅是可读的\"></a>不仅仅是可读的</h3><p><code>length</code> 除了可以获取当前数组的长度之外，其也可以用于增加或删除数组元素：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">let list = [1, 2, 3]</div><div class=\"line\">console.log(list.length) // 3</div><div class=\"line\"></div><div class=\"line\">list.length = 2;</div><div class=\"line\">console.log(list) // 输出 1,2， 第3个元素被删除了</div><div class=\"line\"></div><div class=\"line\">list.length = 4</div><div class=\"line\">console.log(list) // 输出 1,2,undefined,undefined，新增了两个值为 undefined 的元素</div><div class=\"line\"></div><div class=\"line\">list[list.length] = 5</div><div class=\"line\">console.log(list) // 输出 1,2,undefined,undefined,5，通过length下标新增一个值为 5 的元素，与 list.push(5) 行为是一致的</div></pre></td></tr></table></figure></p>\n<h3 id=\"不使用循环来创建值为-1-2-…n-的数组\"><a href=\"#不使用循环来创建值为-1-2-…n-的数组\" class=\"headerlink\" title=\"不使用循环来创建值为 1,2,…n 的数组\"></a>不使用循环来创建值为 1,2,…n 的数组</h3><p>使用递归：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">function producer(n,list =[])&#123;</div><div class=\"line\">\treturn list.length === n ? list : (list[list.length] = list.length + 1) &amp;&amp; producer(n, list)</div><div class=\"line\">&#125;</div><div class=\"line\">console.log(producer(5)); // 1,2,3,4,5</div></pre></td></tr></table></figure></p>\n<h2 id=\"检测数组\"><a href=\"#检测数组\" class=\"headerlink\" title=\"检测数组\"></a>检测数组</h2><h3 id=\"instanceOf\"><a href=\"#instanceOf\" class=\"headerlink\" title=\"instanceOf\"></a>instanceOf</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">new Array() instanceOf Array // true</div></pre></td></tr></table></figure>\n<p><code>操作数1 instanceof 操作数2</code> 操作符实际上做的行为是判断第一个操作数的的构造函数是否等于第二个。<br>因此如果是在有多个全局环境的情况下（网页中有多个iframe），那么一个 iframe 的数组实例的构造函数不一定等于另一个 iframe 的 Array。<br>所以这个方法存在一定的局限性。</p>\n<h3 id=\"Array-isArray\"><a href=\"#Array-isArray\" class=\"headerlink\" title=\"Array.isArray()\"></a>Array.isArray()</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">let value = new Array()</div><div class=\"line\">Array.isArray(value) // true</div></pre></td></tr></table></figure>\n<p>不同于 <code>instanceof</code> 可能会受不同全局环境的影响， <code>isArray()</code> 方法在各种环境下都是可靠的，推荐使用 <code>isArray()</code> 来判断一个变量是否是数组的实例。</p>\n<h2 id=\"转换方法\"><a href=\"#转换方法\" class=\"headerlink\" title=\"转换方法\"></a>转换方法</h2><h3 id=\"toString-NaN\"><a href=\"#toString-NaN\" class=\"headerlink\" title=\"toString()\"></a>toString()</h3><p>在需要字符串的操作场合，都会调用数组的 <code>toString()</code> 方法，返回一个以逗号分隔的字符串：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">let value = new Array(1,2,3)</div><div class=\"line\">console.log(value) // 打印的过程中调用了 value 的 toString 方法，输出 [1,2,3]</div></pre></td></tr></table></figure></p>\n<h3 id=\"join\"><a href=\"#join\" class=\"headerlink\" title=\"join()\"></a>join()</h3><p>我们可以通过 <code>join()</code> 方法来拼接数组元素，使其成为一个字符串：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">let value = new Array(1,2,3)</div><div class=\"line\">console.log(value.join(&apos;&amp;&apos;)) // 1&amp;2&amp;3</div></pre></td></tr></table></figure></p>\n<h2 id=\"栈方法（LIFO）\"><a href=\"#栈方法（LIFO）\" class=\"headerlink\" title=\"栈方法（LIFO）\"></a>栈方法（LIFO）</h2><h3 id=\"push\"><a href=\"#push\" class=\"headerlink\" title=\"push()\"></a>push()</h3><p><code>push()</code> 用于向数组的末尾添加一个元素：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">let value = new Array(1,2,3)</div><div class=\"line\">value.push(4)</div><div class=\"line\">console.log(value) // [1,2,3,4]</div></pre></td></tr></table></figure></p>\n<p>我们可以借助 length 属性来模拟这个行为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">let value = new Array(1,2,3)</div><div class=\"line\">value[value.length] = 4</div><div class=\"line\">console.log(value) // [1,2,3,4]</div></pre></td></tr></table></figure></p>\n<h3 id=\"pop\"><a href=\"#pop\" class=\"headerlink\" title=\"pop()\"></a>pop()</h3><p><code>pop()</code> 方法用于移除数组末尾的元素：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">let value = new Array(1,2,3,4)</div><div class=\"line\">value.pop()</div><div class=\"line\">console.log(value) // [1,2,3]</div></pre></td></tr></table></figure></p>\n<h2 id=\"队列方法（FIFO）\"><a href=\"#队列方法（FIFO）\" class=\"headerlink\" title=\"队列方法（FIFO）\"></a>队列方法（FIFO）</h2><h3 id=\"shift\"><a href=\"#shift\" class=\"headerlink\" title=\"shift()\"></a>shift()</h3><p><code>shift()</code> 能够移除并返回数组的第一项<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">let value = new Array(1,2,3)</div><div class=\"line\">let shiftedNode = value.shift()</div><div class=\"line\">console.log(value) // [2,3]</div><div class=\"line\">console.log(shiftedNode) // 1</div></pre></td></tr></table></figure></p>\n<h3 id=\"unshift\"><a href=\"#unshift\" class=\"headerlink\" title=\"unshift()\"></a>unshift()</h3><p><code>unshift()</code> 与 <code>shift()</code> 正好相反，后者用于移除，而前者用于添加若干个新元素到数组的前端，并返回新数组的长度：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">let value = new Array(1,2,3)</div><div class=\"line\">value.unshift(-2,-1,0)</div><div class=\"line\">console.log(value) // [-2,-1,0,1,2,3]</div></pre></td></tr></table></figure></p>\n<p>需要注意的是，<code>unshift()</code> 里的参数是从最右边开始逐个加到数组前端的。</p>\n<h2 id=\"排序方法\"><a href=\"#排序方法\" class=\"headerlink\" title=\"排序方法\"></a>排序方法</h2><h3 id=\"reverse\"><a href=\"#reverse\" class=\"headerlink\" title=\"reverse()\"></a>reverse()</h3><p><code>reverse()</code> 用于反转数组的顺序：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">let value = new Array(1,2,3)</div><div class=\"line\">value.reverse()</div><div class=\"line\">console.log(value) // [3,2,1]</div></pre></td></tr></table></figure></p>\n<h3 id=\"sort\"><a href=\"#sort\" class=\"headerlink\" title=\"sort()\"></a>sort()</h3><p><code>sort()</code> 方法用于排序，其默认排序为升序。<br>需要注意的是，sort() 排序时会把所有的元素都转换成字符串进行比较，所以有个比较奇怪的现象如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">let value = new Array(1,2,3,11,22,33)</div><div class=\"line\">value.sort()</div><div class=\"line\">console.log(value) // 1,11,2,22,33</div></pre></td></tr></table></figure></p>\n<p>这时我们需要借助一个比较函数来对这个数组进行排序<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">function compare(before, after)&#123;</div><div class=\"line\">    // 当返回负数时， before 会排在 after 前；返回正数时，before 会被放到 after 后面。</div><div class=\"line\">    return before - after</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">let value = new Array(1,2,3,11,22,33)</div><div class=\"line\">value.sort(compare)</div><div class=\"line\">console.log(value) // 1,2,3,11,22,33</div></pre></td></tr></table></figure></p>\n<h2 id=\"操作方法\"><a href=\"#操作方法\" class=\"headerlink\" title=\"操作方法\"></a>操作方法</h2><h3 id=\"concat\"><a href=\"#concat\" class=\"headerlink\" title=\"concat()\"></a>concat()</h3><p><code>concat()</code> 用于连接两个数组：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">let value_1 = new Array(1,2,3)</div><div class=\"line\">let value_2 = new Array(4,5,6)</div><div class=\"line\">let result = value_1.concat(value_2)</div><div class=\"line\">console.log(result) // [1,2,3,4,5,6]</div><div class=\"line\"></div><div class=\"line\">// 当 concat 没有被传入参数时， 返回的是原数组的一个副本，即 concat 可以用来浅拷贝一个数组</div><div class=\"line\">let value_copy = value_1.concat()</div><div class=\"line\">console.log(value_copy) // [1,2,3,4,5,6]</div></pre></td></tr></table></figure></p>\n<p>需要注意的是，<code>concat()</code> 是不会影响原数组的。</p>\n<h3 id=\"slice\"><a href=\"#slice\" class=\"headerlink\" title=\"slice()\"></a>slice()</h3><p><code>slice()</code> 用来创建一个子数组，其接受两个参数，分别为起始下标和结束下标，当只传了起始下标时，会返回从这个起始下标开始的所有数组元素。<br>需要注意的是，结束下标所在的元素并不会被包含到新的子数组中去：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">let value = new Array(1,2,3,4,5)</div><div class=\"line\">console.log(value.slice(2)) // [3,4,5]</div><div class=\"line\">console.log(value.slice(2, value.length)) // [3,4,5]</div><div class=\"line\">console.log(value.slice(2,3)) // [3]</div></pre></td></tr></table></figure></p>\n<p><code>slice()</code> 也不会影响原数组，也可以用于浅拷贝一个数组。</p>\n<h3 id=\"splice\"><a href=\"#splice\" class=\"headerlink\" title=\"splice()\"></a>splice()</h3><p><code>splice()</code> 可用于删除、插入和替换元素，其接受三个参数，分别为需要删除或插入的元素下标，需要删除的个数，以及需要插入的元素：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">let value = new Array(1,2,3)</div><div class=\"line\">// 删除一个元素</div><div class=\"line\">value.splice(0,1)</div><div class=\"line\">console.log(value) // [2,3]</div><div class=\"line\">// 插入一个元素</div><div class=\"line\">value.splice(0,0,1.5)</div><div class=\"line\">console.log(value) // [1.5,2,3]</div><div class=\"line\"></div><div class=\"line\">// 删除多个元素和插入多个元素</div><div class=\"line\">value.splice(1,2, 2.5, 3.5)</div><div class=\"line\">console.log(value) // [1.5, 2.5, 3.5]</div></pre></td></tr></table></figure></p>\n<p><code>splice()</code> 会返回被删除的元素，与 <code>concat()</code>和 <code>slice()</code> 不同的是，<code>splice()</code> 是会直接影响原数组的。</p>\n"},{"title":"JavaScript：Array类型小结（2）","date":"2017-08-06T06:11:52.000Z","_content":"\n承接 JavaScript：Array类型小结（1）\n\n## 位置方法\n### indexOf()\n`indexOf()` 方法用于从前往后查找元素，当没有查找到该元素时，会返回 -1。\n此外，indexOf() 不会对传入的查找元素进行类型转换，在进行对比时会使用全等（===）的方式进行比较：\n```\nlet value = [1,2,3,4,5] \nconsole.log(value.indexOf(3)) // 2\nconsole.log(value.indexOf(4)) // -1\nconsole.log(value.indexOf('3')) // -1\n```\n我们可以再传入一个参数来指定从第几项（从0开始）开始进行查找（查找包含起始的元素）：\n```\nlet value = [1,2,3,4,5]\nconsole.log(value.indexOf(3,2)) // 3\nconsole.log(value.indexOf(2,2)) // -1\n```\n### lastIndexOf()\n`lastIndexOf()` 方法用于从后往前查找元素，用法与 `indexOf()` 基本一致：\n```\nlet value = [1,1,2,2,3,3]\nconsole.log(value.lastIndexOf(1)) // 1\nconsole.log(value.lastIndexOf(3)) // 5\nconsole.log(value.lastIndexOf(2,1)) // -1，代表从第1项开始往前查找\n```\n\n## 迭代方法\n### forEach\n`forEach()` 对数组中每一项运行指定函数，没有返回值。等同于 `for` 语句：\n```\nlet value = [1,2,3,4,5]\nvalue.forEach( (item, index) => {\n    console.log(item, index)\n})\n// 输出\n// 1 0\n// 2 1\n// 3 2\n// 4 3\n// 5 4\n```\n### every\n`every()` 对数组每一项运行指定函数，若对任意所有函数都返回 `true`， 则返回 `true`。与逻辑与操作符很相似：\n```\nlet value = [1,2,3,4,5]\nvalue.every( item => {\n    return item > 0\n}) // true\n```\n### some\n`some()` 对数组每一项运行指定函数，若存在函数返回 `true`，则返回 `true`。与逻辑或操作符很相似：\n```\nlet value = [1,2,3,4,5]\nvalue.some( item => {\n    return item > 4\n}) // true\n```\n### map\n`map()` 对数组每一项运行指定函数，返回由每一项函数的返回值组成的新数组：\n```\nlet value = [1,2,3,4,5]\nvalue.map( item => {\n    return item + 1\n}) // [2,3,4,5,6]\n```\n### filter\n`filter()` 对数组每一项运行指定函数，返回每一项函数返回值为 `true` 的项组成的新数组：\n```\nlet value = [1,2,3,4,5]\nvalue.map( item => {\n    return item < 3\n}) // [1,2]\n```\n\n## 归并方法\n### reduce()\n`reduce()` 接受一个函数，函数接受4个参数，分别是 前一个值，当前值，项的索引和数组对象。\n`reduce()` 方法能够遍历整个数组，并将上一个函数的返回值作为第一个参数传给下一个函数：\nlet value = [1,2,3,4,5]\nlet sum = value.reduce((prev, cur, index, array){\n    return prev + cur\n})\nconsole.log(sum ) // 15\n### reduceRight()\n`reduceRight()` 与 `reduce()` 基本一致，只是前者从后向前归并。\n\n## ES6 新方法（部分）\n### Array.of()\n`Array.of()` 方法用于创建一个数组。\n之前我们提到，创建数组的方式由两种，一是通过构造函数，二是通过字面量的形式。\n然而通过构造函数的方式有一个令人迷惑的地方：\n```\nlet array = new Array(2)\nconsole.log(array.length) // 2\nconsole.log(array) // [undefined, undefined]\n```\n当给构造函数传入一个数字时，构造函数会返回一个长度为该数字的数组，并用 undefined 填充。\n而当给构造函数传入一个字符串时，则会创建一个长度为1，元素为该字符串的数组：\n```\nlet array = new Array('2')\nconsole.log(array.length) // 1\nconsole.log(array) // ['2']\n```\n这样就让我们很难用构造函数来创建只有一个数字的数组了。\n\n为了让创建数组的行为更加一致， `Array.of()` 去除了数组构造函数当传入一个数字时的情况：\n```\nlet array = Array.of(2)\nconsole.log(array.length) // 1\nconsole.log(array.) // [2]\n```\n这样子，构造数组的方式就更加统一，无需我们去判断只传入一个参数时，参数的类型了。\n\n### Array.from()\n`Array.form()` 方法可以接受可迭代对象或类数组对象作为第一个参数，第二个参数接受一个映射函数，来对第一个参数中的每一个值进行映射转换：\n```\nvoid function f_1(){\n    let array = Array.from(arguments)\n    console.log(array)\n}(1,2,3,4) // [1,2,3,4]\n\nvoid function f_2(){\n    let array = Array.from(arguments, value => value + 1)\n    console.log(array)\n}(1,2,3,4) // [2,3,4,5]\n```\n### Array.find()\n`Array.find()` 方法接受一个函数作为参数，用于获取满足某一条件的数组元素：\n```\nlet value = [1,2,3,4,5]\nvalue.find(item => item > 3) // 4\n```\n### Array.findIndex()\n`Array.findIndex()` 与 `Array.find()` 的用法一致，只是前者返回的是查找到的元素下标：\n```\nlet value = [1,2,3,4,5]\nvalue.find(item => item > 3) // 3\n```\n### Array.fill()\n`Array.fill()` 可以用指定的值填充若干个数组元素。\n其接受三个参数，第一个参数是需要替换的值，第二个和第三个是起始下标和结束下标（不包含结束下标对应的值）\n```\nlet value = [1,2,3,4]\nvalue.fill(0) // [0,0,0,0]\n\nvalue.fill(-1, 1) // [0, -1, -1, -1]\nvalue.fill(-2, 1, 3) // [0, -2, -2, -1]\n```\n\n\n\n\n","source":"_posts/JavaScript：Array类型小结（2）.md","raw":"---\ntitle: JavaScript：Array类型小结（2）\ndate: 2017-08-06 14:11:52\ntags: javascript\n---\n\n承接 JavaScript：Array类型小结（1）\n\n## 位置方法\n### indexOf()\n`indexOf()` 方法用于从前往后查找元素，当没有查找到该元素时，会返回 -1。\n此外，indexOf() 不会对传入的查找元素进行类型转换，在进行对比时会使用全等（===）的方式进行比较：\n```\nlet value = [1,2,3,4,5] \nconsole.log(value.indexOf(3)) // 2\nconsole.log(value.indexOf(4)) // -1\nconsole.log(value.indexOf('3')) // -1\n```\n我们可以再传入一个参数来指定从第几项（从0开始）开始进行查找（查找包含起始的元素）：\n```\nlet value = [1,2,3,4,5]\nconsole.log(value.indexOf(3,2)) // 3\nconsole.log(value.indexOf(2,2)) // -1\n```\n### lastIndexOf()\n`lastIndexOf()` 方法用于从后往前查找元素，用法与 `indexOf()` 基本一致：\n```\nlet value = [1,1,2,2,3,3]\nconsole.log(value.lastIndexOf(1)) // 1\nconsole.log(value.lastIndexOf(3)) // 5\nconsole.log(value.lastIndexOf(2,1)) // -1，代表从第1项开始往前查找\n```\n\n## 迭代方法\n### forEach\n`forEach()` 对数组中每一项运行指定函数，没有返回值。等同于 `for` 语句：\n```\nlet value = [1,2,3,4,5]\nvalue.forEach( (item, index) => {\n    console.log(item, index)\n})\n// 输出\n// 1 0\n// 2 1\n// 3 2\n// 4 3\n// 5 4\n```\n### every\n`every()` 对数组每一项运行指定函数，若对任意所有函数都返回 `true`， 则返回 `true`。与逻辑与操作符很相似：\n```\nlet value = [1,2,3,4,5]\nvalue.every( item => {\n    return item > 0\n}) // true\n```\n### some\n`some()` 对数组每一项运行指定函数，若存在函数返回 `true`，则返回 `true`。与逻辑或操作符很相似：\n```\nlet value = [1,2,3,4,5]\nvalue.some( item => {\n    return item > 4\n}) // true\n```\n### map\n`map()` 对数组每一项运行指定函数，返回由每一项函数的返回值组成的新数组：\n```\nlet value = [1,2,3,4,5]\nvalue.map( item => {\n    return item + 1\n}) // [2,3,4,5,6]\n```\n### filter\n`filter()` 对数组每一项运行指定函数，返回每一项函数返回值为 `true` 的项组成的新数组：\n```\nlet value = [1,2,3,4,5]\nvalue.map( item => {\n    return item < 3\n}) // [1,2]\n```\n\n## 归并方法\n### reduce()\n`reduce()` 接受一个函数，函数接受4个参数，分别是 前一个值，当前值，项的索引和数组对象。\n`reduce()` 方法能够遍历整个数组，并将上一个函数的返回值作为第一个参数传给下一个函数：\nlet value = [1,2,3,4,5]\nlet sum = value.reduce((prev, cur, index, array){\n    return prev + cur\n})\nconsole.log(sum ) // 15\n### reduceRight()\n`reduceRight()` 与 `reduce()` 基本一致，只是前者从后向前归并。\n\n## ES6 新方法（部分）\n### Array.of()\n`Array.of()` 方法用于创建一个数组。\n之前我们提到，创建数组的方式由两种，一是通过构造函数，二是通过字面量的形式。\n然而通过构造函数的方式有一个令人迷惑的地方：\n```\nlet array = new Array(2)\nconsole.log(array.length) // 2\nconsole.log(array) // [undefined, undefined]\n```\n当给构造函数传入一个数字时，构造函数会返回一个长度为该数字的数组，并用 undefined 填充。\n而当给构造函数传入一个字符串时，则会创建一个长度为1，元素为该字符串的数组：\n```\nlet array = new Array('2')\nconsole.log(array.length) // 1\nconsole.log(array) // ['2']\n```\n这样就让我们很难用构造函数来创建只有一个数字的数组了。\n\n为了让创建数组的行为更加一致， `Array.of()` 去除了数组构造函数当传入一个数字时的情况：\n```\nlet array = Array.of(2)\nconsole.log(array.length) // 1\nconsole.log(array.) // [2]\n```\n这样子，构造数组的方式就更加统一，无需我们去判断只传入一个参数时，参数的类型了。\n\n### Array.from()\n`Array.form()` 方法可以接受可迭代对象或类数组对象作为第一个参数，第二个参数接受一个映射函数，来对第一个参数中的每一个值进行映射转换：\n```\nvoid function f_1(){\n    let array = Array.from(arguments)\n    console.log(array)\n}(1,2,3,4) // [1,2,3,4]\n\nvoid function f_2(){\n    let array = Array.from(arguments, value => value + 1)\n    console.log(array)\n}(1,2,3,4) // [2,3,4,5]\n```\n### Array.find()\n`Array.find()` 方法接受一个函数作为参数，用于获取满足某一条件的数组元素：\n```\nlet value = [1,2,3,4,5]\nvalue.find(item => item > 3) // 4\n```\n### Array.findIndex()\n`Array.findIndex()` 与 `Array.find()` 的用法一致，只是前者返回的是查找到的元素下标：\n```\nlet value = [1,2,3,4,5]\nvalue.find(item => item > 3) // 3\n```\n### Array.fill()\n`Array.fill()` 可以用指定的值填充若干个数组元素。\n其接受三个参数，第一个参数是需要替换的值，第二个和第三个是起始下标和结束下标（不包含结束下标对应的值）\n```\nlet value = [1,2,3,4]\nvalue.fill(0) // [0,0,0,0]\n\nvalue.fill(-1, 1) // [0, -1, -1, -1]\nvalue.fill(-2, 1, 3) // [0, -2, -2, -1]\n```\n\n\n\n\n","slug":"JavaScript：Array类型小结（2）","published":1,"updated":"2017-08-06T12:10:50.000Z","_id":"cj60bzxlg001j1dor37l1ieo9","comments":1,"layout":"post","photos":[],"link":"","content":"<p>承接 JavaScript：Array类型小结（1）</p>\n<h2 id=\"位置方法\"><a href=\"#位置方法\" class=\"headerlink\" title=\"位置方法\"></a>位置方法</h2><h3 id=\"indexOf\"><a href=\"#indexOf\" class=\"headerlink\" title=\"indexOf()\"></a>indexOf()</h3><p><code>indexOf()</code> 方法用于从前往后查找元素，当没有查找到该元素时，会返回 -1。<br>此外，indexOf() 不会对传入的查找元素进行类型转换，在进行对比时会使用全等（===）的方式进行比较：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">let value = [1,2,3,4,5] </div><div class=\"line\">console.log(value.indexOf(3)) // 2</div><div class=\"line\">console.log(value.indexOf(4)) // -1</div><div class=\"line\">console.log(value.indexOf(&apos;3&apos;)) // -1</div></pre></td></tr></table></figure></p>\n<p>我们可以再传入一个参数来指定从第几项（从0开始）开始进行查找（查找包含起始的元素）：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">let value = [1,2,3,4,5]</div><div class=\"line\">console.log(value.indexOf(3,2)) // 3</div><div class=\"line\">console.log(value.indexOf(2,2)) // -1</div></pre></td></tr></table></figure></p>\n<h3 id=\"lastIndexOf\"><a href=\"#lastIndexOf\" class=\"headerlink\" title=\"lastIndexOf()\"></a>lastIndexOf()</h3><p><code>lastIndexOf()</code> 方法用于从后往前查找元素，用法与 <code>indexOf()</code> 基本一致：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">let value = [1,1,2,2,3,3]</div><div class=\"line\">console.log(value.lastIndexOf(1)) // 1</div><div class=\"line\">console.log(value.lastIndexOf(3)) // 5</div><div class=\"line\">console.log(value.lastIndexOf(2,1)) // -1，代表从第1项开始往前查找</div></pre></td></tr></table></figure></p>\n<h2 id=\"迭代方法\"><a href=\"#迭代方法\" class=\"headerlink\" title=\"迭代方法\"></a>迭代方法</h2><h3 id=\"forEach\"><a href=\"#forEach\" class=\"headerlink\" title=\"forEach\"></a>forEach</h3><p><code>forEach()</code> 对数组中每一项运行指定函数，没有返回值。等同于 <code>for</code> 语句：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">let value = [1,2,3,4,5]</div><div class=\"line\">value.forEach( (item, index) =&gt; &#123;</div><div class=\"line\">    console.log(item, index)</div><div class=\"line\">&#125;)</div><div class=\"line\">// 输出</div><div class=\"line\">// 1 0</div><div class=\"line\">// 2 1</div><div class=\"line\">// 3 2</div><div class=\"line\">// 4 3</div><div class=\"line\">// 5 4</div></pre></td></tr></table></figure></p>\n<h3 id=\"every\"><a href=\"#every\" class=\"headerlink\" title=\"every\"></a>every</h3><p><code>every()</code> 对数组每一项运行指定函数，若对任意所有函数都返回 <code>true</code>， 则返回 <code>true</code>。与逻辑与操作符很相似：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">let value = [1,2,3,4,5]</div><div class=\"line\">value.every( item =&gt; &#123;</div><div class=\"line\">    return item &gt; 0</div><div class=\"line\">&#125;) // true</div></pre></td></tr></table></figure></p>\n<h3 id=\"some\"><a href=\"#some\" class=\"headerlink\" title=\"some\"></a>some</h3><p><code>some()</code> 对数组每一项运行指定函数，若存在函数返回 <code>true</code>，则返回 <code>true</code>。与逻辑或操作符很相似：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">let value = [1,2,3,4,5]</div><div class=\"line\">value.some( item =&gt; &#123;</div><div class=\"line\">    return item &gt; 4</div><div class=\"line\">&#125;) // true</div></pre></td></tr></table></figure></p>\n<h3 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h3><p><code>map()</code> 对数组每一项运行指定函数，返回由每一项函数的返回值组成的新数组：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">let value = [1,2,3,4,5]</div><div class=\"line\">value.map( item =&gt; &#123;</div><div class=\"line\">    return item + 1</div><div class=\"line\">&#125;) // [2,3,4,5,6]</div></pre></td></tr></table></figure></p>\n<h3 id=\"filter\"><a href=\"#filter\" class=\"headerlink\" title=\"filter\"></a>filter</h3><p><code>filter()</code> 对数组每一项运行指定函数，返回每一项函数返回值为 <code>true</code> 的项组成的新数组：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">let value = [1,2,3,4,5]</div><div class=\"line\">value.map( item =&gt; &#123;</div><div class=\"line\">    return item &lt; 3</div><div class=\"line\">&#125;) // [1,2]</div></pre></td></tr></table></figure></p>\n<h2 id=\"归并方法\"><a href=\"#归并方法\" class=\"headerlink\" title=\"归并方法\"></a>归并方法</h2><h3 id=\"reduce\"><a href=\"#reduce\" class=\"headerlink\" title=\"reduce()\"></a>reduce()</h3><p><code>reduce()</code> 接受一个函数，函数接受4个参数，分别是 前一个值，当前值，项的索引和数组对象。<br><code>reduce()</code> 方法能够遍历整个数组，并将上一个函数的返回值作为第一个参数传给下一个函数：<br>let value = [1,2,3,4,5]<br>let sum = value.reduce((prev, cur, index, array){<br>    return prev + cur<br>})<br>console.log(sum ) // 15</p>\n<h3 id=\"reduceRight\"><a href=\"#reduceRight\" class=\"headerlink\" title=\"reduceRight()\"></a>reduceRight()</h3><p><code>reduceRight()</code> 与 <code>reduce()</code> 基本一致，只是前者从后向前归并。</p>\n<h2 id=\"ES6-新方法（部分）\"><a href=\"#ES6-新方法（部分）\" class=\"headerlink\" title=\"ES6 新方法（部分）\"></a>ES6 新方法（部分）</h2><h3 id=\"Array-of\"><a href=\"#Array-of\" class=\"headerlink\" title=\"Array.of()\"></a>Array.of()</h3><p><code>Array.of()</code> 方法用于创建一个数组。<br>之前我们提到，创建数组的方式由两种，一是通过构造函数，二是通过字面量的形式。<br>然而通过构造函数的方式有一个令人迷惑的地方：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">let array = new Array(2)</div><div class=\"line\">console.log(array.length) // 2</div><div class=\"line\">console.log(array) // [undefined, undefined]</div></pre></td></tr></table></figure></p>\n<p>当给构造函数传入一个数字时，构造函数会返回一个长度为该数字的数组，并用 undefined 填充。<br>而当给构造函数传入一个字符串时，则会创建一个长度为1，元素为该字符串的数组：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">let array = new Array(&apos;2&apos;)</div><div class=\"line\">console.log(array.length) // 1</div><div class=\"line\">console.log(array) // [&apos;2&apos;]</div></pre></td></tr></table></figure></p>\n<p>这样就让我们很难用构造函数来创建只有一个数字的数组了。</p>\n<p>为了让创建数组的行为更加一致， <code>Array.of()</code> 去除了数组构造函数当传入一个数字时的情况：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">let array = Array.of(2)</div><div class=\"line\">console.log(array.length) // 1</div><div class=\"line\">console.log(array.) // [2]</div></pre></td></tr></table></figure></p>\n<p>这样子，构造数组的方式就更加统一，无需我们去判断只传入一个参数时，参数的类型了。</p>\n<h3 id=\"Array-from\"><a href=\"#Array-from\" class=\"headerlink\" title=\"Array.from()\"></a>Array.from()</h3><p><code>Array.form()</code> 方法可以接受可迭代对象或类数组对象作为第一个参数，第二个参数接受一个映射函数，来对第一个参数中的每一个值进行映射转换：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">void function f_1()&#123;</div><div class=\"line\">    let array = Array.from(arguments)</div><div class=\"line\">    console.log(array)</div><div class=\"line\">&#125;(1,2,3,4) // [1,2,3,4]</div><div class=\"line\"></div><div class=\"line\">void function f_2()&#123;</div><div class=\"line\">    let array = Array.from(arguments, value =&gt; value + 1)</div><div class=\"line\">    console.log(array)</div><div class=\"line\">&#125;(1,2,3,4) // [2,3,4,5]</div></pre></td></tr></table></figure></p>\n<h3 id=\"Array-find\"><a href=\"#Array-find\" class=\"headerlink\" title=\"Array.find()\"></a>Array.find()</h3><p><code>Array.find()</code> 方法接受一个函数作为参数，用于获取满足某一条件的数组元素：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">let value = [1,2,3,4,5]</div><div class=\"line\">value.find(item =&gt; item &gt; 3) // 4</div></pre></td></tr></table></figure></p>\n<h3 id=\"Array-findIndex\"><a href=\"#Array-findIndex\" class=\"headerlink\" title=\"Array.findIndex()\"></a>Array.findIndex()</h3><p><code>Array.findIndex()</code> 与 <code>Array.find()</code> 的用法一致，只是前者返回的是查找到的元素下标：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">let value = [1,2,3,4,5]</div><div class=\"line\">value.find(item =&gt; item &gt; 3) // 3</div></pre></td></tr></table></figure></p>\n<h3 id=\"Array-fill\"><a href=\"#Array-fill\" class=\"headerlink\" title=\"Array.fill()\"></a>Array.fill()</h3><p><code>Array.fill()</code> 可以用指定的值填充若干个数组元素。<br>其接受三个参数，第一个参数是需要替换的值，第二个和第三个是起始下标和结束下标（不包含结束下标对应的值）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">let value = [1,2,3,4]</div><div class=\"line\">value.fill(0) // [0,0,0,0]</div><div class=\"line\"></div><div class=\"line\">value.fill(-1, 1) // [0, -1, -1, -1]</div><div class=\"line\">value.fill(-2, 1, 3) // [0, -2, -2, -1]</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>承接 JavaScript：Array类型小结（1）</p>\n<h2 id=\"位置方法\"><a href=\"#位置方法\" class=\"headerlink\" title=\"位置方法\"></a>位置方法</h2><h3 id=\"indexOf\"><a href=\"#indexOf\" class=\"headerlink\" title=\"indexOf()\"></a>indexOf()</h3><p><code>indexOf()</code> 方法用于从前往后查找元素，当没有查找到该元素时，会返回 -1。<br>此外，indexOf() 不会对传入的查找元素进行类型转换，在进行对比时会使用全等（===）的方式进行比较：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">let value = [1,2,3,4,5] </div><div class=\"line\">console.log(value.indexOf(3)) // 2</div><div class=\"line\">console.log(value.indexOf(4)) // -1</div><div class=\"line\">console.log(value.indexOf(&apos;3&apos;)) // -1</div></pre></td></tr></table></figure></p>\n<p>我们可以再传入一个参数来指定从第几项（从0开始）开始进行查找（查找包含起始的元素）：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">let value = [1,2,3,4,5]</div><div class=\"line\">console.log(value.indexOf(3,2)) // 3</div><div class=\"line\">console.log(value.indexOf(2,2)) // -1</div></pre></td></tr></table></figure></p>\n<h3 id=\"lastIndexOf\"><a href=\"#lastIndexOf\" class=\"headerlink\" title=\"lastIndexOf()\"></a>lastIndexOf()</h3><p><code>lastIndexOf()</code> 方法用于从后往前查找元素，用法与 <code>indexOf()</code> 基本一致：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">let value = [1,1,2,2,3,3]</div><div class=\"line\">console.log(value.lastIndexOf(1)) // 1</div><div class=\"line\">console.log(value.lastIndexOf(3)) // 5</div><div class=\"line\">console.log(value.lastIndexOf(2,1)) // -1，代表从第1项开始往前查找</div></pre></td></tr></table></figure></p>\n<h2 id=\"迭代方法\"><a href=\"#迭代方法\" class=\"headerlink\" title=\"迭代方法\"></a>迭代方法</h2><h3 id=\"forEach\"><a href=\"#forEach\" class=\"headerlink\" title=\"forEach\"></a>forEach</h3><p><code>forEach()</code> 对数组中每一项运行指定函数，没有返回值。等同于 <code>for</code> 语句：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">let value = [1,2,3,4,5]</div><div class=\"line\">value.forEach( (item, index) =&gt; &#123;</div><div class=\"line\">    console.log(item, index)</div><div class=\"line\">&#125;)</div><div class=\"line\">// 输出</div><div class=\"line\">// 1 0</div><div class=\"line\">// 2 1</div><div class=\"line\">// 3 2</div><div class=\"line\">// 4 3</div><div class=\"line\">// 5 4</div></pre></td></tr></table></figure></p>\n<h3 id=\"every\"><a href=\"#every\" class=\"headerlink\" title=\"every\"></a>every</h3><p><code>every()</code> 对数组每一项运行指定函数，若对任意所有函数都返回 <code>true</code>， 则返回 <code>true</code>。与逻辑与操作符很相似：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">let value = [1,2,3,4,5]</div><div class=\"line\">value.every( item =&gt; &#123;</div><div class=\"line\">    return item &gt; 0</div><div class=\"line\">&#125;) // true</div></pre></td></tr></table></figure></p>\n<h3 id=\"some\"><a href=\"#some\" class=\"headerlink\" title=\"some\"></a>some</h3><p><code>some()</code> 对数组每一项运行指定函数，若存在函数返回 <code>true</code>，则返回 <code>true</code>。与逻辑或操作符很相似：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">let value = [1,2,3,4,5]</div><div class=\"line\">value.some( item =&gt; &#123;</div><div class=\"line\">    return item &gt; 4</div><div class=\"line\">&#125;) // true</div></pre></td></tr></table></figure></p>\n<h3 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h3><p><code>map()</code> 对数组每一项运行指定函数，返回由每一项函数的返回值组成的新数组：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">let value = [1,2,3,4,5]</div><div class=\"line\">value.map( item =&gt; &#123;</div><div class=\"line\">    return item + 1</div><div class=\"line\">&#125;) // [2,3,4,5,6]</div></pre></td></tr></table></figure></p>\n<h3 id=\"filter\"><a href=\"#filter\" class=\"headerlink\" title=\"filter\"></a>filter</h3><p><code>filter()</code> 对数组每一项运行指定函数，返回每一项函数返回值为 <code>true</code> 的项组成的新数组：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">let value = [1,2,3,4,5]</div><div class=\"line\">value.map( item =&gt; &#123;</div><div class=\"line\">    return item &lt; 3</div><div class=\"line\">&#125;) // [1,2]</div></pre></td></tr></table></figure></p>\n<h2 id=\"归并方法\"><a href=\"#归并方法\" class=\"headerlink\" title=\"归并方法\"></a>归并方法</h2><h3 id=\"reduce\"><a href=\"#reduce\" class=\"headerlink\" title=\"reduce()\"></a>reduce()</h3><p><code>reduce()</code> 接受一个函数，函数接受4个参数，分别是 前一个值，当前值，项的索引和数组对象。<br><code>reduce()</code> 方法能够遍历整个数组，并将上一个函数的返回值作为第一个参数传给下一个函数：<br>let value = [1,2,3,4,5]<br>let sum = value.reduce((prev, cur, index, array){<br>    return prev + cur<br>})<br>console.log(sum ) // 15</p>\n<h3 id=\"reduceRight\"><a href=\"#reduceRight\" class=\"headerlink\" title=\"reduceRight()\"></a>reduceRight()</h3><p><code>reduceRight()</code> 与 <code>reduce()</code> 基本一致，只是前者从后向前归并。</p>\n<h2 id=\"ES6-新方法（部分）\"><a href=\"#ES6-新方法（部分）\" class=\"headerlink\" title=\"ES6 新方法（部分）\"></a>ES6 新方法（部分）</h2><h3 id=\"Array-of\"><a href=\"#Array-of\" class=\"headerlink\" title=\"Array.of()\"></a>Array.of()</h3><p><code>Array.of()</code> 方法用于创建一个数组。<br>之前我们提到，创建数组的方式由两种，一是通过构造函数，二是通过字面量的形式。<br>然而通过构造函数的方式有一个令人迷惑的地方：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">let array = new Array(2)</div><div class=\"line\">console.log(array.length) // 2</div><div class=\"line\">console.log(array) // [undefined, undefined]</div></pre></td></tr></table></figure></p>\n<p>当给构造函数传入一个数字时，构造函数会返回一个长度为该数字的数组，并用 undefined 填充。<br>而当给构造函数传入一个字符串时，则会创建一个长度为1，元素为该字符串的数组：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">let array = new Array(&apos;2&apos;)</div><div class=\"line\">console.log(array.length) // 1</div><div class=\"line\">console.log(array) // [&apos;2&apos;]</div></pre></td></tr></table></figure></p>\n<p>这样就让我们很难用构造函数来创建只有一个数字的数组了。</p>\n<p>为了让创建数组的行为更加一致， <code>Array.of()</code> 去除了数组构造函数当传入一个数字时的情况：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">let array = Array.of(2)</div><div class=\"line\">console.log(array.length) // 1</div><div class=\"line\">console.log(array.) // [2]</div></pre></td></tr></table></figure></p>\n<p>这样子，构造数组的方式就更加统一，无需我们去判断只传入一个参数时，参数的类型了。</p>\n<h3 id=\"Array-from\"><a href=\"#Array-from\" class=\"headerlink\" title=\"Array.from()\"></a>Array.from()</h3><p><code>Array.form()</code> 方法可以接受可迭代对象或类数组对象作为第一个参数，第二个参数接受一个映射函数，来对第一个参数中的每一个值进行映射转换：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">void function f_1()&#123;</div><div class=\"line\">    let array = Array.from(arguments)</div><div class=\"line\">    console.log(array)</div><div class=\"line\">&#125;(1,2,3,4) // [1,2,3,4]</div><div class=\"line\"></div><div class=\"line\">void function f_2()&#123;</div><div class=\"line\">    let array = Array.from(arguments, value =&gt; value + 1)</div><div class=\"line\">    console.log(array)</div><div class=\"line\">&#125;(1,2,3,4) // [2,3,4,5]</div></pre></td></tr></table></figure></p>\n<h3 id=\"Array-find\"><a href=\"#Array-find\" class=\"headerlink\" title=\"Array.find()\"></a>Array.find()</h3><p><code>Array.find()</code> 方法接受一个函数作为参数，用于获取满足某一条件的数组元素：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">let value = [1,2,3,4,5]</div><div class=\"line\">value.find(item =&gt; item &gt; 3) // 4</div></pre></td></tr></table></figure></p>\n<h3 id=\"Array-findIndex\"><a href=\"#Array-findIndex\" class=\"headerlink\" title=\"Array.findIndex()\"></a>Array.findIndex()</h3><p><code>Array.findIndex()</code> 与 <code>Array.find()</code> 的用法一致，只是前者返回的是查找到的元素下标：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">let value = [1,2,3,4,5]</div><div class=\"line\">value.find(item =&gt; item &gt; 3) // 3</div></pre></td></tr></table></figure></p>\n<h3 id=\"Array-fill\"><a href=\"#Array-fill\" class=\"headerlink\" title=\"Array.fill()\"></a>Array.fill()</h3><p><code>Array.fill()</code> 可以用指定的值填充若干个数组元素。<br>其接受三个参数，第一个参数是需要替换的值，第二个和第三个是起始下标和结束下标（不包含结束下标对应的值）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">let value = [1,2,3,4]</div><div class=\"line\">value.fill(0) // [0,0,0,0]</div><div class=\"line\"></div><div class=\"line\">value.fill(-1, 1) // [0, -1, -1, -1]</div><div class=\"line\">value.fill(-2, 1, 3) // [0, -2, -2, -1]</div></pre></td></tr></table></figure></p>\n"},{"title":"奇怪的JavaScript（1）：基础类型篇","date":"2017-08-03T16:44:12.000Z","_content":"\n## 前言\nJavaScript 是一门很奇怪的语言，它看起来很“随便”，一个变量可以赋值数字也可以赋值字符串，一个对象竟然用一对花括号就可以创建出来。\n然而正是在这种“随便”的特点之下，造就了 JavaScript 无比灵活的姿态。它有着性感的体态，却也有着诡异的性格，让人琢磨不透。\n那么就让我们来盘点一下，JavaScript 那些奇怪的地方吧。\n\n## 1、tpyeof null; // object\n`typeof` 是一个用于类型判断的操作符，而 null 则是五大基本数据类型之一，然而 `typeof null` 却出乎了很多初学者的预料。\n没错，这个表达式返回居然是 `'object'`！\n这个表达式在《JS高程》中也有特意提到，尽管 `null` 被视作对象的占位符，因此返回的是对象在技术角度上来讲是合理的，但是不得不说这个“特例”会让人觉得相当迷惑。\n\n## 2、null == undefined; // true\n返回的是 `true`，其原因是 `undefined` 派生自 `null`，在不严格的比较下两者是相等的。\n反正我是没在别的语言见过这种操作啦。\n\n## 3、Boolean(false) == true; // true\n`Boolean(false)` 是一个包装对象，既然是对象那么它在不严格相等的情况都会转换成 `true`。\n你可以用 `Boolean(false).valueOf()` 来获取真正的 `false` 值。\n\n## 4、0.1 + 0.2 == 0.3; // false\n“浮点数值的最高精度是17位小数，但在进行算术计算时其精确度远远不如整数”\n因此，`0.1 + 0.2` 等于 `0.30000000000000004`，而不等于 `0.3` 。\n这个其实在所有语言的浮点数运算中都会有类似的问题。\n\n## 5、NaN == NaN; // false\nNaN（Not a Number），有两个特点：\n一是与其任何的操作都返回 `NaN`；\n二是 `NaN` 与任何值都不相等。\n所以 `NaN != NaN` 是成立的。\n还有就是当 `0 / 0` 时也会返回 `NaN`。\n\n## 6、\"23\" < \"3\"; // true\n尽管 JS 在进行比较的时候会进行类型转换，但是在直接比较字符串的时候，它可能并不想我们预想中的那样子会直接比较“数值”（因为并没有被转换成数值）。\n两个字符串进行大小比较时，比较的是字符编码。`'3'`的字符编码在`'2'`的后面，所以 `\"23\" < \"3\"` 返回的是 `true`。\n需要注意的是，当比较的两个操作数，有一个是数字时，另一个字符串会被转换成数值。如：\n```\n\"23\" < 3 // false\n```\n与\n```\n23 < 3 // false\n```\n是等价的。","source":"_posts/奇怪的JavaScript（1）.md","raw":"---\ntitle: 奇怪的JavaScript（1）：基础类型篇\ndate: 2017-08-04 00:44:12\ntags: javascript\n---\n\n## 前言\nJavaScript 是一门很奇怪的语言，它看起来很“随便”，一个变量可以赋值数字也可以赋值字符串，一个对象竟然用一对花括号就可以创建出来。\n然而正是在这种“随便”的特点之下，造就了 JavaScript 无比灵活的姿态。它有着性感的体态，却也有着诡异的性格，让人琢磨不透。\n那么就让我们来盘点一下，JavaScript 那些奇怪的地方吧。\n\n## 1、tpyeof null; // object\n`typeof` 是一个用于类型判断的操作符，而 null 则是五大基本数据类型之一，然而 `typeof null` 却出乎了很多初学者的预料。\n没错，这个表达式返回居然是 `'object'`！\n这个表达式在《JS高程》中也有特意提到，尽管 `null` 被视作对象的占位符，因此返回的是对象在技术角度上来讲是合理的，但是不得不说这个“特例”会让人觉得相当迷惑。\n\n## 2、null == undefined; // true\n返回的是 `true`，其原因是 `undefined` 派生自 `null`，在不严格的比较下两者是相等的。\n反正我是没在别的语言见过这种操作啦。\n\n## 3、Boolean(false) == true; // true\n`Boolean(false)` 是一个包装对象，既然是对象那么它在不严格相等的情况都会转换成 `true`。\n你可以用 `Boolean(false).valueOf()` 来获取真正的 `false` 值。\n\n## 4、0.1 + 0.2 == 0.3; // false\n“浮点数值的最高精度是17位小数，但在进行算术计算时其精确度远远不如整数”\n因此，`0.1 + 0.2` 等于 `0.30000000000000004`，而不等于 `0.3` 。\n这个其实在所有语言的浮点数运算中都会有类似的问题。\n\n## 5、NaN == NaN; // false\nNaN（Not a Number），有两个特点：\n一是与其任何的操作都返回 `NaN`；\n二是 `NaN` 与任何值都不相等。\n所以 `NaN != NaN` 是成立的。\n还有就是当 `0 / 0` 时也会返回 `NaN`。\n\n## 6、\"23\" < \"3\"; // true\n尽管 JS 在进行比较的时候会进行类型转换，但是在直接比较字符串的时候，它可能并不想我们预想中的那样子会直接比较“数值”（因为并没有被转换成数值）。\n两个字符串进行大小比较时，比较的是字符编码。`'3'`的字符编码在`'2'`的后面，所以 `\"23\" < \"3\"` 返回的是 `true`。\n需要注意的是，当比较的两个操作数，有一个是数字时，另一个字符串会被转换成数值。如：\n```\n\"23\" < 3 // false\n```\n与\n```\n23 < 3 // false\n```\n是等价的。","slug":"奇怪的JavaScript（1）","published":1,"updated":"2017-08-06T12:15:59.000Z","_id":"cj60bzxlh001l1dor7kvn4tim","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>JavaScript 是一门很奇怪的语言，它看起来很“随便”，一个变量可以赋值数字也可以赋值字符串，一个对象竟然用一对花括号就可以创建出来。<br>然而正是在这种“随便”的特点之下，造就了 JavaScript 无比灵活的姿态。它有着性感的体态，却也有着诡异的性格，让人琢磨不透。<br>那么就让我们来盘点一下，JavaScript 那些奇怪的地方吧。</p>\n<h2 id=\"1、tpyeof-null-object\"><a href=\"#1、tpyeof-null-object\" class=\"headerlink\" title=\"1、tpyeof null; // object\"></a>1、tpyeof null; // object</h2><p><code>typeof</code> 是一个用于类型判断的操作符，而 null 则是五大基本数据类型之一，然而 <code>typeof null</code> 却出乎了很多初学者的预料。<br>没错，这个表达式返回居然是 <code>&#39;object&#39;</code>！<br>这个表达式在《JS高程》中也有特意提到，尽管 <code>null</code> 被视作对象的占位符，因此返回的是对象在技术角度上来讲是合理的，但是不得不说这个“特例”会让人觉得相当迷惑。</p>\n<h2 id=\"2、null-undefined-true\"><a href=\"#2、null-undefined-true\" class=\"headerlink\" title=\"2、null == undefined; // true\"></a>2、null == undefined; // true</h2><p>返回的是 <code>true</code>，其原因是 <code>undefined</code> 派生自 <code>null</code>，在不严格的比较下两者是相等的。<br>反正我是没在别的语言见过这种操作啦。</p>\n<h2 id=\"3、Boolean-false-true-true\"><a href=\"#3、Boolean-false-true-true\" class=\"headerlink\" title=\"3、Boolean(false) == true; // true\"></a>3、Boolean(false) == true; // true</h2><p><code>Boolean(false)</code> 是一个包装对象，既然是对象那么它在不严格相等的情况都会转换成 <code>true</code>。<br>你可以用 <code>Boolean(false).valueOf()</code> 来获取真正的 <code>false</code> 值。</p>\n<h2 id=\"4、0-1-0-2-0-3-false\"><a href=\"#4、0-1-0-2-0-3-false\" class=\"headerlink\" title=\"4、0.1 + 0.2 == 0.3; // false\"></a>4、0.1 + 0.2 == 0.3; // false</h2><p>“浮点数值的最高精度是17位小数，但在进行算术计算时其精确度远远不如整数”<br>因此，<code>0.1 + 0.2</code> 等于 <code>0.30000000000000004</code>，而不等于 <code>0.3</code> 。<br>这个其实在所有语言的浮点数运算中都会有类似的问题。</p>\n<h2 id=\"5、NaN-NaN-false\"><a href=\"#5、NaN-NaN-false\" class=\"headerlink\" title=\"5、NaN == NaN; // false\"></a>5、NaN == NaN; // false</h2><p>NaN（Not a Number），有两个特点：<br>一是与其任何的操作都返回 <code>NaN</code>；<br>二是 <code>NaN</code> 与任何值都不相等。<br>所以 <code>NaN != NaN</code> 是成立的。<br>还有就是当 <code>0 / 0</code> 时也会返回 <code>NaN</code>。</p>\n<h2 id=\"6、”23”-lt-“3”-true\"><a href=\"#6、”23”-lt-“3”-true\" class=\"headerlink\" title=\"6、”23” &lt; “3”; // true\"></a>6、”23” &lt; “3”; // true</h2><p>尽管 JS 在进行比较的时候会进行类型转换，但是在直接比较字符串的时候，它可能并不想我们预想中的那样子会直接比较“数值”（因为并没有被转换成数值）。<br>两个字符串进行大小比较时，比较的是字符编码。<code>&#39;3&#39;</code>的字符编码在<code>&#39;2&#39;</code>的后面，所以 <code>&quot;23&quot; &lt; &quot;3&quot;</code> 返回的是 <code>true</code>。<br>需要注意的是，当比较的两个操作数，有一个是数字时，另一个字符串会被转换成数值。如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&quot;23&quot; &lt; 3 // false</div></pre></td></tr></table></figure></p>\n<p>与<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">23 &lt; 3 // false</div></pre></td></tr></table></figure></p>\n<p>是等价的。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>JavaScript 是一门很奇怪的语言，它看起来很“随便”，一个变量可以赋值数字也可以赋值字符串，一个对象竟然用一对花括号就可以创建出来。<br>然而正是在这种“随便”的特点之下，造就了 JavaScript 无比灵活的姿态。它有着性感的体态，却也有着诡异的性格，让人琢磨不透。<br>那么就让我们来盘点一下，JavaScript 那些奇怪的地方吧。</p>\n<h2 id=\"1、tpyeof-null-object\"><a href=\"#1、tpyeof-null-object\" class=\"headerlink\" title=\"1、tpyeof null; // object\"></a>1、tpyeof null; // object</h2><p><code>typeof</code> 是一个用于类型判断的操作符，而 null 则是五大基本数据类型之一，然而 <code>typeof null</code> 却出乎了很多初学者的预料。<br>没错，这个表达式返回居然是 <code>&#39;object&#39;</code>！<br>这个表达式在《JS高程》中也有特意提到，尽管 <code>null</code> 被视作对象的占位符，因此返回的是对象在技术角度上来讲是合理的，但是不得不说这个“特例”会让人觉得相当迷惑。</p>\n<h2 id=\"2、null-undefined-true\"><a href=\"#2、null-undefined-true\" class=\"headerlink\" title=\"2、null == undefined; // true\"></a>2、null == undefined; // true</h2><p>返回的是 <code>true</code>，其原因是 <code>undefined</code> 派生自 <code>null</code>，在不严格的比较下两者是相等的。<br>反正我是没在别的语言见过这种操作啦。</p>\n<h2 id=\"3、Boolean-false-true-true\"><a href=\"#3、Boolean-false-true-true\" class=\"headerlink\" title=\"3、Boolean(false) == true; // true\"></a>3、Boolean(false) == true; // true</h2><p><code>Boolean(false)</code> 是一个包装对象，既然是对象那么它在不严格相等的情况都会转换成 <code>true</code>。<br>你可以用 <code>Boolean(false).valueOf()</code> 来获取真正的 <code>false</code> 值。</p>\n<h2 id=\"4、0-1-0-2-0-3-false\"><a href=\"#4、0-1-0-2-0-3-false\" class=\"headerlink\" title=\"4、0.1 + 0.2 == 0.3; // false\"></a>4、0.1 + 0.2 == 0.3; // false</h2><p>“浮点数值的最高精度是17位小数，但在进行算术计算时其精确度远远不如整数”<br>因此，<code>0.1 + 0.2</code> 等于 <code>0.30000000000000004</code>，而不等于 <code>0.3</code> 。<br>这个其实在所有语言的浮点数运算中都会有类似的问题。</p>\n<h2 id=\"5、NaN-NaN-false\"><a href=\"#5、NaN-NaN-false\" class=\"headerlink\" title=\"5、NaN == NaN; // false\"></a>5、NaN == NaN; // false</h2><p>NaN（Not a Number），有两个特点：<br>一是与其任何的操作都返回 <code>NaN</code>；<br>二是 <code>NaN</code> 与任何值都不相等。<br>所以 <code>NaN != NaN</code> 是成立的。<br>还有就是当 <code>0 / 0</code> 时也会返回 <code>NaN</code>。</p>\n<h2 id=\"6、”23”-lt-“3”-true\"><a href=\"#6、”23”-lt-“3”-true\" class=\"headerlink\" title=\"6、”23” &lt; “3”; // true\"></a>6、”23” &lt; “3”; // true</h2><p>尽管 JS 在进行比较的时候会进行类型转换，但是在直接比较字符串的时候，它可能并不想我们预想中的那样子会直接比较“数值”（因为并没有被转换成数值）。<br>两个字符串进行大小比较时，比较的是字符编码。<code>&#39;3&#39;</code>的字符编码在<code>&#39;2&#39;</code>的后面，所以 <code>&quot;23&quot; &lt; &quot;3&quot;</code> 返回的是 <code>true</code>。<br>需要注意的是，当比较的两个操作数，有一个是数字时，另一个字符串会被转换成数值。如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&quot;23&quot; &lt; 3 // false</div></pre></td></tr></table></figure></p>\n<p>与<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">23 &lt; 3 // false</div></pre></td></tr></table></figure></p>\n<p>是等价的。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cj60bzxl4000z1dorjqifgpap","category_id":"cj60bzxlc001c1dorioezt843","_id":"cj60bzxlr00221dorxp64zc90"}],"PostTag":[{"post_id":"cj60bzxlg001j1dor37l1ieo9","tag_id":"cj60bzxli001m1dorcw9ej0sr","_id":"cj60bzxlk001r1doribwcp85o"},{"post_id":"cj60bzxlf001g1dors87vaiej","tag_id":"cj60bzxli001m1dorcw9ej0sr","_id":"cj60otyvk0000mior9jf8gai3"},{"post_id":"cj60bzxk600001dorj89n6wm7","tag_id":"cj60p0bqk0000wworpoz7kwei","_id":"cj60p0bqu0002wworbaki17ue"},{"post_id":"cj60bzxkb00011dora9q1u9wb","tag_id":"cj60p0bqk0000wworpoz7kwei","_id":"cj60p0br00004wworpa42re9l"},{"post_id":"cj60bzxke00031doruwuu5vxj","tag_id":"cj60p0bqz0003wworgbagyaql","_id":"cj60p0br60006wword2qcaqe0"},{"post_id":"cj60bzxkh00041dord46ns8ay","tag_id":"cj60p0br40005wworqo6g8bc0","_id":"cj60p0br90008wworc7s6ebmx"},{"post_id":"cj60bzxks000j1dorj0r53adw","tag_id":"cj60bzxli001m1dorcw9ej0sr","_id":"cj60p0brd0009wworfrm8wy0m"},{"post_id":"cj60bzxki00051dorbpu9nox6","tag_id":"cj60p0br80007wwor4zdtdrsc","_id":"cj60p0bre000bwwor3yzwfqlf"},{"post_id":"cj60bzxkm00091doril276aun","tag_id":"cj60p0br80007wwor4zdtdrsc","_id":"cj60p0brg000dwworf2w185h5"},{"post_id":"cj60bzxku000k1dorpwvnuqje","tag_id":"cj60p0bqz0003wworgbagyaql","_id":"cj60p0brg000ewworlzrd659o"},{"post_id":"cj60bzxl1000t1dor8n3l34hk","tag_id":"cj60bzxli001m1dorcw9ej0sr","_id":"cj60p0bri000gwwor6l240cxl"},{"post_id":"cj60bzxkn000b1dor2co5sa4q","tag_id":"cj60p0brf000cwworjm7pu6u3","_id":"cj60p0brj000hwwor2h2o2yvy"},{"post_id":"cj60bzxl2000w1dordwdiqwco","tag_id":"cj60bzxli001m1dorcw9ej0sr","_id":"cj60p0brk000jwwors2015102"},{"post_id":"cj60bzxl3000x1dor3mgo5pn2","tag_id":"cj60bzxli001m1dorcw9ej0sr","_id":"cj60p0brl000kwwor0i2r15nk"},{"post_id":"cj60bzxkl00071dor1qi3qqoh","tag_id":"cj60p0br80007wwor4zdtdrsc","_id":"cj60p0brm000mwworz5d7uxdw"},{"post_id":"cj60bzxl800131dor1qb9hkjs","tag_id":"cj60bzxli001m1dorcw9ej0sr","_id":"cj60p0bro000nwworn1oqf23a"},{"post_id":"cj60bzxkp000d1dorkzss7csy","tag_id":"cj60p0brk000iwwor12vbytf9","_id":"cj60p0brp000pwworv3hnr6z5"},{"post_id":"cj60bzxl900151dorx35wkekt","tag_id":"cj60p0br80007wwor4zdtdrsc","_id":"cj60p0brt000qwworhwu3zksm"},{"post_id":"cj60bzxla00161dorbhx32z3f","tag_id":"cj60p0br80007wwor4zdtdrsc","_id":"cj60p0bru000swworv6w6k4jp"},{"post_id":"cj60bzxkp000f1dor1ghp5u3k","tag_id":"cj60p0brm000lwworovm01rni","_id":"cj60p0brw000twwor5glyzqda"},{"post_id":"cj60bzxlc001b1dorxzhocf2j","tag_id":"cj60p0br80007wwor4zdtdrsc","_id":"cj60p0bry000uwwor8k95ovl6"},{"post_id":"cj60bzxkr000g1doryl2l03f4","tag_id":"cj60p0brm000lwworovm01rni","_id":"cj60p0bs2000wwworibgvi6k9"},{"post_id":"cj60bzxlh001l1dor7kvn4tim","tag_id":"cj60bzxli001m1dorcw9ej0sr","_id":"cj60p0bs3000xwworabhwztym"},{"post_id":"cj60bzxkx000n1dorkxmsgb10","tag_id":"cj60p0bru000rwworp7x6q519","_id":"cj60p0bs3000zwwor5rxm9s1l"},{"post_id":"cj60bzxky000o1dorelka49s1","tag_id":"cj60p0brz000vwwor77why0as","_id":"cj60p0bs30010wworz8l2243z"},{"post_id":"cj60bzxkz000r1dorw8bzxypq","tag_id":"cj60p0brz000vwwor77why0as","_id":"cj60p0bsb0012wwor19lf3fmk"},{"post_id":"cj60bzxl500111dor7opnoi2v","tag_id":"cj60p0bru000rwworp7x6q519","_id":"cj60p0bsb0014wwortdcxqb44"},{"post_id":"cj60bzxlb00191dormk6720gq","tag_id":"cj60p0bsb0013wwormebcm3r4","_id":"cj60p0bsb0016wwory4ubdyr6"},{"post_id":"cj60bzxld001e1dorrcnda6ut","tag_id":"cj60p0bsb0015wwore91tqikx","_id":"cj60p0bsc0017wwory74eksjg"}],"Tag":[{"name":"javascript","_id":"cj60bzxli001m1dorcw9ej0sr"},{"name":"svn","_id":"cj60p0bqk0000wworpoz7kwei"},{"name":"react","_id":"cj60p0bqz0003wworgbagyaql"},{"name":"git","_id":"cj60p0br40005wworqo6g8bc0"},{"name":"css","_id":"cj60p0br80007wwor4zdtdrsc"},{"name":"sublime","_id":"cj60p0brf000cwworjm7pu6u3"},{"name":"mac","_id":"cj60p0brk000iwwor12vbytf9"},{"name":"http","_id":"cj60p0brm000lwworovm01rni"},{"name":"fe","_id":"cj60p0bru000rwworp7x6q519"},{"name":"jquery","_id":"cj60p0brz000vwwor77why0as"},{"name":"vue","_id":"cj60p0bsb0013wwormebcm3r4"},{"name":"shell","_id":"cj60p0bsb0015wwore91tqikx"}]}}